# 1 "services.cpp"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "services.cpp"
# 10 "services.cpp"
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++config.h" 1 3
# 34 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++config.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/os_defines.h" 1 3
# 72 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/os_defines.h" 3
extern "C" {
# 83 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/os_defines.h" 3
typedef enum node_kinds {
        NODE_THREAD_SPECIFIC_DATA=1,
        NODE_PROCESSWIDE_PTR=2,
        NODE_LAST_KIND
        } TnodeKind ;





typedef enum node_mode {
        NM_ALLOW_RECURSION=1,
        NM_RECURSION_ILLEGAL=2,
        NM_ENHANCED_LOCKING=3,
        NM_LOCKED=4
        } TnodeMode ;



extern void * _keymgr_get_per_thread_data(unsigned int key) ;
extern void _keymgr_set_per_thread_data(unsigned int key, void *keydata) ;
extern void *_keymgr_get_and_lock_processwide_ptr(unsigned int key) ;
extern void _keymgr_set_and_unlock_processwide_ptr(unsigned int key, void *ptr) ;
extern void _keymgr_unlock_processwide_ptr(unsigned int key) ;
extern void _keymgr_set_lockmode_processwide_ptr(unsigned int key, unsigned int mode) ;
extern unsigned int _keymgr_get_lockmode_processwide_ptr(unsigned int key) ;
extern int _keymgr_get_lock_count_processwide_ptr(unsigned int key) ;
# 155 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/os_defines.h" 3
}
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++config.h" 2 3
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ostream" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/ostream" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/iosfwd" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/iosfwd" 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stringfwd.h" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stringfwd.h" 3



namespace std
{
  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;




  template<typename _Alloc>
    class allocator;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  typedef basic_string<char> string;
  typedef basic_string<wchar_t> wstring;
}
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/iosfwd" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/fpos.h" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/bits/fpos.h" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++io.h" 1 3
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++io.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cstdio" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cstdio" 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cstddef" 1 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/cstddef" 3

# 1 "/usr/include/stddef.h" 1 3 4
# 63 "/usr/include/stddef.h" 3 4
# 1 "/usr/include/machine/types.h" 1 3 4
# 30 "/usr/include/machine/types.h" 3 4
# 1 "/usr/include/ppc/types.h" 1 3 4
# 64 "/usr/include/ppc/types.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 65 "/usr/include/ppc/types.h" 2 3 4




typedef signed char int8_t;
typedef unsigned char u_int8_t;
typedef short int16_t;
typedef unsigned short u_int16_t;
typedef int int32_t;
typedef unsigned int u_int32_t;
typedef long long int64_t;
typedef unsigned long long u_int64_t;

typedef int32_t register_t;

typedef long int intptr_t;
typedef unsigned long int uintptr_t;
# 31 "/usr/include/machine/types.h" 2 3 4
# 64 "/usr/include/stddef.h" 2 3 4
# 1 "/usr/include/machine/ansi.h" 1 3 4
# 33 "/usr/include/machine/ansi.h" 3 4
# 1 "/usr/include/ppc/ansi.h" 1 3 4
# 92 "/usr/include/ppc/ansi.h" 3 4
typedef union {
        char __mbstate8[128];
        long long _mbstateL;
} __mbstate_t;
# 34 "/usr/include/machine/ansi.h" 2 3 4
# 65 "/usr/include/stddef.h" 2 3 4

typedef int ptrdiff_t;



typedef long unsigned int size_t;





typedef int rune_t;





typedef int wchar_t;
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/cstddef" 2 3

namespace std
{
  using ::ptrdiff_t;
  using ::size_t;
}
# 51 "/usr/include/gcc/darwin/3.1/g++-v3/cstdio" 2 3

# 1 "/usr/include/stdio.h" 1 3 4
# 64 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/sys/types.h" 1 3 4
# 66 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/appleapiopts.h" 1 3 4
# 67 "/usr/include/sys/types.h" 2 3 4
# 75 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/machine/endian.h" 1 3 4
# 30 "/usr/include/machine/endian.h" 3 4
# 1 "/usr/include/ppc/endian.h" 1 3 4
# 81 "/usr/include/ppc/endian.h" 3 4
extern "C" {
unsigned long htonl (unsigned long);
unsigned short htons (unsigned short);
unsigned long ntohl (unsigned long);
unsigned short ntohs (unsigned short);
}
# 31 "/usr/include/machine/endian.h" 2 3 4
# 76 "/usr/include/sys/types.h" 2 3 4


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

typedef char * caddr_t;
typedef int32_t daddr_t;
typedef int32_t dev_t;
typedef u_int32_t fixpt_t;
typedef u_int32_t gid_t;
typedef u_int32_t in_addr_t;
typedef u_int16_t in_port_t;
typedef u_int32_t ino_t;
typedef long key_t;
typedef u_int16_t mode_t;
typedef u_int16_t nlink_t;
typedef quad_t off_t;
typedef int32_t pid_t;
typedef quad_t rlim_t;
typedef int32_t segsz_t;
typedef int32_t swblk_t;
typedef u_int32_t uid_t;
# 117 "/usr/include/sys/types.h" 3 4
typedef unsigned long clock_t;
# 127 "/usr/include/sys/types.h" 3 4
typedef int ssize_t;




typedef long time_t;
# 146 "/usr/include/sys/types.h" 3 4
typedef int32_t fd_mask;






typedef struct fd_set {
        fd_mask fds_bits[(((1024) + (((sizeof(fd_mask) * 8)) - 1)) / ((sizeof(fd_mask) * 8)))];
} fd_set;
# 182 "/usr/include/sys/types.h" 3 4
struct _pthread_handler_rec
{
        void (*routine)(void *);
        void *arg;
        struct _pthread_handler_rec *next;
};
# 202 "/usr/include/sys/types.h" 3 4
typedef struct _opaque_pthread_t { long sig; struct _pthread_handler_rec *cleanup_stack; char opaque[596];} *pthread_t;

typedef struct _opaque_pthread_attr_t { long sig; char opaque[36]; } pthread_attr_t;

typedef struct _opaque_pthread_mutexattr_t { long sig; char opaque[8]; } pthread_mutexattr_t;

typedef struct _opaque_pthread_mutex_t { long sig; char opaque[40]; } pthread_mutex_t;

typedef struct _opaque_pthread_condattr_t { long sig; char opaque[4]; } pthread_condattr_t;

typedef struct _opaque_pthread_cond_t { long sig; char opaque[24]; } pthread_cond_t;

typedef struct _opaque_pthread_rwlockattr_t { long sig; char opaque[12]; } pthread_rwlockattr_t;

typedef struct _opaque_pthread_rwlock_t { long sig; char opaque[124]; } pthread_rwlock_t;

typedef struct { long sig; char opaque[4]; } pthread_once_t;



typedef unsigned long pthread_key_t;
# 65 "/usr/include/stdio.h" 2 3 4
# 91 "/usr/include/stdio.h" 3 4
typedef off_t fpos_t;
# 107 "/usr/include/stdio.h" 3 4
struct __sbuf {
        unsigned char *_base;
        int _size;
};
# 138 "/usr/include/stdio.h" 3 4
typedef struct __sFILE {
        unsigned char *_p;
        int _r;
        int _w;
        short _flags;
        short _file;
        struct __sbuf _bf;
        int _lbfsize;


        void *_cookie;
        int (*_close) (void *);
        int (*_read) (void *, char *, int);
        fpos_t (*_seek) (void *, fpos_t, int);
        int (*_write) (void *, const char *, int);


        struct __sbuf _ub;
        unsigned char *_up;
        int _ur;


        unsigned char _ubuf[3];
        unsigned char _nbuf[1];


        struct __sbuf _lb;


        int _blksize;
        fpos_t _offset;
} FILE;

extern "C" {
extern FILE __sF[];
}
# 241 "/usr/include/stdio.h" 3 4
extern "C" {
void clearerr (FILE *);
int fclose (FILE *);
int feof (FILE *);
int ferror (FILE *);
int fflush (FILE *);
int fgetc (FILE *);
int fgetpos (FILE *, fpos_t *);
char *fgets (char *, int, FILE *);
FILE *fopen (const char *, const char *);
int fprintf (FILE *, const char *, ...);
int fputc (int, FILE *);
int fputs (const char *, FILE *);
size_t fread (void *, size_t, size_t, FILE *);
FILE *freopen (const char *, const char *, FILE *);
int fscanf (FILE *, const char *, ...);
int fseek (FILE *, long, int);
int fsetpos (FILE *, const fpos_t *);
long ftell (FILE *);
size_t fwrite (const void *, size_t, size_t, FILE *);
int getc (FILE *);
int getchar (void);
char *gets (char *);

extern const int sys_nerr;
extern const char *const sys_errlist[];

void perror (const char *);
int printf (const char *, ...);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int remove (const char *);
int rename (const char *, const char *);
void rewind (FILE *);
int scanf (const char *, ...);
void setbuf (FILE *, char *);
int setvbuf (FILE *, char *, int, size_t);
int sprintf (char *, const char *, ...);
int sscanf (const char *, const char *, ...);
FILE *tmpfile (void);
char *tmpnam (char *);
int ungetc (int, FILE *);
int vfprintf (FILE *, const char *, __builtin_va_list);
int vprintf (const char *, __builtin_va_list);
int vsprintf (char *, const char *, __builtin_va_list);
int asprintf (char **, const char *, ...);
int vasprintf (char **, const char *, __builtin_va_list);
}
# 298 "/usr/include/stdio.h" 3 4
extern "C" {
char *ctermid (char *);
FILE *fdopen (int, const char *);
int fileno (FILE *);
}






extern "C" {
char *fgetln (FILE *, size_t *);
int fpurge (FILE *);
int fseeko (FILE *, fpos_t, int);
fpos_t ftello (FILE *);
int getw (FILE *);
int pclose (FILE *);
FILE *popen (const char *, const char *);
int putw (int, FILE *);
void setbuffer (FILE *, char *, int);
int setlinebuf (FILE *);
char *tempnam (const char *, const char *);
int snprintf (char *, size_t, const char *, ...);
int vsnprintf (char *, size_t, const char *, __builtin_va_list);
int vscanf (const char *, __builtin_va_list);
int vsscanf (const char *, const char *, __builtin_va_list);
FILE *zopen (const char *, const char *, int);
}
# 338 "/usr/include/stdio.h" 3 4
extern "C" {
FILE *funopen (const void *, int (*)(void *, char *, int), int (*)(void *, const char *, int), fpos_t (*)(void *, fpos_t, int), int (*)(void *));




}







extern "C" {
int __srget (FILE *);
int __svfscanf (FILE *, const char *, __builtin_va_list);
int __swbuf (int, FILE *);
}







static inline int __sputc(int _c, FILE *_p) {
        if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
                return (*_p->_p++ = _c);
        else
                return (__swbuf(_c, _p));
}
# 53 "/usr/include/gcc/darwin/3.1/g++-v3/cstdio" 2 3
# 97 "/usr/include/gcc/darwin/3.1/g++-v3/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 36 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++io.h" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr.h" 1 3
# 98 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr-default.h" 1 3
# 37 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 34 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/pthread_impl.h" 1 3 4
# 35 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/errno.h" 1 3 4
# 22 "/usr/include/errno.h" 3 4
# 1 "/usr/include/sys/errno.h" 1 3 4
# 68 "/usr/include/sys/errno.h" 3 4
extern "C" {
extern int * __error (void);

}
# 23 "/usr/include/errno.h" 2 3 4
# 37 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 10 "/usr/include/sched.h" 3 4
struct sched_param { int sched_priority; char opaque[4]; };


extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
# 38 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 88 "/usr/include/time.h" 3 4
struct timespec {
        time_t tv_sec;
        long tv_nsec;
};


struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        long tm_gmtoff;
        char *tm_zone;
};

# 1 "/usr/include/gcc/darwin/3.1/machine/limits.h" 1 3 4





# 1 "/usr/include/ppc/limits.h" 1 3 4
# 7 "/usr/include/gcc/darwin/3.1/machine/limits.h" 2 3 4
# 109 "/usr/include/time.h" 2 3 4






extern char *tzname[];


extern "C" {
char *asctime (const struct tm *);
clock_t clock (void);
char *ctime (const time_t *);
double difftime (time_t, time_t);
struct tm *gmtime (const time_t *);
struct tm *localtime (const time_t *);
time_t mktime (struct tm *);
size_t strftime (char *, size_t, const char *, const struct tm *);
time_t time (time_t *);


void tzset (void);



char *asctime_r (const struct tm *, char *);
char *ctime_r (const time_t *, char *);
struct tm *gmtime_r (const time_t *, struct tm *);
struct tm *localtime_r (const time_t *, struct tm *);
char *strptime (const char *, const char *, struct tm *);
char *timezone (int, int);
void tzsetwall (void);
time_t timelocal (struct tm * const);
time_t timegm (struct tm * const);



int nanosleep (const struct timespec *, struct timespec *);

}
# 39 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/unistd.h" 1 3 4
# 72 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/sys/unistd.h" 1 3 4
# 73 "/usr/include/unistd.h" 2 3 4
# 91 "/usr/include/unistd.h" 3 4
extern "C" {
 void
         _exit (int);
int access (const char *, int);
unsigned int alarm (unsigned int);
int chdir (const char *);
int chown (const char *, uid_t, gid_t);
int close (int);
size_t confstr (int, char *, size_t);
int dup (int);
int dup2 (int, int);
int execl (const char *, const char *, ...);
int execle (const char *, const char *, ...);
int execlp (const char *, const char *, ...);
int execv (const char *, char * const *);
int execve (const char *, char * const *, char * const *);
int execvp (const char *, char * const *);
pid_t fork (void);
long fpathconf (int, int);
char *getcwd (char *, size_t);
gid_t getegid (void);
uid_t geteuid (void);
gid_t getgid (void);
int getgroups (int, gid_t []);
char *getlogin (void);
pid_t getpgrp (void);
pid_t getpid (void);
pid_t getppid (void);
uid_t getuid (void);
int isatty (int);
int link (const char *, const char *);
off_t lseek (int, off_t, int);
long pathconf (const char *, int);
int pause (void);
int pipe (int *);
ssize_t read (int, void *, size_t);
int rmdir (const char *);
int setgid (gid_t);
int setpgid (pid_t, pid_t);
pid_t setsid (void);
int setuid (uid_t);
unsigned int sleep (unsigned int);
long sysconf (int);
pid_t tcgetpgrp (int);
int tcsetpgrp (int, pid_t);
char *ttyname (int);
int unlink (const char *);
ssize_t write (int, const void *, size_t);

extern char *optarg;
extern int optind, opterr, optopt, optreset;
int getopt (int, char * const [], const char *);



struct timeval;

int acct (const char *);
int async_daemon (void);
char *brk (const char *);
int chroot (const char *);
char *crypt (const char *, const char *);
int des_cipher (const char *, char *, long, int);
int des_setkey (const char *key);
int encrypt (char *, int);
void endusershell (void);
int exect (const char *, char * const *, char * const *);
int fchdir (int);
int fchown (int, int, int);
char *fflagstostr (u_long);
int fsync (int);
int ftruncate (int, off_t);
int getdtablesize (void);
int getgrouplist (const char *, int, int *, int *);
long gethostid (void);
int gethostname (char *, int);
mode_t getmode (const void *, mode_t);
 int
         getpagesize (void);
char *getpass (const char *);
int getpgid (pid_t _pid);
int getsid (pid_t _pid);
char *getusershell (void);
char *getwd (char *);
int initgroups (const char *, int);
int iruserok (unsigned long, int, const char *, const char *);
int issetugid (void);
char *mkdtemp (char *);
int mknod (const char *, mode_t, dev_t);
int mkstemp (char *);
int mkstemps (char *, int);
char *mktemp (char *);
int nfssvc (int, void *);
int nice (int);
ssize_t pread (int, void *, size_t, off_t);




# 1 "/usr/include/signal.h" 1 3 4
# 62 "/usr/include/signal.h" 3 4
# 1 "/usr/include/sys/signal.h" 1 3 4
# 72 "/usr/include/sys/signal.h" 3 4
# 1 "/usr/include/machine/signal.h" 1 3 4
# 27 "/usr/include/machine/signal.h" 3 4
# 1 "/usr/include/ppc/signal.h" 1 3 4
# 32 "/usr/include/ppc/signal.h" 3 4
typedef int sig_atomic_t;
# 50 "/usr/include/ppc/signal.h" 3 4
typedef enum {
        REGS_SAVED_NONE,
        REGS_SAVED_CALLER,


        REGS_SAVED_ALL
} regs_saved_t;
# 66 "/usr/include/ppc/signal.h" 3 4
struct sigcontext {
    int sc_onstack;
    int sc_mask;
        int sc_ir;
    int sc_psw;
    int sc_sp;
        void *sc_regs;
};
# 28 "/usr/include/machine/signal.h" 2 3 4
# 73 "/usr/include/sys/signal.h" 2 3 4
# 134 "/usr/include/sys/signal.h" 3 4
typedef unsigned int sigset_t;

union sigval {

        int sigval_int;
        void *sigval_ptr;
};







typedef struct __siginfo {
        int si_signo;
        int si_errno;
        int si_code;
        int si_pid;
        unsigned int si_uid;
        int si_status;
        void *si_addr;
        union sigval si_value;
        long si_band;
        int pad[7];
} siginfo_t;
# 208 "/usr/include/sys/signal.h" 3 4
union __sigaction_u {
        void (*__sa_handler)(int);
        void (*__sa_sigaction)(int, struct __siginfo *,
                       void *);
};


struct __sigaction {
        union __sigaction_u __sigaction_u;
        void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
        sigset_t sa_mask;
        int sa_flags;
};




struct sigaction {
        union __sigaction_u __sigaction_u;
        sigset_t sa_mask;
        int sa_flags;
};
# 263 "/usr/include/sys/signal.h" 3 4
typedef void (*sig_t) (int);




struct sigaltstack {
        char *ss_sp;
        int ss_size;
        int ss_flags;
};

typedef struct sigaltstack stack_t;
# 285 "/usr/include/sys/signal.h" 3 4
struct sigvec {
        void (*sv_handler)(int);
        int sv_mask;
        int sv_flags;
};
# 303 "/usr/include/sys/signal.h" 3 4
struct sigstack {
        char *ss_sp;
        int ss_onstack;
};
# 336 "/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal (int, void (*) (int))) (int);
}
# 63 "/usr/include/signal.h" 2 3 4


extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];


extern "C" {
int raise (int);

int kill (pid_t, int);
int sigaction (int, const struct sigaction *, struct sigaction *);
int sigaddset (sigset_t *, int);
int sigdelset (sigset_t *, int);
int sigemptyset (sigset_t *);
int sigfillset (sigset_t *);
int sigismember (const sigset_t *, int);
int sigpending (sigset_t *);
int sigprocmask (int, const sigset_t *, sigset_t *);
int sigsuspend (const sigset_t *);

int killpg (pid_t, int);
int sigblock (int);
int siginterrupt (int, int);
int sighold (int);
int sigrelse (int);
int sigpause (int);
int sigreturn (struct sigcontext *);
int sigsetmask (int);
int sigvec (int, struct sigvec *, struct sigvec *);
void psignal (unsigned int, const char *);


}
# 191 "/usr/include/unistd.h" 2 3 4

int profil (char *, int, int, int);
ssize_t pwrite (int, const void *, size_t, off_t);
int rcmd (char **, int, const char *, const char *, const char *, int *);

char *re_comp (const char *);
int re_exec (const char *);
int readlink (const char *, char *, int);
int reboot (int);
int revoke (const char *);
int rresvport (int *);
int ruserok (const char *, int, const char *, const char *);
char *sbrk (int);
int select (int, fd_set *, fd_set *, fd_set *, struct timeval *);
int setegid (gid_t);
int seteuid (uid_t);
int setgroups (int, const gid_t *);
void sethostid (long);
int sethostname (const char *, int);
int setkey (const char *);
int setlogin (const char *);
void *setmode (const char *);
int setpgrp (pid_t pid, pid_t pgrp);
int setregid (gid_t, gid_t);
int setreuid (uid_t, uid_t);
int setrgid (gid_t);
int setruid (uid_t);
void setusershell (void);
int strtofflags (char **, u_long *, u_long *);
int swapon (const char *);
int symlink (const char *, const char *);
void sync (void);
int syscall (int, ...);
int truncate (const char *, off_t);
int ttyslot (void);
unsigned int ualarm (unsigned int, unsigned int);
int unwhiteout (const char *);
int usleep (unsigned int);
void *valloc (size_t);
pid_t vfork (void);

extern char *suboptarg;
int getsubopt (char **, char * const *, char **);


int getattrlist (const char*,void*,void*,size_t,unsigned long);
int setattrlist (const char*,void*,void*,size_t,unsigned long);
int exchangedata (const char*,const char*,unsigned long);
int checkuseraccess (const char*,uid_t,gid_t*,int,int,unsigned long);
int getdirentriesattr (int,void*,void*,size_t,unsigned long*,unsigned long*,unsigned long*,unsigned long);
int searchfs (const char*,void*,void*,unsigned long,unsigned long,void*);

int fsctl (const char *,unsigned long,void*,unsigned long);



}
# 40 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 63 "/usr/include/limits.h" 3 4
# 1 "/usr/include/sys/syslimits.h" 1 3 4
# 64 "/usr/include/limits.h" 2 3 4
# 41 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/mach/mach_types.h" 1 3 4
# 64 "/usr/include/mach/mach_types.h" 3 4
# 1 "/usr/include/gcc/darwin/3.1/stdint.h" 1 3 4
# 34 "/usr/include/gcc/darwin/3.1/stdint.h" 3 4
typedef u_int8_t uint8_t;
typedef u_int16_t uint16_t;
typedef u_int32_t uint32_t;
typedef u_int64_t uint64_t;



typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 68 "/usr/include/gcc/darwin/3.1/stdint.h" 3 4
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
# 65 "/usr/include/mach/mach_types.h" 2 3 4

# 1 "/usr/include/mach/host_info.h" 1 3 4
# 62 "/usr/include/mach/host_info.h" 3 4
# 1 "/usr/include/mach/vm_statistics.h" 1 3 4
# 63 "/usr/include/mach/vm_statistics.h" 3 4
# 1 "/usr/include/mach/machine/vm_types.h" 1 3 4
# 27 "/usr/include/mach/machine/vm_types.h" 3 4
# 1 "/usr/include/mach/ppc/vm_types.h" 1 3 4
# 77 "/usr/include/mach/ppc/vm_types.h" 3 4
typedef unsigned int natural_t;
# 86 "/usr/include/mach/ppc/vm_types.h" 3 4
typedef int integer_t;





typedef natural_t vm_offset_t;






typedef natural_t vm_size_t;




typedef unsigned int space_t;
# 28 "/usr/include/mach/machine/vm_types.h" 2 3 4
# 64 "/usr/include/mach/vm_statistics.h" 2 3 4

struct vm_statistics {
        integer_t free_count;
        integer_t active_count;
        integer_t inactive_count;
        integer_t wire_count;
        integer_t zero_fill_count;
        integer_t reactivations;
        integer_t pageins;
        integer_t pageouts;
        integer_t faults;
        integer_t cow_faults;
        integer_t lookups;
        integer_t hits;
};

typedef struct vm_statistics *vm_statistics_t;
typedef struct vm_statistics vm_statistics_data_t;
# 99 "/usr/include/mach/vm_statistics.h" 3 4
struct pmap_statistics {
        integer_t resident_count;
        integer_t wired_count;
};

typedef struct pmap_statistics *pmap_statistics_t;
# 63 "/usr/include/mach/host_info.h" 2 3 4
# 1 "/usr/include/mach/machine.h" 1 3 4
# 60 "/usr/include/mach/machine.h" 3 4
# 1 "/usr/include/mach/boolean.h" 1 3 4
# 127 "/usr/include/mach/boolean.h" 3 4
# 1 "/usr/include/mach/machine/boolean.h" 1 3 4
# 27 "/usr/include/mach/machine/boolean.h" 3 4
# 1 "/usr/include/mach/ppc/boolean.h" 1 3 4
# 129 "/usr/include/mach/ppc/boolean.h" 3 4
typedef int boolean_t;
# 28 "/usr/include/mach/machine/boolean.h" 2 3 4
# 128 "/usr/include/mach/boolean.h" 2 3 4
# 61 "/usr/include/mach/machine.h" 2 3 4
# 71 "/usr/include/mach/machine.h" 3 4
struct machine_info {
        integer_t major_version;
        integer_t minor_version;
        integer_t max_cpus;
        integer_t avail_cpus;
        vm_size_t memory_size;
};

typedef struct machine_info *machine_info_t;
typedef struct machine_info machine_info_data_t;

typedef integer_t cpu_type_t;
typedef integer_t cpu_subtype_t;
# 64 "/usr/include/mach/host_info.h" 2 3 4

# 1 "/usr/include/mach/time_value.h" 1 3 4
# 62 "/usr/include/mach/time_value.h" 3 4
struct time_value {
        integer_t seconds;
        integer_t microseconds;
};
typedef struct time_value time_value_t;
# 106 "/usr/include/mach/time_value.h" 3 4
typedef struct mapped_time_value {
        integer_t seconds;
        integer_t microseconds;
        integer_t check_seconds;
} mapped_time_value_t;
# 66 "/usr/include/mach/host_info.h" 2 3 4




typedef integer_t *host_info_t;


typedef integer_t host_info_data_t[(1024)];


typedef char kernel_version_t[(512)];


typedef char kernel_boot_info_t[(4096)];







typedef integer_t host_flavor_t;







struct host_basic_info {
        integer_t max_cpus;
        integer_t avail_cpus;
        vm_size_t memory_size;
        cpu_type_t cpu_type;
        cpu_subtype_t cpu_subtype;
};

typedef struct host_basic_info host_basic_info_data_t;
typedef struct host_basic_info *host_basic_info_t;



struct host_sched_info {
        integer_t min_timeout;
        integer_t min_quantum;
};

typedef struct host_sched_info host_sched_info_data_t;
typedef struct host_sched_info *host_sched_info_t;



struct kernel_resource_sizes {
        vm_size_t task;
        vm_size_t thread;
        vm_size_t port;
        vm_size_t memory_region;
        vm_size_t memory_object;
};

typedef struct kernel_resource_sizes kernel_resource_sizes_data_t;
typedef struct kernel_resource_sizes *kernel_resource_sizes_t;



struct host_priority_info {
        integer_t kernel_priority;
        integer_t system_priority;
        integer_t server_priority;
        integer_t user_priority;
        integer_t depress_priority;
        integer_t idle_priority;
        integer_t minimum_priority;
        integer_t maximum_priority;
};

typedef struct host_priority_info host_priority_info_data_t;
typedef struct host_priority_info *host_priority_info_t;
# 152 "/usr/include/mach/host_info.h" 3 4
struct host_load_info {
        integer_t avenrun[3];
        integer_t mach_factor[3];
};

typedef struct host_load_info host_load_info_data_t;
typedef struct host_load_info *host_load_info_t;







struct host_cpu_load_info {
        unsigned long cpu_ticks[4];
};
typedef struct host_cpu_load_info host_cpu_load_info_data_t;
typedef struct host_cpu_load_info *host_cpu_load_info_t;
# 67 "/usr/include/mach/mach_types.h" 2 3 4


# 1 "/usr/include/mach/memory_object_types.h" 1 3 4
# 67 "/usr/include/mach/memory_object_types.h" 3 4
# 1 "/usr/include/mach/port.h" 1 3 4
# 91 "/usr/include/mach/port.h" 3 4
typedef natural_t port_name_t;
typedef port_name_t *port_name_array_t;


typedef port_name_t port_t;
# 117 "/usr/include/mach/port.h" 3 4
typedef port_t mach_port_t;
typedef port_t *mach_port_array_t;
typedef port_name_t mach_port_name_t;
typedef mach_port_name_t *mach_port_name_array_t;
# 165 "/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_right_t;
# 174 "/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_type_t;
typedef mach_port_type_t *mach_port_type_array_t;
# 206 "/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_urefs_t;
typedef integer_t mach_port_delta_t;



typedef natural_t mach_port_seqno_t;
typedef natural_t mach_port_mscount_t;
typedef natural_t mach_port_msgcount_t;
typedef natural_t mach_port_rights_t;






typedef unsigned int mach_port_srights_t;

typedef struct mach_port_status {
        mach_port_name_t mps_pset;
        mach_port_seqno_t mps_seqno;
        mach_port_mscount_t mps_mscount;
        mach_port_msgcount_t mps_qlimit;
        mach_port_msgcount_t mps_msgcount;
        mach_port_rights_t mps_sorights;
        boolean_t mps_srights;
        boolean_t mps_pdrequest;
        boolean_t mps_nsrequest;
        unsigned int mps_flags;
} mach_port_status_t;




typedef struct mach_port_limits {
        mach_port_msgcount_t mpl_qlimit;
} mach_port_limits_t;

typedef integer_t *mach_port_info_t;


typedef int mach_port_flavor_t;
# 262 "/usr/include/mach/port.h" 3 4
typedef struct mach_port_qos {
        boolean_t name:1;
        boolean_t prealloc:1;
        boolean_t pad1:30;
        natural_t len;
} mach_port_qos_t;
# 68 "/usr/include/mach/memory_object_types.h" 2 3 4
# 1 "/usr/include/mach/vm_types.h" 1 3 4
# 35 "/usr/include/mach/vm_types.h" 3 4
typedef vm_offset_t pointer_t;
typedef vm_offset_t vm_address_t;
typedef uint64_t vm_object_offset_t;


typedef mach_port_t vm_map_t;
# 49 "/usr/include/mach/vm_types.h" 3 4
typedef mach_port_t upl_t;
typedef mach_port_t vm_named_entry_t;
# 69 "/usr/include/mach/memory_object_types.h" 2 3 4






typedef unsigned long long memory_object_offset_t;
typedef unsigned long long memory_object_size_t;






typedef mach_port_t memory_object_t;
typedef mach_port_t memory_object_control_t;


typedef memory_object_t *memory_object_array_t;




typedef mach_port_t memory_object_name_t;



typedef mach_port_t memory_object_default_t;
# 106 "/usr/include/mach/memory_object_types.h" 3 4
typedef int memory_object_copy_strategy_t;
# 142 "/usr/include/mach/memory_object_types.h" 3 4
typedef int memory_object_return_t;
# 169 "/usr/include/mach/memory_object_types.h" 3 4
typedef int *memory_object_info_t;
typedef int memory_object_flavor_t;
typedef int memory_object_info_data_t[(1024)];
# 182 "/usr/include/mach/memory_object_types.h" 3 4
struct old_memory_object_behave_info {
        memory_object_copy_strategy_t copy_strategy;
        boolean_t temporary;
        boolean_t invalidate;
};

struct old_memory_object_attr_info {
        boolean_t object_ready;
        boolean_t may_cache;
        memory_object_copy_strategy_t copy_strategy;
};

typedef struct old_memory_object_behave_info *old_memory_object_behave_info_t;
typedef struct old_memory_object_behave_info old_memory_object_behave_info_data_t;
typedef struct old_memory_object_attr_info *old_memory_object_attr_info_t;
typedef struct old_memory_object_attr_info old_memory_object_attr_info_data_t;







struct memory_object_perf_info {
        vm_size_t cluster_size;
        boolean_t may_cache;
};

struct memory_object_attr_info {
        memory_object_copy_strategy_t copy_strategy;
        vm_offset_t cluster_size;
        boolean_t may_cache_object;
        boolean_t temporary;
};

struct memory_object_behave_info {
        memory_object_copy_strategy_t copy_strategy;
        boolean_t temporary;
        boolean_t invalidate;
        boolean_t silent_overwrite;
        boolean_t advisory_pageout;
};


typedef struct memory_object_behave_info *memory_object_behave_info_t;
typedef struct memory_object_behave_info memory_object_behave_info_data_t;

typedef struct memory_object_perf_info *memory_object_perf_info_t;
typedef struct memory_object_perf_info memory_object_perf_info_data_t;

typedef struct memory_object_attr_info *memory_object_attr_info_t;
typedef struct memory_object_attr_info memory_object_attr_info_data_t;
# 264 "/usr/include/mach/memory_object_types.h" 3 4
struct upl_page_info {
        vm_offset_t phys_addr;
        unsigned int
                        pageout:1,
                        absent:1,
                        dirty:1,
                        precious:1,
                        device:1,
                        :0;
};

typedef struct upl_page_info upl_page_info_t;
typedef upl_page_info_t *upl_page_info_array_t;
typedef upl_page_info_array_t upl_page_list_ptr_t;
# 70 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/exception_types.h" 1 3 4
# 56 "/usr/include/mach/exception_types.h" 3 4
# 1 "/usr/include/mach/machine/exception.h" 1 3 4
# 27 "/usr/include/mach/machine/exception.h" 3 4
# 1 "/usr/include/mach/ppc/exception.h" 1 3 4
# 28 "/usr/include/mach/machine/exception.h" 2 3 4
# 57 "/usr/include/mach/exception_types.h" 2 3 4
# 147 "/usr/include/mach/exception_types.h" 3 4
# 1 "/usr/include/mach/thread_status.h" 1 3 4
# 70 "/usr/include/mach/thread_status.h" 3 4
# 1 "/usr/include/mach/machine/thread_status.h" 1 3 4
# 27 "/usr/include/mach/machine/thread_status.h" 3 4
# 1 "/usr/include/mach/ppc/thread_status.h" 1 3 4
# 60 "/usr/include/mach/ppc/thread_status.h" 3 4
typedef struct ppc_thread_state {
        unsigned int srr0;
        unsigned int srr1;
        unsigned int r0;
        unsigned int r1;
        unsigned int r2;
        unsigned int r3;
        unsigned int r4;
        unsigned int r5;
        unsigned int r6;
        unsigned int r7;
        unsigned int r8;
        unsigned int r9;
        unsigned int r10;
        unsigned int r11;
        unsigned int r12;
        unsigned int r13;
        unsigned int r14;
        unsigned int r15;
        unsigned int r16;
        unsigned int r17;
        unsigned int r18;
        unsigned int r19;
        unsigned int r20;
        unsigned int r21;
        unsigned int r22;
        unsigned int r23;
        unsigned int r24;
        unsigned int r25;
        unsigned int r26;
        unsigned int r27;
        unsigned int r28;
        unsigned int r29;
        unsigned int r30;
        unsigned int r31;

        unsigned int cr;
        unsigned int xer;
        unsigned int lr;
        unsigned int ctr;
        unsigned int mq;

        unsigned int vrsave;
} ppc_thread_state_t;



typedef struct ppc_float_state {
        double fpregs[32];

        unsigned int fpscr_pad;
        unsigned int fpscr;
} ppc_float_state_t;

typedef struct ppc_vector_state {
        unsigned long save_vr[32][4];
        unsigned long save_vscr[4];
        unsigned int save_pad5[4];
        unsigned int save_vrvalid;
        unsigned int save_pad6[7];
} ppc_vector_state_t;
# 132 "/usr/include/mach/ppc/thread_status.h" 3 4
typedef struct ppc_thread_state ppc_saved_state_t;
# 148 "/usr/include/mach/ppc/thread_status.h" 3 4
typedef struct ppc_exception_state {
        unsigned long dar;
        unsigned long dsisr;
        unsigned long exception;
        unsigned long pad0;

        unsigned long pad1[4];
} ppc_exception_state_t;
# 28 "/usr/include/mach/machine/thread_status.h" 2 3 4
# 71 "/usr/include/mach/thread_status.h" 2 3 4
# 1 "/usr/include/mach/machine/thread_state.h" 1 3 4
# 27 "/usr/include/mach/machine/thread_state.h" 3 4
# 1 "/usr/include/mach/ppc/thread_state.h" 1 3 4
# 28 "/usr/include/mach/machine/thread_state.h" 2 3 4
# 72 "/usr/include/mach/thread_status.h" 2 3 4





typedef natural_t *thread_state_t;


typedef int thread_state_data_t[(144)];



typedef int thread_state_flavor_t;
typedef thread_state_flavor_t *thread_state_flavor_array_t;
# 148 "/usr/include/mach/exception_types.h" 2 3 4





typedef int exception_type_t;
typedef integer_t exception_data_type_t;
typedef int exception_behavior_t;
typedef integer_t *exception_data_t;
typedef unsigned int exception_mask_t;
typedef exception_mask_t *exception_mask_array_t;
typedef exception_behavior_t *exception_behavior_array_t;
typedef thread_state_flavor_t *exception_flavor_array_t;
typedef mach_port_t *exception_port_array_t;
# 71 "/usr/include/mach/mach_types.h" 2 3 4

# 1 "/usr/include/mach/processor_info.h" 1 3 4
# 65 "/usr/include/mach/processor_info.h" 3 4
# 1 "/usr/include/mach/machine/processor_info.h" 1 3 4
# 27 "/usr/include/mach/machine/processor_info.h" 3 4
# 1 "/usr/include/mach/ppc/processor_info.h" 1 3 4
# 43 "/usr/include/mach/ppc/processor_info.h" 3 4
typedef union {
        unsigned int word;
        struct {
                unsigned int dis : 1;
                unsigned int dp : 1;
                unsigned int du : 1;
                unsigned int dms : 1;
                unsigned int dmr : 1;
                unsigned int reserved3 : 1;
                unsigned int reserved4 : 1;
                unsigned int reserved5 : 2;
                unsigned int reserved6 : 1;
                unsigned int threshold : 6;
                unsigned int reserved7 : 1;
                unsigned int reserved8 : 1;
                unsigned int reserved9 : 1;
                unsigned int pmc1select : 7;
                unsigned int pmc2select : 6;
        }bits;
}mmcr0_t;

typedef union {
        unsigned int word;
        struct {
                unsigned int pmc3select : 5;
                unsigned int pmc4select : 5;
                unsigned int reserved : 22;
        }bits;
}mmcr1_t;

typedef union {
        unsigned int word;
        struct {
                unsigned int threshmult : 1;
                unsigned int reserved : 31;
        }bits;
}mmcr2_t;

typedef union {
        unsigned int word;
        struct {
                unsigned int ov : 1;
                unsigned int cv : 31;
        }bits;
}pmcn_t;





struct processor_pm_regs {
      union {
        mmcr0_t mmcr0;
        mmcr1_t mmcr1;
        mmcr2_t mmcr2;
      }u;
      pmcn_t pmc[2];
};

typedef struct processor_pm_regs processor_pm_regs_data_t;
typedef struct processor_pm_regs *processor_pm_regs_t;
# 119 "/usr/include/mach/ppc/processor_info.h" 3 4
typedef unsigned int processor_temperature_data_t;
typedef unsigned int *processor_temperature_t;



union processor_control_data {
        processor_pm_regs_data_t cmd_pm_regs[3];
};

struct processor_control_cmd {
    integer_t cmd_op;
    cpu_type_t cmd_cpu_type;
    cpu_subtype_t cmd_cpu_subtype;
    union processor_control_data u;
};

typedef struct processor_control_cmd processor_control_cmd_data_t;
typedef struct processor_control_cmd *processor_control_cmd_t;
# 28 "/usr/include/mach/machine/processor_info.h" 2 3 4
# 66 "/usr/include/mach/processor_info.h" 2 3 4




typedef integer_t *processor_info_t;
typedef integer_t *processor_info_array_t;


typedef integer_t processor_info_data_t[(1024)];


typedef integer_t *processor_set_info_t;


typedef integer_t processor_set_info_data_t[(1024)];




typedef int processor_flavor_t;





struct processor_basic_info {
        cpu_type_t cpu_type;
        cpu_subtype_t cpu_subtype;
        boolean_t running;
        int slot_num;
        boolean_t is_master;
};

typedef struct processor_basic_info processor_basic_info_data_t;
typedef struct processor_basic_info *processor_basic_info_t;



struct processor_cpu_load_info {
        unsigned long cpu_ticks[4];
};

typedef struct processor_cpu_load_info processor_cpu_load_info_data_t;
typedef struct processor_cpu_load_info *processor_cpu_load_info_t;
# 118 "/usr/include/mach/processor_info.h" 3 4
typedef int processor_set_flavor_t;


struct processor_set_basic_info {
        int processor_count;
        int default_policy;
};

typedef struct processor_set_basic_info processor_set_basic_info_data_t;
typedef struct processor_set_basic_info *processor_set_basic_info_t;





struct processor_set_load_info {
        int task_count;
        int thread_count;
        integer_t load_average;
        integer_t mach_factor;
};

typedef struct processor_set_load_info processor_set_load_info_data_t;
typedef struct processor_set_load_info *processor_set_load_info_t;
# 73 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/task_info.h" 1 3 4
# 66 "/usr/include/mach/task_info.h" 3 4
# 1 "/usr/include/mach/policy.h" 1 3 4
# 72 "/usr/include/mach/policy.h" 3 4
typedef int policy_t;
typedef integer_t *policy_info_t;
typedef integer_t *policy_base_t;
typedef integer_t *policy_limit_t;
# 108 "/usr/include/mach/policy.h" 3 4
struct policy_timeshare_base {
        integer_t base_priority;
};
struct policy_timeshare_limit {
        integer_t max_priority;
};
struct policy_timeshare_info {
        integer_t max_priority;
        integer_t base_priority;
        integer_t cur_priority;
        boolean_t depressed;
        integer_t depress_priority;
};

typedef struct policy_timeshare_base *policy_timeshare_base_t;
typedef struct policy_timeshare_limit *policy_timeshare_limit_t;
typedef struct policy_timeshare_info *policy_timeshare_info_t;

typedef struct policy_timeshare_base policy_timeshare_base_data_t;
typedef struct policy_timeshare_limit policy_timeshare_limit_data_t;
typedef struct policy_timeshare_info policy_timeshare_info_data_t;
# 142 "/usr/include/mach/policy.h" 3 4
struct policy_rr_base {
        integer_t base_priority;
        integer_t quantum;
};
struct policy_rr_limit {
        integer_t max_priority;
};
struct policy_rr_info {
        integer_t max_priority;
        integer_t base_priority;
        integer_t quantum;
        boolean_t depressed;
        integer_t depress_priority;
};

typedef struct policy_rr_base *policy_rr_base_t;
typedef struct policy_rr_limit *policy_rr_limit_t;
typedef struct policy_rr_info *policy_rr_info_t;

typedef struct policy_rr_base policy_rr_base_data_t;
typedef struct policy_rr_limit policy_rr_limit_data_t;
typedef struct policy_rr_info policy_rr_info_data_t;
# 176 "/usr/include/mach/policy.h" 3 4
struct policy_fifo_base {
        integer_t base_priority;
};
struct policy_fifo_limit {
        integer_t max_priority;
};
struct policy_fifo_info {
        integer_t max_priority;
        integer_t base_priority;
        boolean_t depressed;
        integer_t depress_priority;
};

typedef struct policy_fifo_base *policy_fifo_base_t;
typedef struct policy_fifo_limit *policy_fifo_limit_t;
typedef struct policy_fifo_info *policy_fifo_info_t;

typedef struct policy_fifo_base policy_fifo_base_data_t;
typedef struct policy_fifo_limit policy_fifo_limit_data_t;
typedef struct policy_fifo_info policy_fifo_info_data_t;
# 208 "/usr/include/mach/policy.h" 3 4
struct policy_bases {
        policy_timeshare_base_data_t ts;
        policy_rr_base_data_t rr;
        policy_fifo_base_data_t fifo;
};

struct policy_limits {
        policy_timeshare_limit_data_t ts;
        policy_rr_limit_data_t rr;
        policy_fifo_limit_data_t fifo;
};

struct policy_infos {
        policy_timeshare_info_data_t ts;
        policy_rr_info_data_t rr;
        policy_fifo_info_data_t fifo;
};

typedef struct policy_bases policy_base_data_t;
typedef struct policy_limits policy_limit_data_t;
typedef struct policy_infos policy_info_data_t;
# 67 "/usr/include/mach/task_info.h" 2 3 4






typedef natural_t task_flavor_t;
typedef integer_t *task_info_t;


typedef integer_t task_info_data_t[(1024)];







struct task_basic_info {
        integer_t suspend_count;
        vm_size_t virtual_size;
        vm_size_t resident_size;
        time_value_t user_time;

        time_value_t system_time;

        policy_t policy;
};

typedef struct task_basic_info task_basic_info_data_t;
typedef struct task_basic_info *task_basic_info_t;






struct task_events_info {
        integer_t faults;
        integer_t pageins;
        integer_t cow_faults;
        integer_t messages_sent;
        integer_t messages_received;
        integer_t syscalls_mach;
        integer_t syscalls_unix;
        integer_t csw;
};
typedef struct task_events_info task_events_info_data_t;
typedef struct task_events_info *task_events_info_t;






struct task_thread_times_info {
        time_value_t user_time;

        time_value_t system_time;

};

typedef struct task_thread_times_info task_thread_times_info_data_t;
typedef struct task_thread_times_info *task_thread_times_info_t;
# 74 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/task_policy.h" 1 3 4
# 37 "/usr/include/mach/task_policy.h" 3 4
# 1 "/usr/include/mach/mach_types.h" 1 3 4
# 38 "/usr/include/mach/task_policy.h" 2 3 4
# 56 "/usr/include/mach/task_policy.h" 3 4
typedef natural_t task_policy_flavor_t;
typedef integer_t *task_policy_t;
# 111 "/usr/include/mach/task_policy.h" 3 4
enum task_role {
        TASK_RENICED = -1,
        TASK_UNSPECIFIED = 0,
        TASK_FOREGROUND_APPLICATION,
        TASK_BACKGROUND_APPLICATION,
        TASK_CONTROL_APPLICATION,
        TASK_GRAPHICS_SERVER
};

typedef enum task_role task_role_t;

struct task_category_policy {
        task_role_t role;
};

typedef struct task_category_policy task_category_policy_data_t;
typedef struct task_category_policy *task_category_policy_t;
# 75 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/task_special_ports.h" 1 3 4
# 66 "/usr/include/mach/task_special_ports.h" 3 4
typedef int task_special_port_t;
# 76 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/thread_info.h" 1 3 4
# 76 "/usr/include/mach/thread_info.h" 3 4
typedef natural_t thread_flavor_t;
typedef integer_t *thread_info_t;


typedef integer_t thread_info_data_t[(1024)];






struct thread_basic_info {
        time_value_t user_time;
        time_value_t system_time;
        integer_t cpu_usage;
        policy_t policy;
        integer_t run_state;
        integer_t flags;
        integer_t suspend_count;
        integer_t sleep_time;

};

typedef struct thread_basic_info thread_basic_info_data_t;
typedef struct thread_basic_info *thread_basic_info_t;
# 77 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/thread_policy.h" 1 3 4
# 56 "/usr/include/mach/thread_policy.h" 3 4
typedef natural_t thread_policy_flavor_t;
typedef integer_t *thread_policy_t;
# 91 "/usr/include/mach/thread_policy.h" 3 4
struct thread_standard_policy {
        natural_t no_data;
};

typedef struct thread_standard_policy thread_standard_policy_data_t;
typedef struct thread_standard_policy *thread_standard_policy_t;
# 114 "/usr/include/mach/thread_policy.h" 3 4
struct thread_extended_policy {
        boolean_t timeshare;
};

typedef struct thread_extended_policy thread_extended_policy_data_t;
typedef struct thread_extended_policy *thread_extended_policy_t;
# 153 "/usr/include/mach/thread_policy.h" 3 4
struct thread_time_constraint_policy {
        uint32_t period;
        uint32_t computation;
        uint32_t constraint;
        boolean_t preemptible;
};

typedef struct thread_time_constraint_policy thread_time_constraint_policy_data_t;

typedef struct thread_time_constraint_policy *thread_time_constraint_policy_t;
# 181 "/usr/include/mach/thread_policy.h" 3 4
struct thread_precedence_policy {
        integer_t importance;
};

typedef struct thread_precedence_policy thread_precedence_policy_data_t;
typedef struct thread_precedence_policy *thread_precedence_policy_t;
# 78 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/thread_special_ports.h" 1 3 4
# 79 "/usr/include/mach/mach_types.h" 2 3 4


# 1 "/usr/include/mach/clock_types.h" 1 3 4
# 46 "/usr/include/mach/clock_types.h" 3 4
typedef int alarm_type_t;
typedef int sleep_type_t;
typedef int clock_id_t;
typedef int clock_flavor_t;
typedef int *clock_attr_t;
typedef int clock_res_t;




struct mach_timespec {
        unsigned int tv_sec;
        clock_res_t tv_nsec;
};
typedef struct mach_timespec mach_timespec_t;
# 82 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/vm_attributes.h" 1 3 4
# 70 "/usr/include/mach/vm_attributes.h" 3 4
typedef unsigned int vm_machine_attribute_t;
# 79 "/usr/include/mach/vm_attributes.h" 3 4
typedef int vm_machine_attribute_val_t;
# 83 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/vm_inherit.h" 1 3 4
# 69 "/usr/include/mach/vm_inherit.h" 3 4
typedef unsigned int vm_inherit_t;
# 84 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/vm_behavior.h" 1 3 4
# 41 "/usr/include/mach/vm_behavior.h" 3 4
typedef int vm_behavior_t;
# 85 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/vm_prot.h" 1 3 4
# 69 "/usr/include/mach/vm_prot.h" 3 4
typedef int vm_prot_t;
# 86 "/usr/include/mach/mach_types.h" 2 3 4

# 1 "/usr/include/mach/vm_sync.h" 1 3 4
# 60 "/usr/include/mach/vm_sync.h" 3 4
typedef unsigned vm_sync_t;
# 88 "/usr/include/mach/mach_types.h" 2 3 4

# 1 "/usr/include/mach/vm_region.h" 1 3 4
# 47 "/usr/include/mach/vm_region.h" 3 4
typedef int *vm_region_info_t;
typedef int *vm_region_info_64_t;
typedef int *vm_region_recurse_info_t;
typedef int *vm_region_recurse_info_64_t;
typedef int vm_region_flavor_t;
typedef int vm_region_info_data_t[(1024)];



struct vm_region_basic_info_64 {
        vm_prot_t protection;
        vm_prot_t max_protection;
        vm_inherit_t inheritance;
        boolean_t shared;
        boolean_t reserved;
        vm_object_offset_t offset;
        vm_behavior_t behavior;
        unsigned short user_wired_count;
};

typedef struct vm_region_basic_info_64 *vm_region_basic_info_64_t;
typedef struct vm_region_basic_info_64 vm_region_basic_info_data_64_t;





struct vm_region_basic_info {
        vm_prot_t protection;
        vm_prot_t max_protection;
        vm_inherit_t inheritance;
        boolean_t shared;
        boolean_t reserved;



        vm_offset_t offset;

        vm_behavior_t behavior;
        unsigned short user_wired_count;
};

typedef struct vm_region_basic_info *vm_region_basic_info_t;
typedef struct vm_region_basic_info vm_region_basic_info_data_t;
# 116 "/usr/include/mach/vm_region.h" 3 4
struct vm_region_extended_info {
        vm_prot_t protection;
        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
};

typedef struct vm_region_extended_info *vm_region_extended_info_t;
typedef struct vm_region_extended_info vm_region_extended_info_data_t;







struct vm_region_top_info {
        unsigned int obj_id;
        unsigned int ref_count;
        unsigned int private_pages_resident;
        unsigned int shared_pages_resident;
        unsigned char share_mode;
};

typedef struct vm_region_top_info *vm_region_top_info_t;
typedef struct vm_region_top_info vm_region_top_info_data_t;
# 173 "/usr/include/mach/vm_region.h" 3 4
struct vm_region_submap_info {
        vm_prot_t protection;
        vm_prot_t max_protection;
        vm_inherit_t inheritance;



        vm_offset_t offset;

        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
        boolean_t is_submap;
        vm_behavior_t behavior;
        vm_offset_t object_id;
        unsigned short user_wired_count;
};

typedef struct vm_region_submap_info *vm_region_submap_info_t;
typedef struct vm_region_submap_info vm_region_submap_info_data_t;






struct vm_region_submap_info_64 {
        vm_prot_t protection;
        vm_prot_t max_protection;
        vm_inherit_t inheritance;
        vm_object_offset_t offset;
        unsigned int user_tag;
        unsigned int pages_resident;
        unsigned int pages_shared_now_private;
        unsigned int pages_swapped_out;
        unsigned int pages_dirtied;
        unsigned int ref_count;
        unsigned short shadow_depth;
        unsigned char external_pager;
        unsigned char share_mode;
        boolean_t is_submap;
        vm_behavior_t behavior;
        vm_offset_t object_id;
        unsigned short user_wired_count;
};

typedef struct vm_region_submap_info_64 *vm_region_submap_info_64_t;
typedef struct vm_region_submap_info_64 vm_region_submap_info_data_64_t;





struct vm_read_entry {
        vm_address_t address;
        vm_size_t size;
};



typedef struct vm_read_entry vm_read_entry_t[(256)];
# 90 "/usr/include/mach/mach_types.h" 2 3 4
# 1 "/usr/include/mach/kmod.h" 1 3 4
# 34 "/usr/include/mach/kmod.h" 3 4
# 1 "/usr/include/mach/kern_return.h" 1 3 4
# 64 "/usr/include/mach/kern_return.h" 3 4
# 1 "/usr/include/mach/machine/kern_return.h" 1 3 4
# 27 "/usr/include/mach/machine/kern_return.h" 3 4
# 1 "/usr/include/mach/ppc/kern_return.h" 1 3 4
# 135 "/usr/include/mach/ppc/kern_return.h" 3 4
typedef int kern_return_t;
# 28 "/usr/include/mach/machine/kern_return.h" 2 3 4
# 65 "/usr/include/mach/kern_return.h" 2 3 4
# 35 "/usr/include/mach/kmod.h" 2 3 4
# 54 "/usr/include/mach/kmod.h" 3 4
typedef int kmod_t;
typedef int kmod_control_flavor_t;
typedef void* kmod_args_t;



typedef struct kmod_reference {
        struct kmod_reference *next;
        struct kmod_info *info;
} kmod_reference_t;
# 73 "/usr/include/mach/kmod.h" 3 4
typedef kern_return_t kmod_start_func_t(struct kmod_info *ki, void *data);
typedef kern_return_t kmod_stop_func_t(struct kmod_info *ki, void *data);

typedef struct kmod_info {
        struct kmod_info *next;
        int info_version;
        int id;
        char name[64];
        char version[64];
        int reference_count;
        kmod_reference_t *reference_list;
        vm_address_t address;
        vm_size_t size;
        vm_size_t hdr_size;
        kmod_start_func_t *start;
        kmod_stop_func_t *stop;
} kmod_info_t;



typedef kmod_info_t *kmod_info_array_t;
# 134 "/usr/include/mach/kmod.h" 3 4
typedef struct kmod_load_extension_cmd {
        int type;
        char name[64];
} kmod_load_extension_cmd_t;

typedef struct kmod_load_with_dependencies_cmd {
        int type;
        char name[64];
        char dependencies[1][64];
} kmod_load_with_dependencies_cmd_t;

typedef struct kmod_generic_cmd {
        int type;
        char data[1];
} kmod_generic_cmd_t;
# 91 "/usr/include/mach/mach_types.h" 2 3 4






typedef mach_port_t task_t;
typedef mach_port_t thread_t;
typedef mach_port_t thread_act_t;
typedef mach_port_t ipc_space_t;
typedef mach_port_t host_t;
typedef mach_port_t host_priv_t;
typedef mach_port_t host_security_t;
typedef mach_port_t processor_t;
typedef mach_port_t processor_set_t;
typedef mach_port_t processor_set_control_t;
typedef mach_port_t semaphore_t;
typedef mach_port_t lock_set_t;
typedef mach_port_t ledger_t;
typedef mach_port_t alarm_t;
typedef mach_port_t clock_serv_t;
typedef mach_port_t clock_ctrl_t;







typedef processor_set_t processor_set_name_t;




typedef mach_port_t clock_reply_t;
typedef mach_port_t bootstrap_t;
typedef mach_port_t mem_entry_name_port_t;
typedef mach_port_t exception_handler_t;
typedef exception_handler_t *exception_handler_array_t;
typedef mach_port_t vm_task_entry_t;
typedef mach_port_t io_master_t;
typedef mach_port_t UNDServerRef;
# 141 "/usr/include/mach/mach_types.h" 3 4
typedef task_t *task_array_t;
typedef thread_t *thread_array_t;
typedef processor_set_t *processor_set_array_t;
typedef processor_set_t *processor_set_name_array_t;
typedef processor_t *processor_array_t;
typedef thread_act_t *thread_act_array_t;
typedef ledger_t *ledger_array_t;
# 156 "/usr/include/mach/mach_types.h" 3 4
typedef task_t task_port_t;
typedef task_array_t task_port_array_t;
typedef thread_t thread_port_t;
typedef thread_array_t thread_port_array_t;
typedef ipc_space_t ipc_space_port_t;
typedef host_t host_name_t;
typedef host_t host_name_port_t;
typedef processor_set_t processor_set_port_t;
typedef processor_set_t processor_set_name_port_t;
typedef processor_set_array_t processor_set_name_port_array_t;
typedef processor_set_t processor_set_control_port_t;
typedef processor_t processor_port_t;
typedef processor_array_t processor_port_array_t;
typedef thread_act_t thread_act_port_t;
typedef thread_act_array_t thread_act_port_array_t;
typedef semaphore_t semaphore_port_t;
typedef lock_set_t lock_set_port_t;
typedef ledger_t ledger_port_t;
typedef ledger_array_t ledger_port_array_t;
typedef alarm_t alarm_port_t;
typedef clock_serv_t clock_serv_port_t;
typedef clock_ctrl_t clock_ctrl_port_t;
typedef exception_handler_t exception_port_t;
typedef exception_handler_array_t exception_port_arrary_t;
# 198 "/usr/include/mach/mach_types.h" 3 4
typedef integer_t ledger_item_t;
typedef vm_offset_t *emulation_vector_t;
typedef char *user_subsystem_t;





# 1 "/usr/include/mach/std_types.h" 1 3 4
# 207 "/usr/include/mach/mach_types.h" 2 3 4
# 45 "/usr/include/pthread.h" 2 3 4
# 74 "/usr/include/pthread.h" 3 4
extern "C" {
# 168 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sys/time.h" 1 3 4
# 68 "/usr/include/sys/time.h" 3 4
struct timeval {
        int32_t tv_sec;
        int32_t tv_usec;
};
# 93 "/usr/include/sys/time.h" 3 4
struct timezone {
        int tz_minuteswest;
        int tz_dsttime;
};
# 141 "/usr/include/sys/time.h" 3 4
struct itimerval {
        struct timeval it_interval;
        struct timeval it_value;
};




struct clockinfo {
        int hz;
        int tick;
        int tickadj;
        int stathz;
        int profhz;
};
# 179 "/usr/include/sys/time.h" 3 4
extern "C" {
int adjtime (const struct timeval *, struct timeval *);
int futimes (int, const struct timeval *);
int getitimer (int, struct itimerval *);
int gettimeofday (struct timeval *, struct timezone *);
int setitimer (int, const struct itimerval *, struct itimerval *);
int settimeofday (const struct timeval *, const struct timezone *);
int utimes (const char *, const struct timeval *);
}
# 169 "/usr/include/pthread.h" 2 3 4




int pthread_attr_destroy (pthread_attr_t *attr);
int pthread_attr_getdetachstate (const pthread_attr_t *attr, int *detachstate);

int pthread_attr_getinheritsched (const pthread_attr_t *attr, int *inheritsched);

int pthread_attr_getschedparam (const pthread_attr_t *attr, struct sched_param *param);

int pthread_attr_getschedpolicy (const pthread_attr_t *attr, int *policy);

int pthread_attr_getstackaddr (const pthread_attr_t *attr, void **stackaddr);

int pthread_attr_getstacksize (const pthread_attr_t *attr, size_t *stacksize);

int pthread_attr_getstack (const pthread_attr_t *attr, void **stackaddr, size_t *stacksize);

int pthread_attr_init (pthread_attr_t *attr);
int pthread_attr_setdetachstate (pthread_attr_t *attr, int detachstate);

int pthread_attr_setinheritsched (pthread_attr_t *attr, int inheritsched);

int pthread_attr_setschedparam (pthread_attr_t *attr, const struct sched_param *param);

int pthread_attr_setschedpolicy (pthread_attr_t *attr, int policy);

int pthread_attr_setstackaddr (pthread_attr_t *attr, void *stackaddr);

int pthread_attr_setstacksize (pthread_attr_t *attr, size_t stacksize);

int pthread_attr_setstack (pthread_attr_t *attr, void *stackaddr, size_t stacksize);

int pthread_cancel (pthread_t thread);
int pthread_setcancelstate (int state, int *oldstate);
int pthread_setcanceltype (int type, int *oldtype);
void pthread_testcancel (void);
int pthread_cond_broadcast (pthread_cond_t *cond);
int pthread_cond_destroy (pthread_cond_t *cond);
int pthread_cond_init (pthread_cond_t *cond, const pthread_condattr_t *attr);

int pthread_cond_signal (pthread_cond_t *cond);
int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex);

int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);


int pthread_condattr_init (pthread_condattr_t *attr);
int pthread_condattr_destroy (pthread_condattr_t *attr);
int pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared);

int pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared);

int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);



int pthread_detach (pthread_t thread);
int pthread_equal (pthread_t t1, pthread_t t2);

void pthread_exit (void *value_ptr);
int pthread_kill (pthread_t, int);
int pthread_sigmask (int, const sigset_t *, sigset_t *);
int sigwait (const sigset_t *, int *);
int pthread_getschedparam (pthread_t thread, int *policy, struct sched_param *param);


int pthread_join (pthread_t thread, void **value_ptr);

int pthread_mutex_destroy (pthread_mutex_t *mutex);
int pthread_mutex_getprioceiling (const pthread_mutex_t *mutex, int *prioceiling);

int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

int pthread_mutex_lock (pthread_mutex_t *mutex);
int pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prioceiling, int *old_prioceiling);


int pthread_mutex_trylock (pthread_mutex_t *mutex);
int pthread_mutex_unlock (pthread_mutex_t *mutex);
int pthread_mutexattr_destroy (pthread_mutexattr_t *attr);
int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr, int *prioceiling);

int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr, int *protocol);

int pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr, int *pshared);

int pthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *type);

int pthread_mutexattr_init (pthread_mutexattr_t *attr);
int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr, int prioceiling);

int pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr, int protocol);

int pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type);

int pthread_mutexattr_setpshared (pthread_mutexattr_t *attr, int pshared);

int pthread_once (pthread_once_t *once_control, void (*init_routine)(void));

pthread_t pthread_self (void);
int pthread_setschedparam (pthread_t thread, int policy, const struct sched_param *param);


int pthread_key_create (pthread_key_t *key, void (*destructor)(void *));

int pthread_key_delete (pthread_key_t key);
int pthread_setspecific (pthread_key_t key, const void *value);

void *pthread_getspecific (pthread_key_t key);
int pthread_attr_getscope (pthread_attr_t *, int *);
int pthread_attr_setscope (pthread_attr_t *, int);
int pthread_getconcurrency (void);
int pthread_setconcurrency (int);
int pthread_rwlock_destroy (pthread_rwlock_t * rwlock);
int pthread_rwlock_init (pthread_rwlock_t * rwlock, const pthread_rwlockattr_t *attr);

int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock (pthread_rwlock_t *rwlock);
int pthread_rwlockattr_init (pthread_rwlockattr_t *attr);
int pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr);
int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared);

int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared);




int pthread_is_threaded_np (void);


int pthread_main_np (void);


mach_port_t pthread_mach_thread_np (pthread_t);
size_t pthread_get_stacksize_np (pthread_t);
void * pthread_get_stackaddr_np (pthread_t);


int pthread_cond_signal_thread_np (pthread_cond_t *, pthread_t);


int pthread_cond_timedwait_relative_np (pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *reltime);




int pthread_create_suspended_np (pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);



void pthread_yield_np (void);

}
# 38 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr-default.h" 2 3

typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
# 89 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 437 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr-default.h" 3
static inline int
__gthread_once (__gthread_once_t *once, void (*func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (once, func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))
{
  return pthread_key_create (key, dtor);
}

static inline int
__gthread_key_dtor (__gthread_key_t key, void *ptr)
{

  if (ptr)
    return pthread_setspecific (key, 0);
  else
    return 0;
}

static inline int
__gthread_key_delete (__gthread_key_t key)
{
  return pthread_key_delete (key);
}

static inline void *
__gthread_getspecific (__gthread_key_t key)
{
  return pthread_getspecific (key);
}

static inline int
__gthread_setspecific (__gthread_key_t key, const void *ptr)
{
  return pthread_setspecific (key, ptr);
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_unlock (__gthread_mutex_t *mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (mutex);
  else
    return 0;
}
# 99 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/gthr.h" 2 3
# 38 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++io.h" 2 3

namespace std
{

  typedef long streamoff;
  typedef ptrdiff_t streamsize;



  typedef fpos_t __c_streampos;

  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


  struct __ios_flags
  {
    typedef short __int_type;

    static const __int_type _S_boolalpha = 0x0001;
    static const __int_type _S_dec = 0x0002;
    static const __int_type _S_fixed = 0x0004;
    static const __int_type _S_hex = 0x0008;
    static const __int_type _S_internal = 0x0010;
    static const __int_type _S_left = 0x0020;
    static const __int_type _S_oct = 0x0040;
    static const __int_type _S_right = 0x0080;
    static const __int_type _S_scientific = 0x0100;
    static const __int_type _S_showbase = 0x0200;
    static const __int_type _S_showpoint = 0x0400;
    static const __int_type _S_showpos = 0x0800;
    static const __int_type _S_skipws = 0x1000;
    static const __int_type _S_unitbuf = 0x2000;
    static const __int_type _S_uppercase = 0x4000;
    static const __int_type _S_adjustfield = 0x0020 | 0x0080 | 0x0010;
    static const __int_type _S_basefield = 0x0002 | 0x0040 | 0x0008;
    static const __int_type _S_floatfield = 0x0100 | 0x0004;


    static const __int_type _S_badbit = 0x01;
    static const __int_type _S_eofbit = 0x02;
    static const __int_type _S_failbit = 0x04;


    static const __int_type _S_app = 0x01;
    static const __int_type _S_ate = 0x02;
    static const __int_type _S_bin = 0x04;
    static const __int_type _S_in = 0x08;
    static const __int_type _S_out = 0x10;
    static const __int_type _S_trunc = 0x20;
  };
}
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/bits/fpos.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cwchar" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cwchar" 3



# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ctime" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/ctime" 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 52 "/usr/include/gcc/darwin/3.1/g++-v3/cwchar" 2 3
# 60 "/usr/include/gcc/darwin/3.1/g++-v3/cwchar" 3
extern "C"
{
  typedef struct
  {
    int __fill[6];
  } mbstate_t;
}


namespace std
{
  using ::mbstate_t;
}
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/bits/fpos.h" 2 3

namespace std
{



  template<typename _StateT>
    class fpos
    {
    public:

      typedef _StateT __state_type;

    private:
      streamoff _M_off;
      __state_type _M_st;

    public:
      __state_type
      state() const { return _M_st; }

      void
      state(__state_type __st) { _M_st = __st; }



      fpos(): _M_off(streamoff()), _M_st(__state_type()) { }

      fpos(streamoff __off, __state_type __st = __state_type())
      : _M_off(__off), _M_st(__st) { }

      operator streamoff() const { return _M_off; }

      fpos&
      operator+=(streamoff __off) { _M_off += __off; return *this; }

      fpos&
      operator-=(streamoff __off) { _M_off -= __off; return *this; }

      fpos
      operator+(streamoff __off)
      {
        fpos __t(*this);
        __t += __off;
        return __t;
      }

      fpos
      operator-(streamoff __off)
      {
        fpos __t(*this);
        __t -= __off;
        return __t;
      }

      bool
      operator==(const fpos& __pos) const
      { return _M_off == __pos._M_off; }

      bool
      operator!=(const fpos& __pos) const
      { return _M_off != __pos._M_off; }

      streamoff
      _M_position() const { return _M_off; }

      void
      _M_position(streamoff __off) { _M_off = __off; }
    };


  typedef fpos<mbstate_t> streampos;



}
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/iosfwd" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 1 3
# 34 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/exception_defines.h" 1 3
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/iosfwd" 2 3

namespace std
{
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
            typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  class ios_base;


  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;

  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;
}
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/exception" 1 3
# 40 "/usr/include/gcc/darwin/3.1/g++-v3/exception" 3
extern "C++" {

namespace std
{






  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 98 "/usr/include/gcc/darwin/3.1/g++-v3/exception" 3
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 111 "/usr/include/gcc/darwin/3.1/g++-v3/exception" 3
  void __verbose_terminate_handler ();
}

}
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/char_traits.h" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/bits/char_traits.h" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cstring" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cstring" 3



# 1 "/usr/include/string.h" 1 3 4
# 72 "/usr/include/string.h" 3 4
extern "C" {
void *memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void *memcpy (void *, const void *, size_t);
void *memmove (void *, const void *, size_t);
void *memset (void *, int, size_t);
char *strcat (char *, const char *);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *, const char *);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *, const char *, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *, const char *, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);
char *strtok (char *, const char *);
size_t strxfrm (char *, const char *, size_t);



int bcmp (const void *, const void *, size_t);
void bcopy (const void *, void *, size_t);
void bzero (void *, size_t);
int ffs (int);
char *index (const char *, int);
void *memccpy (void *, const void *, int, size_t);
char *rindex (const char *, int);
int strcasecmp (const char *, const char *);
char *strdup (const char *);
size_t strlcat (char *, const char *, size_t);
size_t strlcpy (char *, const char *, size_t);
void strmode (int, char *);
int strncasecmp (const char *, const char *, size_t);
char *strsep (char **, const char *);
char *strtok_r (char *, const char *, char **);
void swab (const void *, void *, size_t);

}
# 52 "/usr/include/gcc/darwin/3.1/g++-v3/cstring" 2 3
# 77 "/usr/include/gcc/darwin/3.1/g++-v3/cstring" 3
namespace std
{
  using ::memcpy;
  using ::memmove;
  using ::strcpy;
  using ::strncpy;
  using ::strcat;
  using ::strncat;
  using ::memcmp;
  using ::strcmp;
  using ::strcoll;
  using ::strncmp;
  using ::strxfrm;
  using ::strcspn;
  using ::strspn;
  using ::strtok;
  using ::memset;
  using ::strerror;
  using ::strlen;

  using ::memchr;

  inline void*
  memchr(void* __p, int __c, size_t __n)
  { return memchr(const_cast<const void*>(__p), __c, __n); }

  using ::strchr;

  inline char*
  strchr(char* __s1, int __n)
  { return __builtin_strchr(const_cast<const char*>(__s1), __n); }

  using ::strpbrk;

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }

  using ::strrchr;

  inline char*
  strrchr(char* __s1, int __n)
  { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }

  using ::strstr;

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
}
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/bits/char_traits.h" 2 3


namespace std
{



  template<class _CharT>
    struct char_traits
    {
      typedef _CharT char_type;

      typedef unsigned long int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
        for (size_t __i = 0; __i < __n; ++__i)
          if (!eq(__s1[__i], __s2[__i]))
            return lt(__s1[__i], __s2[__i]) ? -1 : 1;
        return 0;
      }

      static size_t
      length(const char_type* __s)
      {
        const char_type* __p = __s;
        while (*__p) ++__p;
        return (__p - __s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
        for (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)
          if (*__p == __a) return __p;
        return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
        for (char_type* __p = __s; __p < __s + __n; ++__p)
          assign(*__p, __a);
        return __s;
      }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c) { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }
    };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof() { return static_cast<int_type>((-1)); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
# 269 "/usr/include/gcc/darwin/3.1/g++-v3/bits/char_traits.h" 3
  template<typename _CharT, typename _Traits>
    struct _Char_traits_match
    {
      _CharT _M_c;
      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }

      bool
      operator()(_CharT const& __a) { return _Traits::eq(_M_c, __a); }
    };
}
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++locale.h" 1 3
# 36 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++locale.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/clocale" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/clocale" 3

# 1 "/usr/include/locale.h" 1 3 4
# 39 "/usr/include/locale.h" 3 4
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
};
# 76 "/usr/include/locale.h" 3 4
extern "C" {
struct lconv *localeconv (void);
char *setlocale (int, const char *);
}
# 50 "/usr/include/gcc/darwin/3.1/g++-v3/clocale" 2 3





namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 37 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/c++locale.h" 2 3

namespace std
{
  typedef int* __c_locale;
}
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/climits" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/climits" 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cctype" 1 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/cctype" 3

# 1 "/usr/include/ctype.h" 1 3 4
# 68 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/runetype.h" 1 3 4
# 66 "/usr/include/runetype.h" 3 4
typedef struct {
        rune_t min;
        rune_t max;
        rune_t map;
        unsigned long *types;
} _RuneEntry;

typedef struct {
        int nranges;
        _RuneEntry *ranges;
} _RuneRange;

typedef struct {
        char magic[8];
        char encoding[32];

        rune_t (*sgetrune)
            (const char *, size_t, char const **);
        int (*sputrune)
            (rune_t, char *, size_t, char **);
        rune_t invalid_rune;

        unsigned long runetype[(1 <<8 )];
        rune_t maplower[(1 <<8 )];
        rune_t mapupper[(1 <<8 )];






        _RuneRange runetype_ext;
        _RuneRange maplower_ext;
        _RuneRange mapupper_ext;

        void *variable;
        int variable_len;
} _RuneLocale;



extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
# 69 "/usr/include/ctype.h" 2 3 4
# 100 "/usr/include/ctype.h" 3 4
extern "C" {
int isalnum (int);
int isalpha (int);
int iscntrl (int);
int isdigit (int);
int isgraph (int);
int islower (int);
int isprint (int);
int ispunct (int);
int isspace (int);
int isupper (int);
int isxdigit (int);
int tolower (int);
int toupper (int);


int digittoint (int);
int isascii (int);
int isblank (int);
int ishexnumber (int);
int isideogram (int);
int isnumber (int);
int isphonogram (int);
int isrune (int);
int isspecial (int);
int toascii (int);

}
# 158 "/usr/include/ctype.h" 3 4
extern "C" {
unsigned long ___runetype (int);
int ___tolower (int);
int ___toupper (int);
}
# 180 "/usr/include/ctype.h" 3 4
static inline int
__maskrune(int _c, unsigned long _f)
{
        return ((_c < 0 || _c >= (1 <<8 )) ? ___runetype(_c) :
                _CurrentRuneLocale->runetype[_c]) & _f;
}

static inline int
__istype(int c, unsigned long f)
{
        return !!(__maskrune(c, f));
}

static inline int
__isctype(int _c, unsigned long _f)
{
        return (_c < 0 || _c >= (1 <<8 )) ? 0 :
                !!(_DefaultRuneLocale.runetype[_c] & _f);
}

static inline int
__toupper(int _c)
{
        return (_c < 0 || _c >= (1 <<8 )) ? ___toupper(_c) :
                _CurrentRuneLocale->mapupper[_c];
}

static inline int
__tolower(int _c)
{
        return (_c < 0 || _c >= (1 <<8 )) ? ___tolower(_c) :
                _CurrentRuneLocale->maplower[_c];
}
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/cctype" 2 3
# 69 "/usr/include/gcc/darwin/3.1/g++-v3/cctype" 3
extern "C" {
extern int isalnum(int c);
extern int isalpha(int c);
extern int iscntrl(int c);
extern int isdigit(int c);
extern int isgraph(int c);
extern int islower(int c);
extern int isprint(int c);
extern int ispunct(int c);
extern int isspace(int c);
extern int isupper(int c);
extern int isxdigit(int c);
}


namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/string" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/string" 3




# 1 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 1 3
# 53 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 1 3
# 67 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cstdlib" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cstdlib" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 80 "/usr/include/stdlib.h" 3 4
typedef struct {
        int quot;
        int rem;
} div_t;

typedef struct {
        long quot;
        long rem;
} ldiv_t;
# 99 "/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;




extern "C" {
 void
         abort (void);
 int
         abs (int);
int atexit (void (*)(void));
double atof (const char *);
int atoi (const char *);
long atol (const char *);
void *bsearch (const void *, const void *, size_t, size_t, int (*)(const void *, const void *));

void *calloc (size_t, size_t);
 div_t
         div (int, int);
 void
         exit (int);
void free (void *);
char *getenv (const char *);
 long
         labs (long);
 ldiv_t
         ldiv (long, long);
void *malloc (size_t);
void qsort (void *, size_t, size_t, int (*)(const void *, const void *));

int rand (void);
void *realloc (void *, size_t);
void srand (unsigned);
double strtod (const char *, char **);
long strtol (const char *, char **, int);
unsigned long
         strtoul (const char *, char **, int);
int system (const char *);


int mblen (const char *, size_t);
size_t mbstowcs (wchar_t *, const char *, size_t);
int wctomb (char *, wchar_t);
int mbtowc (wchar_t *, const char *, size_t);
size_t wcstombs (char *, const wchar_t *, size_t);


int putenv (const char *);
int setenv (const char *, const char *, int);



double drand48 (void);
double erand48 (unsigned short[3]);
long jrand48 (unsigned short[3]);
void lcong48 (unsigned short[7]);
long lrand48 (void);
long mrand48 (void);
long nrand48 (unsigned short[3]);
unsigned short
        *seed48 (unsigned short[3]);
void srand48 (long);

void *alloca (size_t);

u_int32_t
         arc4random (void);
void arc4random_addrandom (unsigned char *dat, int datlen);
void arc4random_stir (void);
char *getbsize (int *, long *);
char *cgetcap (char *, char *, int);
int cgetclose (void);
int cgetent (char **, char **, char *);
int cgetfirst (char **, char **);
int cgetmatch (char *, char *);
int cgetnext (char **, char **);
int cgetnum (char *, char *, long *);
int cgetset (char *);
int cgetstr (char *, char *, char **);
int cgetustr (char *, char *, char **);

int daemon (int, int);
char *devname (int, int);
int getloadavg (double [], int);

long a64l (const char *);
char *l64a (long);

char *group_from_gid (unsigned long, int);
int heapsort (void *, size_t, size_t, int (*)(const void *, const void *));

char *initstate (unsigned long, char *, long);
int mergesort (void *, size_t, size_t, int (*)(const void *, const void *));

int radixsort (const unsigned char **, int, const unsigned char *, unsigned);

int sradixsort (const unsigned char **, int, const unsigned char *, unsigned);

int rand_r (unsigned *);
long random (void);
void *reallocf (void *, size_t);
char *realpath (const char *, char resolved_path[]);
char *setstate (char *);
void srandom (unsigned long);
char *user_from_uid (unsigned long, int);

long long
         strtoll(const char *, char **, int);
unsigned long long
         strtoull(const char *, char **, int);
long long
         strtoq (const char *, char **, int);
unsigned long long
         strtouq (const char *, char **, int);

void unsetenv (const char *);

}
# 53 "/usr/include/gcc/darwin/3.1/g++-v3/cstdlib" 2 3
# 84 "/usr/include/gcc/darwin/3.1/g++-v3/cstdlib" 3
namespace std
{
  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;

  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
# 68 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/new" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/new" 3
extern "C++" {

namespace std
{


  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    virtual ~bad_alloc() throw();
  };

  struct nothrow_t { };
  extern const nothrow_t nothrow;


  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler);
}
# 79 "/usr/include/gcc/darwin/3.1/g++-v3/new" 3
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }

}
# 70 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_pair.h" 1 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_pair.h" 3
namespace std
{


template <class _T1, class _T2>
struct pair {
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;




  pair() : first(), second() {}




  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}


  template <class _U1, class _U2>
  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
};


template <class _T1, class _T2>
inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first == __y.first && __x.second == __y.second;
}


template <class _T1, class _T2>
inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
{
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _T1, class _T2>
inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x == __y);
}


template <class _T1, class _T2>
inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return __y < __x;
}


template <class _T1, class _T2>
inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__y < __x);
}


template <class _T1, class _T2>
inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
  return !(__x < __y);
}
# 140 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_pair.h" 3
template <class _T1, class _T2>


inline pair<_T1, _T2> make_pair(_T1 __x, _T2 __y)



{
  return pair<_T1, _T2>(__x, __y);
}

}
# 72 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/type_traits.h" 1 3
# 53 "/usr/include/gcc/darwin/3.1/g++-v3/bits/type_traits.h" 3
# 90 "/usr/include/gcc/darwin/3.1/g++-v3/bits/type_traits.h" 3
struct __true_type {};
struct __false_type {};

template <class _Tp>
struct __type_traits {
   typedef __true_type this_dummy_member_must_be_first;
# 113 "/usr/include/gcc/darwin/3.1/g++-v3/bits/type_traits.h" 3
   typedef __false_type has_trivial_default_constructor;
   typedef __false_type has_trivial_copy_constructor;
   typedef __false_type has_trivial_assignment_operator;
   typedef __false_type has_trivial_destructor;
   typedef __false_type is_POD_type;
};




template<> struct __type_traits<bool> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<signed char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned char> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<wchar_t> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned short> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned int> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<unsigned long long> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<float> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template<> struct __type_traits<long double> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};

template <class _Tp>
struct __type_traits<_Tp*> {
   typedef __true_type has_trivial_default_constructor;
   typedef __true_type has_trivial_copy_constructor;
   typedef __true_type has_trivial_assignment_operator;
   typedef __true_type has_trivial_destructor;
   typedef __true_type is_POD_type;
};





template <class _Tp> struct _Is_integer {
  typedef __false_type _Integral;
};

template<> struct _Is_integer<bool> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<signed char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned char> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<wchar_t> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned short> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned int> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<long long> {
  typedef __true_type _Integral;
};

template<> struct _Is_integer<unsigned long long> {
  typedef __true_type _Integral;
};

template<typename _Tp> struct _Is_normal_iterator {
   typedef __false_type _Normal;
};


namespace __gnu_cxx
{
  template<typename _Iterator, typename _Container> class __normal_iterator;
}

template<typename _Iterator, typename _Container>
struct _Is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator, _Container> > {
   typedef __true_type _Normal;
};
# 73 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_types.h" 1 3
# 68 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_types.h" 3

namespace std
{
# 80 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag {};

  struct output_iterator_tag {};

  struct forward_iterator_tag : public input_iterator_tag {};

  struct bidirectional_iterator_tag : public forward_iterator_tag {};

  struct random_access_iterator_tag : public bidirectional_iterator_tag {};
# 100 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };







  template<typename _Iterator>
    struct iterator_traits {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Tp>
    struct iterator_traits<_Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };

  template<typename _Tp>
    struct iterator_traits<const _Tp*> {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };







  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }

}
# 74 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_funcs.h" 1 3
# 68 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_funcs.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/concept_check.h" 1 3
# 39 "/usr/include/gcc/darwin/3.1/g++-v3/bits/concept_check.h" 3
# 69 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_funcs.h" 2 3




namespace std
{
template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)
  {

   

    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }

template<typename _RandomAccessIterator>
  inline typename iterator_traits<_RandomAccessIterator>::difference_type
  __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
             random_access_iterator_tag)
  {

   
    return __last - __first;
  }
# 111 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_funcs.h" 3
template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {

    return __distance(__first, __last, __iterator_category(__first));
  }

template<typename _InputIter, typename _Distance>
  inline void
  __advance(_InputIter& __i, _Distance __n, input_iterator_tag)
  {

   
    while (__n--) ++__i;
  }

template<typename _BidirectionalIterator, typename _Distance>
  inline void
  __advance(_BidirectionalIterator& __i, _Distance __n,
            bidirectional_iterator_tag)
  {

   

    if (__n > 0)
      while (__n--) ++__i;
    else
      while (__n++) --__i;
  }

template<typename _RandomAccessIterator, typename _Distance>
  inline void
  __advance(_RandomAccessIterator& __i, _Distance __n,
            random_access_iterator_tag)
  {

   
    __i += __n;
  }
# 164 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator_base_funcs.h" 3
template<typename _InputIterator, typename _Distance>
  inline void
  advance(_InputIterator& __i, _Distance __n)
  {

    __advance(__i, __n, __iterator_category(__i));
  }

}
# 75 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 1 3
# 68 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
namespace std
{
# 89 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                      typename iterator_traits<_Iterator>::value_type,
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

    public:
      typedef _Iterator iterator_type;
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

    public:



      reverse_iterator() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
        : current(__x.base()) { }




      iterator_type
      base() const { return current; }






      reference
      operator*() const
      {
        _Iterator __tmp = current;
        return *--__tmp;
      }






      pointer
      operator->() const { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
        --current;
        return *this;
      }






      reverse_iterator
      operator++(int)
      {
        reverse_iterator __tmp = *this;
        --current;
        return __tmp;
      }






      reverse_iterator&
      operator--()
      {
        ++current;
        return *this;
      }






      reverse_iterator operator--(int)
      {
        reverse_iterator __tmp = *this;
        ++current;
        return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
        current -= __n;
        return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
        current += __n;
        return *this;
      }






      reference
      operator[](difference_type __n) const { return *(*this + __n); }
    };
# 269 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
                const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
               const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
              const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
              const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
# 327 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 353 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_back(__value);
        return *this;
      }


      back_insert_iterator&
      operator*() { return *this; }


      back_insert_iterator&
      operator++() { return *this; }


      back_insert_iterator
      operator++(int) { return *this; }
    };
# 384 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 397 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 422 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
        container->push_front(__value);
        return *this;
      }


      front_insert_iterator&
      operator*() { return *this; }


      front_insert_iterator&
      operator++() { return *this; }


      front_insert_iterator
      operator++(int) { return *this; }
    };
# 453 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 470 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 512 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::const_reference __value)
      {
        iter = container->insert(iter, __value);
        ++iter;
        return *this;
      }


      insert_iterator&
      operator*() { return *this; }


      insert_iterator&
      operator++() { return *this; }


      insert_iterator&
      operator++(int) { return *this; }
    };
# 544 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
                                         typename _Container::iterator(__i));
    }
}

namespace __gnu_cxx
{







  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                                                               difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      difference_type
      operator-(const __normal_iterator& __i) const
      { return _M_current - __i._M_current; }

      const _Iterator&
      base() const { return _M_current; }
    };
# 649 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
            const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
            const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
             const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
            const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
# 76 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 2 3


namespace std
{
# 91 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    inline void
    iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)
    {
      typedef typename iterator_traits<_ForwardIter1>::value_type _ValueType1;
      typedef typename iterator_traits<_ForwardIter2>::value_type _ValueType2;


     
     
     
     

      _ValueType1 __tmp = *__a;
      *__a = *__b;
      *__b = __tmp;
    }
# 118 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = __a;
      __a = __b;
      __b = __tmp;
    }
# 146 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a) return __b; return __a;
    }
# 166 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b) return __b; return __a;
    }
# 186 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a)) return __b; return __a;
    }
# 204 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b)) return __b; return __a;
    }
# 221 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy(_InputIter __first, _InputIter __last,
           _OutputIter __result,
           input_iterator_tag)
    {
      for ( ; __first != __last; ++__result, ++__first)
        *__result = *__first;
      return __result;
    }

  template<typename _RandomAccessIter, typename _OutputIter>
    inline _OutputIter
    __copy(_RandomAccessIter __first, _RandomAccessIter __last,
           _OutputIter __result,
           random_access_iterator_tag)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type
          _Distance;
      for (_Distance __n = __last - __first; __n > 0; --__n) {
        *__result = *__first;
        ++__first;
        ++__result;
      }
      return __result;
    }

  template<typename _Tp>
    inline _Tp*
    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)
    {
      memmove(__result, __first, sizeof(_Tp) * (__last - __first));
      return __result + (__last - __first);
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __false_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_aux2(_InputIter __first, _InputIter __last,
                _OutputIter __result, __true_type)
    { return __copy(__first, __last, __result, __iterator_category(__first)); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(_Tp* __first, _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _Tp>
    inline _Tp*
    __copy_aux2(const _Tp* __first, const _Tp* __last,
                _Tp* __result, __true_type)
    { return __copy_trivial(__first, __last, __result); }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return _OutputIter(__copy_aux2(__first, __last,
                                     __result.base(),
                                     _Trivial()));
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni2(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename iterator_traits<_InputIter>::value_type
          _ValueType;
      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator
          _Trivial;
      return __copy_aux2(__first, __last,
                         __result,
                         _Trivial());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first.base(), __last.base(), __result, __Normal());
    }

  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    __copy_ni1(_InputIter __first, _InputIter __last,
               _OutputIter __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;
      return __copy_ni2(__first, __last, __result, __Normal());
    }
# 339 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    copy(_InputIter __first, _InputIter __last, _OutputIter __result)
    {

     
     


       typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;
       return __copy_ni1(__first, __last, __result, __Normal());
    }




  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    inline _BidirectionalIter2
    __copy_backward(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
                    _BidirectionalIter2 __result,
                    bidirectional_iterator_tag)
    {
      while (__first != __last)
        *--__result = *--__last;
      return __result;
    }

  template<typename _RandomAccessIter, typename _BidirectionalIter>
    inline _BidirectionalIter
    __copy_backward(_RandomAccessIter __first, _RandomAccessIter __last,
                    _BidirectionalIter __result,
                    random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __n;
      for (__n = __last - __first; __n > 0; --__n)
        *--__result = *--__last;
      return __result;
    }







  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BoolType>
    struct __copy_backward_dispatch
    {
      static _BidirectionalIter2
      copy(_BidirectionalIter1 __first, _BidirectionalIter1 __last,
           _BidirectionalIter2 __result)
      {
        return __copy_backward(__first, __last,
                               __result,
                               __iterator_category(__first));
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        const ptrdiff_t _Num = __last - __first;
        memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
        return __result - _Num;
      }
    };

  template<typename _Tp>
    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
    {
      static _Tp*
      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)
      {
        return __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
          ::copy(__first, __last, __result);
      }
    };

  template<typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
                            ::has_trivial_assignment_operator _Trivial;
      return __copy_backward_dispatch<_BI1, _BI2, _Trivial>
                  ::copy(__first, __last, __result);
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __true_type)
    { return _BI2(__copy_backward_aux(__first, __last, __result.base())); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,
                                           _BI2 __result, __false_type)
    { return __copy_backward_aux(__first, __last, __result); }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __true_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first.base(), __last.base(),
                                                    __result, __Normal());
    }

  template <typename _BI1, typename _BI2>
    inline _BI2
    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,
                                          _BI2 __result, __false_type)
    {
      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;
      return __copy_backward_output_normal_iterator(__first, __last, __result,
                                                    __Normal());
    }
# 477 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template <typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     



      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;
      return __copy_backward_input_normal_iterator(__first, __last, __result,
                                                   __Normal());
    }
# 509 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)
    {

     

      for ( ; __first != __last; ++__first)
        *__first = __value;
    }
# 531 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _OutputIter, typename _Size, typename _Tp>
    _OutputIter
    fill_n(_OutputIter __first, _Size __n, const _Tp& __value)
    {

     

      for ( ; __n > 0; --__n, ++__first)
        *__first = __value;
      return __first;
    }



  inline void
  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)
  {
    unsigned char __tmp = __c;
    memset(__first, __tmp, __last - __first);
  }

  inline void
  fill(signed char* __first, signed char* __last, const signed char& __c)
  {
    signed char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  inline void
  fill(char* __first, char* __last, const char& __c)
  {
    char __tmp = __c;
    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
  }

  template<typename _Size>
    inline unsigned char*
    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline signed char*
    fill_n(char* __first, _Size __n, const signed char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }

  template<typename _Size>
    inline char*
    fill_n(char* __first, _Size __n, const char& __c)
    {
      fill(__first, __first + __n, __c);
      return __first + __n;
    }
# 606 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2)
    {

     
     
     

     


      while (__first1 != __last1 && *__first1 == *__first2) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 640 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    pair<_InputIter1, _InputIter2>
    mismatch(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2,
             _BinaryPredicate __binary_pred)
    {

     
     

      while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
        ++__first1;
        ++__first2;
      }
      return pair<_InputIter1, _InputIter2>(__first1, __first2);
    }
# 668 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!(*__first1 == *__first2))
          return false;
      return true;
    }
# 699 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>
    inline bool
    equal(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2,
          _BinaryPredicate __binary_pred)
    {

     
     

      for ( ; __first1 != __last1; ++__first1, ++__first2)
        if (!__binary_pred(*__first1, *__first2))
          return false;
      return true;
    }
# 732 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     

     


      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (*__first1 < *__first2)
          return true;
        if (*__first2 < *__first1)
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }
# 767 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _Compare __comp)
    {

     
     

      for ( ; __first1 != __last1 && __first2 != __last2
            ; ++__first1, ++__first2) {
        if (__comp(*__first1, *__first2))
          return true;
        if (__comp(*__first2, *__first1))
          return false;
      }
      return __first1 == __last1 && __first2 != __last2;
    }

  inline bool
  lexicographical_compare(const unsigned char* __first1, const unsigned char* __last1,
                          const unsigned char* __first2, const unsigned char* __last2)
  {
    const size_t __len1 = __last1 - __first1;
    const size_t __len2 = __last2 - __first2;
    const int __result = memcmp(__first1, __first2, min(__len1, __len2));
    return __result != 0 ? __result < 0 : __len1 < __len2;
  }

  inline bool
  lexicographical_compare(const char* __first1, const char* __last1,
                          const char* __first2, const char* __last2)
  {

    return lexicographical_compare((const signed char*) __first1,
                                   (const signed char*) __last1,
                                   (const signed char*) __first2,
                                   (const signed char*) __last2);






  }

}
# 55 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 1 3
# 84 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cassert" 1 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/cassert" 3

# 1 "/usr/include/gcc/darwin/3.1/assert.h" 1 3 4
# 40 "/usr/include/gcc/darwin/3.1/assert.h" 3 4
extern "C" {
extern void __eprintf (const char *, const char *, unsigned, const char *)
    __attribute__ ((noreturn));
}
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/cassert" 2 3
# 85 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 1 3
# 34 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/exception_defines.h" 1 3
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 86 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 1 3
# 54 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 3
namespace std
{




  struct _Refcount_Base
  {

    typedef size_t _RC_t;


    volatile _RC_t _M_ref_count;


    __gthread_mutex_t _M_ref_count_lock;

    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)
    {

      __gthread_mutex_t __tmp = {0x32AAABA7, {}};
      _M_ref_count_lock = __tmp;





    }

    void
    _M_incr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      ++_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
    }

    _RC_t
    _M_decr()
    {
      __gthread_mutex_lock(&_M_ref_count_lock);
      volatile _RC_t __tmp = --_M_ref_count;
      __gthread_mutex_unlock(&_M_ref_count_lock);
      return __tmp;
    }
  };
# 109 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 3
  template<int __dummy>
    struct _Swap_lock_struct
    { static __gthread_mutex_t _S_swap_lock; };

  template<int __dummy>
    __gthread_mutex_t
    _Swap_lock_struct<__dummy>::_S_swap_lock = {0x32AAABA7, {}};



  inline unsigned long
  _Atomic_swap(unsigned long * __p, unsigned long __q)
  {
    __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);
    unsigned long __result = *__p;
    *__p = __q;
    __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);
    return __result;
  }
# 151 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 3
  struct _STL_mutex_lock
  {





    __gthread_mutex_t _M_lock;

    void
    _M_initialize()
    {
# 184 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 3
    }

    void
    _M_acquire_lock()
    {



      __gthread_mutex_lock(&_M_lock);
    }

    void
    _M_release_lock()
    {



      __gthread_mutex_unlock(&_M_lock);
    }
  };
# 220 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_threads.h" 3
  struct _STL_auto_lock
  {
    _STL_mutex_lock& _M_lock;

    _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)
    { _M_lock._M_acquire_lock(); }

    ~_STL_auto_lock() { _M_lock._M_release_lock(); }

  private:
    void operator=(const _STL_auto_lock&);
    _STL_auto_lock(const _STL_auto_lock&);
  };

}
# 87 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 2 3

namespace std
{
# 98 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
  class __new_alloc
  {
  public:
    static void*
    allocate(size_t __n)
    { return ::operator new(__n); }

    static void
    deallocate(void* __p, size_t)
    { ::operator delete(__p); }
  };
# 121 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
  template <int __inst>
    class __malloc_alloc_template
    {
    private:
      static void* _S_oom_malloc(size_t);
      static void* _S_oom_realloc(void*, size_t);
      static void (* __malloc_alloc_oom_handler)();

    public:
      static void*
      allocate(size_t __n)
      {
        void* __result = malloc(__n);
        if (0 == __result) __result = _S_oom_malloc(__n);
        return __result;
      }

      static void
      deallocate(void* __p, size_t )
      { free(__p); }

      static void*
      reallocate(void* __p, size_t , size_t __new_sz)
      {
        void* __result = realloc(__p, __new_sz);
        if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);
        return __result;
      }

      static void (* __set_malloc_handler(void (*__f)()))()
      {
        void (* __old)() = __malloc_alloc_oom_handler;
        __malloc_alloc_oom_handler = __f;
        return(__old);
      }
    };


  template <int __inst>
    void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;

  template <int __inst>
    void*
    __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (0 == __my_malloc_handler)
            std::__throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = malloc(__n);
          if (__result)
            return(__result);
        }
    }

  template <int __inst>
    void*
    __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)
    {
      void (* __my_malloc_handler)();
      void* __result;

      for (;;)
        {
          __my_malloc_handler = __malloc_alloc_oom_handler;
          if (0 == __my_malloc_handler)
            std::__throw_bad_alloc();
          (*__my_malloc_handler)();
          __result = realloc(__p, __n);
          if (__result)
            return(__result);
        }
    }






  typedef __new_alloc __mem_interface;
# 219 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
  template<class _Tp, class _Alloc>
  class __simple_alloc
  {
  public:
    static _Tp* allocate(size_t __n)
    { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }

    static _Tp* allocate()
    { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }

    static void deallocate(_Tp* __p, size_t __n)
    { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }

    static void deallocate(_Tp* __p)
    { _Alloc::deallocate(__p, sizeof (_Tp)); }
  };
# 251 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
  template <class _Alloc>
  class __debug_alloc
  {
  private:
    enum {_S_extra = 8};


  public:

    static void* allocate(size_t __n)
    {
      char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);
      *(size_t*)__result = __n;
      return __result + (int) _S_extra;
    }

    static void deallocate(void* __p, size_t __n)
    {
      char* __real_p = (char*)__p - (int) _S_extra;
      ((void) ((*(size_t*)__real_p == __n) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n", "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h", 270, "*(size_t*)__real_p == __n"), 0)));
      _Alloc::deallocate(__real_p, __n + (int) _S_extra);
    }

    static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz)
    {
      char* __real_p = (char*)__p - (int) _S_extra;
      ((void) ((*(size_t*)__real_p == __old_sz) ? 0 : (__eprintf ("%s:%u: failed assertion `%s'\n", "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h", 277, "*(size_t*)__real_p == __old_sz"), 0)));
      char* __result = (char*)
        _Alloc::reallocate(__real_p, __old_sz + (int) _S_extra,
                                     __new_sz + (int) _S_extra);
      *(size_t*)__result = __new_sz;
      return __result + (int) _S_extra;
    }
  };
# 324 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
template<bool __threads, int __inst>
  class __default_alloc_template
  {
  private:
    enum {_ALIGN = 8};
    enum {_MAX_BYTES = 128};
    enum {_NFREELISTS = _MAX_BYTES / _ALIGN};

    union _Obj
    {
      union _Obj* _M_free_list_link;
      char _M_client_data[1];
    };

    static _Obj* volatile _S_free_list[_NFREELISTS];


    static char* _S_start_free;
    static char* _S_end_free;
    static size_t _S_heap_size;

    static _STL_mutex_lock _S_node_allocator_lock;

    static size_t
    _S_round_up(size_t __bytes)
    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }

    static size_t
    _S_freelist_index(size_t __bytes)
    { return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1); }



    static void*
    _S_refill(size_t __n);



    static char*
    _S_chunk_alloc(size_t __size, int& __nobjs);



    class _Lock
    {
    public:
      _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }
      ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }
    } __attribute__ ((__unused__));
    friend class _Lock;

  public:

    static void*
    allocate(size_t __n)
    {
      void* __ret = 0;

      if (__n > (size_t) _MAX_BYTES)
        __ret = __mem_interface::allocate(__n);
      else
        {
          _Obj* volatile* __my_free_list = _S_free_list
            + _S_freelist_index(__n);



          _Lock __lock_instance;
          _Obj* __restrict__ __result = *__my_free_list;
          if (__result == 0)
            __ret = _S_refill(_S_round_up(__n));
          else
            {
              *__my_free_list = __result -> _M_free_list_link;
              __ret = __result;
            }
        }
      return __ret;
    };


    static void
    deallocate(void* __p, size_t __n)
    {
      if (__n > (size_t) _MAX_BYTES)
        __mem_interface::deallocate(__p, __n);
      else
        {
          _Obj* volatile* __my_free_list
            = _S_free_list + _S_freelist_index(__n);
          _Obj* __q = (_Obj*)__p;



          _Lock __lock_instance;
          __q -> _M_free_list_link = *__my_free_list;
          *__my_free_list = __q;
        }
    }

    static void*
    reallocate(void* __p, size_t __old_sz, size_t __new_sz);
  };


  template<bool __threads, int __inst>
    inline bool
    operator==(const __default_alloc_template<__threads, __inst>&,
               const __default_alloc_template<__threads, __inst>&)
    { return true; }

  template<bool __threads, int __inst>
    inline bool
    operator!=(const __default_alloc_template<__threads, __inst>&,
               const __default_alloc_template<__threads, __inst>&)
    { return false; }





  template<bool __threads, int __inst>
    char*
    __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,
                                                                int& __nobjs)
    {
      char* __result;
      size_t __total_bytes = __size * __nobjs;
      size_t __bytes_left = _S_end_free - _S_start_free;

      if (__bytes_left >= __total_bytes)
      {
        __result = _S_start_free;
        _S_start_free += __total_bytes;
        return(__result);
      }
      else if (__bytes_left >= __size)
        {
          __nobjs = (int)(__bytes_left/__size);
          __total_bytes = __size * __nobjs;
          __result = _S_start_free;
          _S_start_free += __total_bytes;
          return(__result);
        }
      else
        {
          size_t __bytes_to_get =
            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);

          if (__bytes_left > 0)
            {
              _Obj* volatile* __my_free_list =
                _S_free_list + _S_freelist_index(__bytes_left);

              ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;
              *__my_free_list = (_Obj*)_S_start_free;
            }
          _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);
          if (0 == _S_start_free)
            {
              size_t __i;
              _Obj* volatile* __my_free_list;
              _Obj* __p;



              __i = __size;
              for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN)
                {
                  __my_free_list = _S_free_list + _S_freelist_index(__i);
                  __p = *__my_free_list;
                  if (0 != __p)
                    {
                      *__my_free_list = __p -> _M_free_list_link;
                      _S_start_free = (char*)__p;
                      _S_end_free = _S_start_free + __i;
                      return(_S_chunk_alloc(__size, __nobjs));


                    }
                }
              _S_end_free = 0;
              _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);


            }
          _S_heap_size += __bytes_to_get;
          _S_end_free = _S_start_free + __bytes_to_get;
          return(_S_chunk_alloc(__size, __nobjs));
        }
    }





  template<bool __threads, int __inst>
    void*
    __default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
    {
      int __nobjs = 20;
      char* __chunk = _S_chunk_alloc(__n, __nobjs);
      _Obj* volatile* __my_free_list;
      _Obj* __result;
      _Obj* __current_obj;
      _Obj* __next_obj;
      int __i;

      if (1 == __nobjs) return(__chunk);
      __my_free_list = _S_free_list + _S_freelist_index(__n);


      __result = (_Obj*)__chunk;
      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
      for (__i = 1; ; __i++) {
        __current_obj = __next_obj;
        __next_obj = (_Obj*)((char*)__next_obj + __n);
        if (__nobjs - 1 == __i) {
          __current_obj -> _M_free_list_link = 0;
          break;
        } else {
          __current_obj -> _M_free_list_link = __next_obj;
        }
      }
      return(__result);
    }


  template<bool threads, int inst>
    void*
    __default_alloc_template<threads, inst>::reallocate(void* __p,
                                                        size_t __old_sz,
                                                        size_t __new_sz)
    {
      void* __result;
      size_t __copy_sz;

      if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {
        return(realloc(__p, __new_sz));
      }
      if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);
      __result = allocate(__new_sz);
      __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
      memcpy(__result, __p, __copy_sz);
      deallocate(__p, __old_sz);
      return(__result);
    }

  template<bool __threads, int __inst>
  _STL_mutex_lock
  __default_alloc_template<__threads, __inst>::_S_node_allocator_lock
  = { {0x32AAABA7, {}} };

  template<bool __threads, int __inst>
  char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;

  template<bool __threads, int __inst>
  char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;

  template<bool __threads, int __inst>
  size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;

  template<bool __threads, int __inst>
  typename __default_alloc_template<__threads, __inst>::_Obj* volatile
  __default_alloc_template<__threads, __inst>::_S_free_list[_NFREELISTS];

  typedef __default_alloc_template<true, 0> __alloc;
  typedef __default_alloc_template<false, 0> __single_client_alloc;
# 613 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
template <class _Tp>
class allocator
{
  typedef __alloc _Alloc;
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() throw() {}
  allocator(const allocator&) throw() {}
  template <class _Tp1> allocator(const allocator<_Tp1>&) throw() {}
  ~allocator() throw() {}

  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }



  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)))
                    : 0;
  }


  void deallocate(pointer __p, size_type __n)
    { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }

  size_type max_size() const throw()
    { return size_t(-1) / sizeof(_Tp); }

  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
  void destroy(pointer __p) { __p->~_Tp(); }
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};


template <class _T1, class _T2>
inline bool operator==(const allocator<_T1>&, const allocator<_T2>&)
{
  return true;
}

template <class _T1, class _T2>
inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)
{
  return false;
}
# 695 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
template <class _Tp, class _Alloc>
struct __allocator
{
  _Alloc __underlying_alloc;

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp* pointer;
  typedef const _Tp* const_pointer;
  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef __allocator<_Tp1, _Alloc> other;
  };

  __allocator() throw() {}
  __allocator(const __allocator& __a) throw()
    : __underlying_alloc(__a.__underlying_alloc) {}
  template <class _Tp1>
  __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()
    : __underlying_alloc(__a.__underlying_alloc) {}
  ~__allocator() throw() {}

  pointer address(reference __x) const { return &__x; }
  const_pointer address(const_reference __x) const { return &__x; }


  _Tp* allocate(size_type __n, const void* = 0) {
    return __n != 0
        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp)))
        : 0;
  }


  void deallocate(pointer __p, size_type __n)
    { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }

  size_type max_size() const throw()
    { return size_t(-1) / sizeof(_Tp); }

  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
  void destroy(pointer __p) { __p->~_Tp(); }
};

template <class _Alloc>
class __allocator<void, _Alloc> {
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef __allocator<_Tp1, _Alloc> other;
  };
};

template <class _Tp, class _Alloc>
inline bool operator==(const __allocator<_Tp, _Alloc>& __a1,
                       const __allocator<_Tp, _Alloc>& __a2)
{
  return __a1.__underlying_alloc == __a2.__underlying_alloc;
}

template <class _Tp, class _Alloc>
inline bool operator!=(const __allocator<_Tp, _Alloc>& __a1,
                       const __allocator<_Tp, _Alloc>& __a2)
{
  return __a1.__underlying_alloc != __a2.__underlying_alloc;
}







template <int inst>
inline bool operator==(const __malloc_alloc_template<inst>&,
                       const __malloc_alloc_template<inst>&)
{
  return true;
}

template <int __inst>
inline bool operator!=(const __malloc_alloc_template<__inst>&,
                       const __malloc_alloc_template<__inst>&)
{
  return false;
}

template <class _Alloc>
inline bool operator==(const __debug_alloc<_Alloc>&,
                       const __debug_alloc<_Alloc>&) {
  return true;
}

template <class _Alloc>
inline bool operator!=(const __debug_alloc<_Alloc>&,
                       const __debug_alloc<_Alloc>&) {
  return false;
}
# 840 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_alloc.h" 3
template <class _Tp, class _Allocator>
struct _Alloc_traits
{
  static const bool _S_instanceless = false;
  typedef typename _Allocator::template rebind<_Tp>::other allocator_type;
};

template <class _Tp, class _Allocator>
const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;


template <class _Tp, class _Tp1>
struct _Alloc_traits<_Tp, allocator<_Tp1> >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __alloc> _Alloc_type;
  typedef allocator<_Tp> allocator_type;
};




template <class _Tp, int __inst>
struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
};


template <class _Tp, bool __threads, int __inst>
struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __default_alloc_template<__threads, __inst> >
          _Alloc_type;
  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >
          allocator_type;
};


template <class _Tp, class _Alloc>
struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
  typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
};




template <class _Tp, class _Tp1, int __inst>
struct _Alloc_traits<_Tp,
                     __allocator<_Tp1, __malloc_alloc_template<__inst> > >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
};


template <class _Tp, class _Tp1, bool __thr, int __inst>
struct _Alloc_traits<_Tp,
                      __allocator<_Tp1,
                                  __default_alloc_template<__thr, __inst> > >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __default_alloc_template<__thr,__inst> >
          _Alloc_type;
  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >
          allocator_type;
};


template <class _Tp, class _Tp1, class _Alloc>
struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >
{
  static const bool _S_instanceless = true;
  typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;
  typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;
};





  extern template class allocator<char>;
  extern template class allocator<wchar_t>;



  extern template class __default_alloc_template<true, 0>;

}
# 56 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_construct.h" 1 3
# 67 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_construct.h" 3
namespace std
{






  template <class _T1, class _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    { new (static_cast<void*>(__p)) _T1(__value); }







  template <class _T1>
    inline void
    _Construct(_T1* __p)
    { new (static_cast<void*>(__p)) _T1(); }
# 98 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
    { for ( ; __first != __last; ++__first) _Destroy(&*__first); }
# 112 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)
    { }






  template <class _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
# 134 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_construct.h" 3
  template <class _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      typedef typename __type_traits<_Value_type>::has_trivial_destructor
                       _Has_trivial_destructor;

      __destroy_aux(__first, __last, _Has_trivial_destructor());
    }
}
# 57 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 1 3
# 66 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 3
namespace std
{



  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __true_type)
    { return copy(__first, __last, __result); }

  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,
                             _ForwardIter __result,
                             __false_type)
    {
      _ForwardIter __cur = __result;
      try {
        for ( ; __first != __last; ++__first, ++__cur)
          _Construct(&*__cur, *__first);
        return __cur;
      }
      catch(...)
        {
          _Destroy(__result, __cur);
          throw;
        }
    }
# 106 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 3
  template<typename _InputIter, typename _ForwardIter>
    inline _ForwardIter
    uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)
    {
      typedef typename iterator_traits<_InputIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());
    }

  inline char*
  uninitialized_copy(const char* __first, const char* __last, char* __result)
  {
    memmove(__result, __first, __last - __first);
    return __result + (__last - __first);
  }

  inline wchar_t*
  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
                     wchar_t* __result)
  {
    memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
    return __result + (__last - __first);
  }



  template<typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __true_type)
    { fill(__first, __last, __x); }

  template<typename _ForwardIter, typename _Tp>
    void
    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,
                             const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      try {
        for ( ; __cur != __last; ++__cur)
          _Construct(&*__cur, __x);
      }
      catch(...)
        {
          _Destroy(__first, __cur);
          throw;
        }
    }
# 164 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      __uninitialized_fill_aux(__first, __last, __x, _Is_POD());
    }



  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __true_type)
    {
      return fill_n(__first, __n, __x);
    }

  template<typename _ForwardIter, typename _Size, typename _Tp>
    _ForwardIter
    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
                               const _Tp& __x, __false_type)
    {
      _ForwardIter __cur = __first;
      try {
        for ( ; __n > 0; --__n, ++__cur)
          _Construct(&*__cur, __x);
        return __cur;
      }
      catch(...)
        {
          _Destroy(__first, __cur);
          throw;
        }
    }
# 210 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 3
  template<typename _ForwardIter, typename _Size, typename _Tp>
    inline _ForwardIter
    uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;
      return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
    }
# 227 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_uninitialized.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _ForwardIter>
    inline _ForwardIter
    __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _ForwardIter __result)
    {
      _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);
      try {
        return uninitialized_copy(__first2, __last2, __mid);
      }
      catch(...)
        {
          _Destroy(__result, __mid);
          throw;
        }
    }




  template<typename _ForwardIter, typename _Tp, typename _InputIter>
    inline _ForwardIter
    __uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,
                              const _Tp& __x,
                              _InputIter __first, _InputIter __last)
    {
      uninitialized_fill(__result, __mid, __x);
      try {
        return uninitialized_copy(__first, __last, __mid);
      }
      catch(...)
        {
          _Destroy(__result, __mid);
          throw;
        }
    }




  template<typename _InputIter, typename _ForwardIter, typename _Tp>
    inline void
    __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
                              _ForwardIter __first2, _ForwardIter __last2,
                              const _Tp& __x)
    {
      _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);
      try {
        uninitialized_fill(__mid2, __last2, __x);
      }
      catch(...)
        {
          _Destroy(__first2, __mid2);
          throw;
        }
    }

}
# 59 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_raw_storage_iter.h" 1 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_raw_storage_iter.h" 3
namespace std
{




  template <class _ForwardIterator, class _Tp>
  class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _ForwardIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
        _Construct(&*_M_iter, __element);
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>&
      operator++()
      {
        ++_M_iter;
        return *this;
      }

      raw_storage_iterator<_ForwardIterator, _Tp>
      operator++(int)
      {
        raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
        ++_M_iter;
        return __tmp;
      }
    };
}
# 60 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 2 3

namespace std
{







  template <class _Tp>
  pair<_Tp*, ptrdiff_t>
  __get_temporary_buffer(ptrdiff_t __len, _Tp*)
  {
    if (__len > ptrdiff_t(2147483647 / sizeof(_Tp)))
      __len = 2147483647 / sizeof(_Tp);

    while (__len > 0) {
      _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));
      if (__tmp != 0)
        return pair<_Tp*, ptrdiff_t>(__tmp, __len);
      __len /= 2;
    }

    return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
  }
# 102 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 3
  template <class _Tp>
  inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
    return __get_temporary_buffer(__len, (_Tp*) 0);
  }
# 114 "/usr/include/gcc/darwin/3.1/g++-v3/memory" 3
  template <class _Tp>
  void return_temporary_buffer(_Tp* __p) {
    std::free(__p);
  }


template <class _Tp1>
  struct auto_ptr_ref
{
   _Tp1* _M_ptr;
   auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}
};




template <class _Tp>
  class auto_ptr
{
private:
  _Tp* _M_ptr;

public:
  typedef _Tp element_type;

  explicit auto_ptr(_Tp* __p = 0) throw() : _M_ptr(__p) {}
  auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) {}

  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) throw()
    : _M_ptr(__a.release()) {}

  auto_ptr& operator=(auto_ptr& __a) throw() {
    reset(__a.release());
    return *this;
  }

  template <class _Tp1>
  auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw() {
    reset(__a.release());
    return *this;
  }





  ~auto_ptr() { delete _M_ptr; }

  _Tp& operator*() const throw() {
    return *_M_ptr;
  }
  _Tp* operator->() const throw() {
    return _M_ptr;
  }
  _Tp* get() const throw() {
    return _M_ptr;
  }
  _Tp* release() throw() {
    _Tp* __tmp = _M_ptr;
    _M_ptr = 0;
    return __tmp;
  }
  void reset(_Tp* __p = 0) throw() {
    if (__p != _M_ptr) {
      delete _M_ptr;
      _M_ptr = __p;
    }
  }

public:
  auto_ptr(auto_ptr_ref<_Tp> __ref) throw()
    : _M_ptr(__ref._M_ptr) {}

  auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) throw() {
    if (__ref._M_ptr != this->get()) {
      delete _M_ptr;
      _M_ptr = __ref._M_ptr;
    }
    return *this;
  }

  template <class _Tp1> operator auto_ptr_ref<_Tp1>() throw()
    { return auto_ptr_ref<_Tp>(this->release()); }
  template <class _Tp1> operator auto_ptr<_Tp1>() throw()
    { return auto_ptr<_Tp1>(this->release()); }
};

}
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/string" 2 3



# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 1 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
namespace std
{
# 101 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Arg, class _Result>
struct unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};




template <class _Arg1, class _Arg2, class _Result>
struct binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};
# 127 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Tp>
struct plus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
};


template <class _Tp>
struct minus : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
};


template <class _Tp>
struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
};


template <class _Tp>
struct divides : public binary_function<_Tp,_Tp,_Tp> {
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
};


template <class _Tp>
struct modulus : public binary_function<_Tp,_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
};


template <class _Tp>
struct negate : public unary_function<_Tp,_Tp>
{
  _Tp operator()(const _Tp& __x) const { return -__x; }
};
# 173 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Tp>
struct equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
};


template <class _Tp>
struct not_equal_to : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
};


template <class _Tp>
struct greater : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
};


template <class _Tp>
struct less : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
};


template <class _Tp>
struct greater_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
};


template <class _Tp>
struct less_equal : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
};
# 222 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Tp>
struct logical_and : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
};


template <class _Tp>
struct logical_or : public binary_function<_Tp,_Tp,bool>
{
  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
};


template <class _Tp>
struct logical_not : public unary_function<_Tp,bool>
{
  bool operator()(const _Tp& __x) const { return !__x; }
};
# 271 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Predicate>
class unary_negate
  : public unary_function<typename _Predicate::argument_type, bool> {
protected:
  _Predicate _M_pred;
public:
  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::argument_type& __x) const {
    return !_M_pred(__x);
  }
};


template <class _Predicate>
inline unary_negate<_Predicate>
not1(const _Predicate& __pred)
{
  return unary_negate<_Predicate>(__pred);
}


template <class _Predicate>
class binary_negate
  : public binary_function<typename _Predicate::first_argument_type,
                           typename _Predicate::second_argument_type,
                           bool> {
protected:
  _Predicate _M_pred;
public:
  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
  bool operator()(const typename _Predicate::first_argument_type& __x,
                  const typename _Predicate::second_argument_type& __y) const
  {
    return !_M_pred(__x, __y);
  }
};


template <class _Predicate>
inline binary_negate<_Predicate>
not2(const _Predicate& __pred)
{
  return binary_negate<_Predicate>(__pred);
}
# 349 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Operation>
class binder1st
  : public unary_function<typename _Operation::second_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::first_argument_type value;
public:
  binder1st(const _Operation& __x,
            const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }


  typename _Operation::result_type
  operator()(typename _Operation::second_argument_type& __x) const {
    return op(value, __x);
  }

};


template <class _Operation, class _Tp>
inline binder1st<_Operation>
bind1st(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::first_argument_type _Arg1_type;
  return binder1st<_Operation>(__fn, _Arg1_type(__x));
}


template <class _Operation>
class binder2nd
  : public unary_function<typename _Operation::first_argument_type,
                          typename _Operation::result_type> {
protected:
  _Operation op;
  typename _Operation::second_argument_type value;
public:
  binder2nd(const _Operation& __x,
            const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) {}
  typename _Operation::result_type
  operator()(const typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }


  typename _Operation::result_type
  operator()(typename _Operation::first_argument_type& __x) const {
    return op(__x, value);
  }

};


template <class _Operation, class _Tp>
inline binder2nd<_Operation>
bind2nd(const _Operation& __fn, const _Tp& __x)
{
  typedef typename _Operation::second_argument_type _Arg2_type;
  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
}
# 438 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Arg, class _Result>
class pointer_to_unary_function : public unary_function<_Arg, _Result> {
protected:
  _Result (*_M_ptr)(_Arg);
public:
  pointer_to_unary_function() {}
  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
};


template <class _Arg, class _Result>
inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
{
  return pointer_to_unary_function<_Arg, _Result>(__x);
}


template <class _Arg1, class _Arg2, class _Result>
class pointer_to_binary_function :
  public binary_function<_Arg1,_Arg2,_Result> {
protected:
    _Result (*_M_ptr)(_Arg1, _Arg2);
public:
    pointer_to_binary_function() {}
    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) {}
    _Result operator()(_Arg1 __x, _Arg2 __y) const {
      return _M_ptr(__x, __y);
    }
};


template <class _Arg1, class _Arg2, class _Result>
inline pointer_to_binary_function<_Arg1,_Arg2,_Result>
ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);
}


template <class _Tp>
struct _Identity : public unary_function<_Tp,_Tp> {
  _Tp& operator()(_Tp& __x) const { return __x; }
  const _Tp& operator()(const _Tp& __x) const { return __x; }
};

template <class _Pair>
struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
  typename _Pair::first_type& operator()(_Pair& __x) const {
    return __x.first;
  }
  const typename _Pair::first_type& operator()(const _Pair& __x) const {
    return __x.first;
  }
};

template <class _Pair>
struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
{
  typename _Pair::second_type& operator()(_Pair& __x) const {
    return __x.second;
  }
  const typename _Pair::second_type& operator()(const _Pair& __x) const {
    return __x.second;
  }
};
# 528 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_function.h" 3
template <class _Ret, class _Tp>
class mem_fun_t : public unary_function<_Tp*,_Ret> {
public:
  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
public:
  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp>
class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)();
};


template <class _Ret, class _Tp>
class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
public:
  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
private:
  _Ret (_Tp::*_M_f)() const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
public:
  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
public:
  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp* __p, _Arg __x) const
    { return (__p->*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Ret, class _Tp, class _Arg>
class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg);
};


template <class _Ret, class _Tp, class _Arg>
class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
public:
  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
private:
  _Ret (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp>
class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {
public:
  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {
public:
  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp>
class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
  void operator()(_Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)();
};


template <class _Tp>
class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
public:
  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }
private:
  void (_Tp::*_M_f)() const;
};


template <class _Tp, class _Arg>
class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {
public:
  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_t<void, _Tp, _Arg>
  : public binary_function<const _Tp*,_Arg,void> {
public:
  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};


template <class _Tp, class _Arg>
class mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg);
};


template <class _Tp, class _Arg>
class const_mem_fun1_ref_t<void, _Tp, _Arg>
  : public binary_function<_Tp,_Arg,void> {
public:
  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
private:
  void (_Tp::*_M_f)(_Arg) const;
};





template <class _Ret, class _Tp>
inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())
  { return mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  { return mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp>
inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)
  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }

template <class _Ret, class _Tp, class _Arg>
inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }



}
# 53 "/usr/include/gcc/darwin/3.1/g++-v3/string" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/atomicity.h" 1 3
# 33 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/atomicity.h" 3
typedef int _Atomic_word;

static inline _Atomic_word
__attribute__ ((__unused__))
__exchange_and_add (volatile _Atomic_word* __mem, int __val)
{
  _Atomic_word __tmp, __res;
  __asm__ __volatile__ (
        "/* Inline exchange & add */\n"
        "0:\t"
        "lwarx    %0,0,%2 \n\t"
        "add%I3   %1,%0,%3 \n\t"
        "stwcx.   %1,0,%2 \n\t"
        "bne-     0b \n\t"
        "/* End exchange & add */"
        : "=&b"(__res), "=&r"(__tmp)
        : "r" (__mem), "Ir"(__val)
        : "cr0", "memory");
  return __res;
}

static inline void
__attribute__ ((__unused__))
__atomic_add (volatile _Atomic_word *__mem, int __val)
{
  _Atomic_word __tmp;
  __asm__ __volatile__ (
        "/* Inline atomic add */\n"
        "0:\t"
        "lwarx    %0,0,%1 \n\t"
        "add%I2   %0,%0,%2 \n\t"
        "stwcx.   %0,0,%1 \n\t"
        "bne-     0b \n\t"
        "/* End atomic add */"
        : "=&b"(__tmp)
        : "r" (__mem), "Ir"(__val)
        : "cr0", "memory");
}

static inline long
__attribute__ ((__unused__))
__always_swap (volatile long *__p, long int __newval)
{
  long __res;
  __asm__ __volatile__ (
        "/* Inline always swap */\n"
        "0:\t"
        "lwarx    %0,0,%1 \n\t"
        "stwcx.   %2,0,%1 \n\t"
        "bne-     0b \n\t"
        "/* End always swap */"
        : "=&r"(__res)
        : "r"(__p), "r"(__newval)
        : "cr0", "memory");
  return __res;
}

static inline int
__attribute__ ((__unused__))
__test_and_set (volatile long *__p, long int __newval)
{
  int __res;
  __asm__ __volatile__ (
        "/* Inline test & set */\n"
        "0:\t"
        "lwarx    %0,0,%1 \n\t"
        "cmpwi    %0,0 \n\t"
        "bne-     1f \n\t"
        "stwcx.   %2,0,%1 \n\t"
        "bne-     0b \n"
        "1:\n\t"
        "/* End test & set */"
        : "=&r"(__res)
        : "r"(__p), "r"(__newval)
        : "cr0", "memory");
  return __res;
}
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 2 3

namespace std
{
# 88 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {

    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _Alloc::size_type size_type;
      typedef typename _Alloc::difference_type difference_type;
      typedef typename _Alloc::reference reference;
      typedef typename _Alloc::const_reference const_reference;
      typedef typename _Alloc::pointer pointer;
      typedef typename _Alloc::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef reverse_iterator<const_iterator> const_reverse_iterator;
      typedef reverse_iterator<iterator> reverse_iterator;

    private:
# 123 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 3
      struct _Rep
      {

        typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 141 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.h" 3
        static const size_type _S_max_size;
        static const _CharT _S_terminal;

        size_type _M_length;
        size_type _M_capacity;
        _Atomic_word _M_references;

        bool
        _M_is_leaked() const
        { return _M_references < 0; }

        bool
        _M_is_shared() const
        { return _M_references > 0; }

        void
        _M_set_leaked()
        { _M_references = -1; }

        void
        _M_set_sharable()
        { _M_references = 0; }

        _CharT*
        _M_refdata() throw()
        { return reinterpret_cast<_CharT*>(this + 1); }

        _CharT&
        operator[](size_t __s) throw()
        { return _M_refdata() [__s]; }

        _CharT*
        _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
        {
          return (!_M_is_leaked() && __alloc1 == __alloc2)
                  ? _M_refcopy() : _M_clone(__alloc1);
        }


        static _Rep*
        _S_create(size_t, const _Alloc&);

        void
        _M_dispose(const _Alloc& __a)
        {
          if (__exchange_and_add(&_M_references, -1) <= 0)
            _M_destroy(__a);
        }

        void
        _M_destroy(const _Alloc&) throw();

        _CharT*
        _M_refcopy() throw()
        {
          __atomic_add(&_M_references, 1);
          return _M_refdata();
        }

        _CharT*
        _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
        _Alloc_hider(_CharT* __dat, const _Alloc& __a)
        : _Alloc(__a), _M_p(__dat) { }

        _CharT* _M_p;
      };

    public:



      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;



      static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const { return iterator(_M_data()); }

      iterator
      _M_iend() const { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
        if (!_M_rep()->_M_is_leaked())
          _M_leak_hard();
      }

      iterator
      _M_check(size_type __pos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::_M_check");
        return _M_ibegin() + __pos;
      }


      iterator
      _M_fold(size_type __pos, size_type __off) const
      {
        bool __testoff = __off < this->size() - __pos;
        size_type __newoff = __testoff ? __off : this->size() - __pos;
        return (_M_ibegin() + __pos + __newoff);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
          for (; __k1 != __k2; ++__k1, ++__p)
            traits_type::assign(*__p, *__k1);
        }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { traits_type::copy(__p, __k1, __k2 - __k1); }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }

    public:




      inline
      basic_string();

      explicit
      basic_string(const _Alloc& __a);


      basic_string(const basic_string& __str);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n = npos);
      basic_string(const basic_string& __str, size_type __pos,
                   size_type __n, const _Alloc& __a);

      basic_string(const _CharT* __s, size_type __n,
                   const _Alloc& __a = _Alloc());
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());

      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
                     const _Alloc& __a = _Alloc());

      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }

      basic_string&
      operator=(const basic_string& __str) { return this->assign(__str); }

      basic_string&
      operator=(const _CharT* __s) { return this->assign(__s); }

      basic_string&
      operator=(_CharT __c) { return this->assign(1, __c); }


      iterator
      begin()
      {
        _M_leak();
        return iterator(_M_data());
      }

      const_iterator
      begin() const
      { return const_iterator(_M_data()); }

      iterator
      end()
      {
         _M_leak();
         return iterator(_M_data() + this->size());
      }

      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }

      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }

      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }

      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }

      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }

    public:

      size_type
      size() const { return _M_rep()->_M_length; }

      size_type
      length() const { return _M_rep()->_M_length; }

      size_type
      max_size() const { return _Rep::_S_max_size; }

      void
      resize(size_type __n, _CharT __c);

      void
      resize(size_type __n) { this->resize(__n, _CharT()); }

      size_type
      capacity() const { return _M_rep()->_M_capacity; }

      void
      reserve(size_type __res_arg = 0);

      void
      clear() { _M_mutate(0, this->size(), 0); }

      bool
      empty() const { return this->size() == 0; }


      const_reference
      operator[] (size_type __pos) const
      { return _M_data()[__pos]; }

      reference
      operator[](size_type __pos)
      {
        _M_leak();
        return _M_data()[__pos];
      }

      const_reference
      at(size_type __n) const
      {
        if (__n >= this->size())
          __throw_out_of_range("basic_string::at");
        return _M_data()[__n];
      }

      reference
      at(size_type __n)
      {
        if (__n >= size())
          __throw_out_of_range("basic_string::at");
        _M_leak();
        return _M_data()[__n];
      }


      basic_string&
      operator+=(const basic_string& __str) { return this->append(__str); }

      basic_string&
      operator+=(const _CharT* __s) { return this->append(__s); }

      basic_string&
      operator+=(_CharT __c) { return this->append(size_type(1), __c); }

      basic_string&
      append(const basic_string& __str);

      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);

      basic_string&
      append(const _CharT* __s, size_type __n);

      basic_string&
      append(const _CharT* __s)
      { return this->append(__s, traits_type::length(__s)); }

      basic_string&
      append(size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }

      void
      push_back(_CharT __c)
      { this->replace(_M_iend(), _M_iend(), 1, __c); }

      basic_string&
      assign(const basic_string& __str);

      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      {
        const size_type __strsize = __str.size();
        if (__pos > __strsize)
          __throw_out_of_range("basic_string::assign");
        const bool __testn = __n < __strsize - __pos;
        const size_type __newsize = __testn ? __n : __strsize - __pos;
        return this->assign(__str._M_data() + __pos, __newsize);
      }

      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
        if (__n > this->max_size())
          __throw_length_error("basic_string::assign");
        if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
            || less<const _CharT*>()(_M_data() + this->size(), __s))
          return _M_replace_safe(_M_ibegin(), _M_iend(), __s, __s + __n);
        else
          {

            const size_type __pos = __s - _M_data();
            if (__pos >= __n)
              traits_type::copy(_M_data(), __s, __n);
            else if (__pos)
              traits_type::move(_M_data(), __s, __n);
            _M_rep()->_M_length = __n;
            _M_data()[__n] = _Rep::_S_terminal;
            return *this;
          }
      }

      basic_string&
      assign(const _CharT* __s)
      { return this->assign(__s, traits_type::length(__s)); }

      basic_string&
      assign(size_type __n, _CharT __c)
      { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }

      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }

      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }

      template<class _InputIterator>
        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, 0, __str.size()); }

      basic_string&
      insert(size_type __pos1, const basic_string& __str,
             size_type __pos2, size_type __n)
      {
        const size_type __strsize = __str.size();
        if (__pos2 > __strsize)
          __throw_out_of_range("basic_string::insert");
        const bool __testn = __n < __strsize - __pos2;
        const size_type __newsize = __testn ? __n : __strsize - __pos2;
        return this->insert(__pos1, __str._M_data() + __pos2, __newsize);
      }

      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      {
        const size_type __size = this->size();
        if (__pos > __size)
          __throw_out_of_range("basic_string::insert");
        if (__size > this->max_size() - __n)
          __throw_length_error("basic_string::insert");
        if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
            || less<const _CharT*>()(_M_data() + __size, __s))
          return _M_replace_safe(_M_ibegin() + __pos, _M_ibegin() + __pos,
                                 __s, __s + __n);
        else
          {



            const size_type __off = __s - _M_data();
            _M_mutate(__pos, 0, __n);
            __s = _M_data() + __off;
            _CharT* __p = _M_data() + __pos;
            if (__s + __n <= __p)
              traits_type::copy(__p, __s, __n);
            else if (__s >= __p)
              traits_type::copy(__p, __s + __n, __n);
            else
              {
                traits_type::copy(__p, __s, __p - __s);
                traits_type::copy(__p + (__p - __s), __p + __n, __n - (__p - __s));
              }
            return *this;
          }
       }

      basic_string&
      insert(size_type __pos, const _CharT* __s)
      { return this->insert(__pos, __s, traits_type::length(__s)); }

      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      {
        this->insert(_M_check(__pos), __n, __c);
        return *this;
      }

      iterator
      insert(iterator __p, _CharT __c = _CharT())
      {
        size_type __pos = __p - _M_ibegin();
        this->insert(_M_check(__pos), size_type(1), __c);
        _M_rep()->_M_set_leaked();
        return this->_M_ibegin() + __pos;
      }

      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
        return this->replace(_M_check(__pos), _M_fold(__pos, __n),
                             _M_data(), _M_data());
      }

      iterator
      erase(iterator __position)
      {
        size_type __i = __position - _M_ibegin();
        this->replace(__position, __position + 1, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
        return _M_ibegin() + __i;
      }

      iterator
      erase(iterator __first, iterator __last)
      {
        size_type __i = __first - _M_ibegin();
        this->replace(__first, __last, _M_data(), _M_data());
        _M_rep()->_M_set_leaked();
       return _M_ibegin() + __i;
      }

      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }

      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2);

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2)
      {
        const size_type __size = this->size();
        if (__pos > __size)
          __throw_out_of_range("basic_string::replace");
        if (__size - __n1 > this->max_size() - __n2)
          __throw_length_error("basic_string::replace");
        const bool __testn1 = __n1 < __size - __pos;
        const size_type __foldn1 = __testn1 ? __n1 : __size - __pos;
        if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())
            || less<const _CharT*>()(_M_data() + __size, __s))
          return _M_replace_safe(_M_ibegin() + __pos,
                                 _M_ibegin() + __pos + __foldn1, __s, __s + __n2);
        else return this->replace(_M_check(__pos), _M_fold(__pos, __n1),
                                  __s, __s + __n2);
      }

      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }

      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c); }

      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }

      basic_string&
      replace(iterator __i1, iterator __i2,
                           const _CharT* __s, size_type __n)
      { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }

      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }

      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);

      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
                _InputIterator __k1, _InputIterator __k2)
        { return _M_replace(__i1, __i2, __k1, __k2,
             typename iterator_traits<_InputIterator>::iterator_category()); }

    private:
      template<class _InputIterator>
        basic_string&
        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1,
                   _InputIterator __k2, input_iterator_tag);

      template<class _ForwardIterator>
        basic_string&
        _M_replace_safe(iterator __i1, iterator __i2, _ForwardIterator __k1,
                   _ForwardIterator __k2);



      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __false_type)
        {
          typedef typename iterator_traits<_InIter>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
        }

      template<class _InIter>
        static _CharT*
        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,
                         __true_type)
        {
          return _S_construct(static_cast<size_type>(__beg),
                              static_cast<value_type>(__end), __a);
        }

      template<class _InIter>
        static _CharT*
        _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)
        {
          typedef typename _Is_integer<_InIter>::_Integral _Integral;
          return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIter>
        static _CharT*
         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                      input_iterator_tag);



      template<class _FwdIter>
        static _CharT*
        _S_construct(_FwdIter __beg, _FwdIter __end, const _Alloc& __a,
                     forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:

      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;

      void
      swap(basic_string<_CharT, _Traits, _Alloc>& __s);


      const _CharT*
      c_str() const
      {

        size_type __n = this->size();
        traits_type::assign(_M_data()[__n], _Rep::_S_terminal);
        return _M_data();
      }

      const _CharT*
      data() const { return _M_data(); }

      allocator_type
      get_allocator() const { return _M_dataplus; }

      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }

      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      { return this->find(__s, __pos, traits_type::length(__s)); }

      size_type
      find(_CharT __c, size_type __pos = 0) const;

      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }

      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      { return this->rfind(__s, __pos, traits_type::length(__s)); }

      size_type
      rfind(_CharT __c, size_type __pos = npos) const;

      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }

      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;

      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }

      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
                        size_type __n) const;

      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;

      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }

      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
                       size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }

      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;

      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      {
        if (__pos > this->size())
          __throw_out_of_range("basic_string::substr");
        return basic_string(*this, __pos, __n);
      }

      int
      compare(const basic_string& __str) const
      {
        size_type __size = this->size();
        size_type __osize = __str.size();
        size_type __len = min(__size, __osize);

        int __r = traits_type::compare(_M_data(), __str.data(), __len);
        if (!__r)
          __r = __size - __osize;
        return __r;
      }

      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;

      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
              size_type __pos2, size_type __n2) const;

      int
      compare(const _CharT* __s) const;



      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;

      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
              size_type __n2) const;
  };


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>::
    basic_string()
    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
             const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) != 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) != 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
              const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
  { return __rhs.compare(__lhs) >= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
               const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
             const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
         basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
               basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
               const basic_string<_CharT, _Traits, _Alloc>& __str);

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Alloc>& __str);
}
# 54 "/usr/include/gcc/darwin/3.1/g++-v3/string" 2 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/algorithm" 1 3
# 65 "/usr/include/gcc/darwin/3.1/g++-v3/algorithm" 3




# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 1 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_heap.h" 1 3
# 63 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_heap.h" 3
namespace std
{



  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
                _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
            typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {
        *(__first + __holeIndex) = *(__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
      }
      *(__first + __holeIndex) = __value;
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0),
                  _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value);
    }

  template<typename _RandomAccessIterator, typename _Tp>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);
    }

  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;


     

     

      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));
    }

  template<typename _RandomAccessIterator, typename _Distance,
           typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                  _Distance __len, _Tp __value, _Compare __comp)
    {
      _Distance __topIndex = __holeIndex;
      _Distance __secondChild = 2 * __holeIndex + 2;
      while (__secondChild < __len) {
        if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
          __secondChild--;
        *(__first + __holeIndex) = *(__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
      }
      if (__secondChild == __len) {
        *(__first + __holeIndex) = *(__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
      }
      __push_heap(__first, __holeIndex, __topIndex, __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
               _RandomAccessIterator __result, _Tp __value, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;
      *__result = *__first;
      __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                    __value, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
             _RandomAccessIterator __last, _Compare __comp)
    {

     


      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;
      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);
    }

  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     

     

      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len, _ValueType(*(__first + __parent)));
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
          _DistanceType;


     


      if (__last - __first < 2) return;
      _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2)/2;

      while (true) {
        __adjust_heap(__first, __parent, __len,
                      _ValueType(*(__first + __parent)), __comp);
        if (__parent == 0) return;
        __parent--;
      }
    }

  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     


      while (__last - __first > 1)
        pop_heap(__first, __last--);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
              _Compare __comp)
    {

     


      while (__last - __first > 1)
        pop_heap(__first, __last--, __comp);
    }

}
# 65 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_tempbuf.h" 1 3
# 64 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_tempbuf.h" 3
namespace std
{
# 74 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_tempbuf.h" 3
template <class _ForwardIterator, class _Tp>
  class _Temporary_buffer
{

 

  ptrdiff_t _M_original_len;
  ptrdiff_t _M_len;
  _Tp* _M_buffer;


  void _M_allocate_buffer() {
    _M_original_len = _M_len;
    _M_buffer = 0;

    if (_M_len > (ptrdiff_t)(2147483647 / sizeof(_Tp)))
      _M_len = 2147483647 / sizeof(_Tp);

    while (_M_len > 0) {
      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
      if (_M_buffer)
        break;
      _M_len /= 2;
    }
  }

  void _M_initialize_buffer(const _Tp&, __true_type) {}
  void _M_initialize_buffer(const _Tp& val, __false_type) {
    uninitialized_fill_n(_M_buffer, _M_len, val);
  }

public:

  ptrdiff_t size() const { return _M_len; }

  ptrdiff_t requested_size() const { return _M_original_len; }

  _Tp* begin() { return _M_buffer; }

  _Tp* end() { return _M_buffer + _M_len; }

  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {

    typedef typename __type_traits<_Tp>::has_trivial_default_constructor
            _Trivial;

    try {
      _M_len = distance(__first, __last);
      _M_allocate_buffer();
      if (_M_len > 0)
        _M_initialize_buffer(*__first, _Trivial());
    }
    catch(...)
      {
        free(_M_buffer);
        _M_buffer = 0;
        _M_len = 0;
        throw;
      }
  }

  ~_Temporary_buffer() {
    _Destroy(_M_buffer, _M_buffer + _M_len);
    free(_M_buffer);
  }

private:

  _Temporary_buffer(const _Temporary_buffer&) {}
  void operator=(const _Temporary_buffer&) {}
};

}
# 66 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 2 3



namespace std
{
# 84 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _Tp>
  inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)
    {

     
      if (__a < __b)
        if (__b < __c)
          return __b;
        else if (__a < __c)
          return __c;
        else
          return __a;
      else if (__a < __c)
        return __a;
      else if (__b < __c)
        return __c;
      else
        return __b;
    }
# 118 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)
    {

     
      if (__comp(__a, __b))
        if (__comp(__b, __c))
          return __b;
        else if (__comp(__a, __c))
          return __c;
        else
          return __a;
      else if (__comp(__a, __c))
        return __a;
      else if (__comp(__b, __c))
        return __c;
      else
        return __b;
    }
# 150 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Function>
    _Function
    for_each(_InputIter __first, _InputIter __last, _Function __f)
    {

     
      for ( ; __first != __last; ++__first)
        __f(*__first);
      return __f;
    }






  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val,
         input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
        ++__first;
      return __first;
    }






  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred,
            input_iterator_tag)
    {
      while (__first != __last && !__pred(*__first))
        ++__first;
      return __first;
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    find(_RandomAccessIter __first, _RandomAccessIter __last,
         const _Tp& __val,
         random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;

        if (*__first == __val) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (*__first == __val) return __first;
        ++__first;
      case 2:
        if (*__first == __val) return __first;
        ++__first;
      case 1:
        if (*__first == __val) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }






  template<typename _RandomAccessIter, typename _Predicate>
    _RandomAccessIter
    find_if(_RandomAccessIter __first, _RandomAccessIter __last,
            _Predicate __pred,
            random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
        = (__last - __first) >> 2;

      for ( ; __trip_count > 0 ; --__trip_count) {
        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;

        if (__pred(*__first)) return __first;
        ++__first;
      }

      switch(__last - __first) {
      case 3:
        if (__pred(*__first)) return __first;
        ++__first;
      case 2:
        if (__pred(*__first)) return __first;
        ++__first;
      case 1:
        if (__pred(*__first)) return __first;
        ++__first;
      case 0:
      default:
        return __last;
      }
    }
# 289 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    inline _InputIter
    find(_InputIter __first, _InputIter __last,
         const _Tp& __val)
    {

     
     

      return find(__first, __last, __val, __iterator_category(__first));
    }
# 309 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    inline _InputIter
    find_if(_InputIter __first, _InputIter __last,
            _Predicate __pred)
    {

     
     

      return find_if(__first, __last, __pred, __iterator_category(__first));
    }
# 329 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last)
    {

     
     

      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (*__first == *__next)
          return __first;
        __first = __next;
      }
      return __last;
    }
# 358 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    adjacent_find(_ForwardIter __first, _ForwardIter __last,
                  _BinaryPredicate __binary_pred)
    {

     
     


      if (__first == __last)
        return __last;
      _ForwardIter __next = __first;
      while(++__next != __last) {
        if (__binary_pred(*__first, *__next))
          return __first;
        __first = __next;
      }
      return __last;
    }
# 387 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Tp>
    typename iterator_traits<_InputIter>::difference_type
    count(_InputIter __first, _InputIter __last, const _Tp& __value)
    {

     
     

     
      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (*__first == __value)
          ++__n;
      return __n;
    }
# 411 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _Predicate>
    typename iterator_traits<_InputIter>::difference_type
    count_if(_InputIter __first, _InputIter __last, _Predicate __pred)
    {

     
     

      typename iterator_traits<_InputIter>::difference_type __n = 0;
      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          ++__n;
      return __n;
    }
# 450 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2)
        return find(__first1, __last1, *__first2);



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        __first1 = find(__first1, __last1, *__first2);
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1)
          return __last1;

        while (*__current == *__p) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 522 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2, typename _BinaryPred>
    _ForwardIter1
    search(_ForwardIter1 __first1, _ForwardIter1 __last1,
           _ForwardIter2 __first2, _ForwardIter2 __last2,
           _BinaryPred __predicate)
    {

     
     
     




      if (__first1 == __last1 || __first2 == __last2)
        return __first1;


      _ForwardIter2 __tmp(__first2);
      ++__tmp;
      if (__tmp == __last2) {
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        return __first1;
      }



      _ForwardIter2 __p1, __p;

      __p1 = __first2; ++__p1;

      _ForwardIter1 __current = __first1;

      while (__first1 != __last1) {
        while (__first1 != __last1) {
          if (__predicate(*__first1, *__first2))
            break;
          ++__first1;
        }
        while (__first1 != __last1 && !__predicate(*__first1, *__first2))
          ++__first1;
        if (__first1 == __last1)
          return __last1;

        __p = __p1;
        __current = __first1;
        if (++__current == __last1) return __last1;

        while (__predicate(*__current, *__p)) {
          if (++__p == __last2)
            return __first1;
          if (++__current == __last1)
            return __last1;
        }

        ++__first1;
      }
      return __first1;
    }
# 596 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val)
    {

     
     

     

      if (__count <= 0)
        return __first;
      else {
        __first = find(__first, __last, __val);
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && *__i == __val) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else
            __first = find(__i, __last, __val);
        }
        return __last;
      }
    }
# 643 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Integer, typename _Tp,
           typename _BinaryPred>
    _ForwardIter
    search_n(_ForwardIter __first, _ForwardIter __last,
             _Integer __count, const _Tp& __val,
             _BinaryPred __binary_pred)
    {

     
     


      if (__count <= 0)
        return __first;
      else {
        while (__first != __last) {
          if (__binary_pred(*__first, __val))
            break;
          ++__first;
        }
        while (__first != __last) {
          _Integer __n = __count - 1;
          _ForwardIter __i = __first;
          ++__i;
          while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
            ++__i;
            --__n;
          }
          if (__n == 0)
            return __first;
          else {
            while (__i != __last) {
              if (__binary_pred(*__i, __val))
                break;
              ++__i;
            }
            __first = __i;
          }
        }
        return __last;
      }
    }
# 697 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter2
    swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,
                _ForwardIter2 __first2)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1, ++__first2)
        iter_swap(__first1, __first2);
      return __first2;
    }
# 732 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _UnaryOperation>
    _OutputIter
    transform(_InputIter __first, _InputIter __last,
              _OutputIter __result, _UnaryOperation __unary_op)
    {

     
     



      for ( ; __first != __last; ++__first, ++__result)
        *__result = __unary_op(*__first);
      return __result;
    }
# 765 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _BinaryOperation>
    _OutputIter
    transform(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _OutputIter __result,
              _BinaryOperation __binary_op)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 796 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    void
    replace(_ForwardIter __first, _ForwardIter __last,
            const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (*__first == __old_value)
          *__first = __new_value;
    }
# 825 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIter __first, _ForwardIter __last,
               _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (__pred(*__first))
          *__first = __new_value;
    }
# 856 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    replace_copy(_InputIter __first, _InputIter __last,
                 _OutputIter __result,
                 const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
    }
# 888 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate,
           typename _Tp>
    _OutputIter
    replace_copy_if(_InputIter __first, _InputIter __last,
                    _OutputIter __result,
                    _Predicate __pred, const _Tp& __new_value)
    {

     
     

     


      for ( ; __first != __last; ++__first, ++__result)
        *__result = __pred(*__first) ? __new_value : *__first;
      return __result;
    }
# 918 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Generator>
    void
    generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen)
    {

     
     


      for ( ; __first != __last; ++__first)
        *__first = __gen();
    }
# 942 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _OutputIter, typename _Size, typename _Generator>
    _OutputIter
    generate_n(_OutputIter __first, _Size __n, _Generator __gen)
    {

     



      for ( ; __n > 0; --__n, ++__first)
        *__first = __gen();
      return __first;
    }
# 969 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Tp>
    _OutputIter
    remove_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result, const _Tp& __value)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!(*__first == __value)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1003 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _Predicate>
    _OutputIter
    remove_copy_if(_InputIter __first, _InputIter __last,
                   _OutputIter __result, _Predicate __pred)
    {

     
     

     


      for ( ; __first != __last; ++__first)
        if (!__pred(*__first)) {
          *__result = *__first;
          ++__result;
        }
      return __result;
    }
# 1039 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    remove(_ForwardIter __first, _ForwardIter __last,
           const _Tp& __value)
    {

     
     

     


      __first = find(__first, __last, __value);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy(++__i, __last, __first, __value);
    }
# 1073 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    remove_if(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      __first = find_if(__first, __last, __pred);
      _ForwardIter __i = __first;
      return __first == __last ? __first
                               : remove_copy_if(++__i, __last, __first, __pred);
    }







  template<typename _InputIter, typename _OutputIter>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  output_iterator_tag)
    {

      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!(__value == *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }







  template<typename _InputIter, typename _ForwardIter>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  forward_iterator_tag)
    {

      *__result = *__first;
      while (++__first != __last)
        if (!(*__result == *__first))
          *++__result = *__first;
      return ++__result;
    }
# 1145 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result)
    {

     
     

     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last, __result, _IterType());
    }
# 1170 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    _OutputIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _OutputIter __result,
                  _BinaryPredicate __binary_pred,
                  output_iterator_tag)
    {

     



      typename iterator_traits<_InputIter>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
        if (!__binary_pred(__value, *__first)) {
          __value = *__first;
          *++__result = __value;
        }
      return ++__result;
    }
# 1199 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    __unique_copy(_InputIter __first, _InputIter __last,
                  _ForwardIter __result,
                  _BinaryPredicate __binary_pred,
                  forward_iterator_tag)
    {

     



      *__result = *__first;
      while (++__first != __last)
        if (!__binary_pred(*__result, *__first)) *++__result = *__first;
      return ++__result;
    }
# 1232 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _OutputIter, typename _BinaryPredicate>
    inline _OutputIter
    unique_copy(_InputIter __first, _InputIter __last,
                _OutputIter __result,
                _BinaryPredicate __binary_pred)
    {

     
     


      typedef typename iterator_traits<_OutputIter>::iterator_category _IterType;

      if (__first == __last) return __result;
      return __unique_copy(__first, __last,
__result, __binary_pred, _IterType());
    }
# 1263 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last)
    {

         
         


          __first = adjacent_find(__first, __last);
          return unique_copy(__first, __last, __first);
    }
# 1290 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _BinaryPredicate>
    _ForwardIter
    unique(_ForwardIter __first, _ForwardIter __last,
           _BinaryPredicate __binary_pred)
    {

     
     



      __first = adjacent_find(__first, __last, __binary_pred);
      return unique_copy(__first, __last, __first, __binary_pred);
    }







  template<typename _BidirectionalIter>
    void
    __reverse(_BidirectionalIter __first, _BidirectionalIter __last,
                          bidirectional_iterator_tag)
    {
          while (true)
            if (__first == __last || __first == --__last)
                  return;
            else
                  iter_swap(__first++, __last);
    }







  template<typename _RandomAccessIter>
    void
    __reverse(_RandomAccessIter __first, _RandomAccessIter __last,
                          random_access_iterator_tag)
    {
          while (__first < __last)
            iter_swap(__first++, --__last);
    }
# 1349 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    inline void
    reverse(_BidirectionalIter __first, _BidirectionalIter __last)
    {

         

          __reverse(__first, __last, __iterator_category(__first));
    }
# 1374 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _OutputIter>
    _OutputIter
    reverse_copy(_BidirectionalIter __first, _BidirectionalIter __last,
                             _OutputIter __result)
    {

     
     


      while (__first != __last) {
        --__last;
        *__result = *__last;
        ++__result;
      }
      return __result;
    }
# 1399 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0) {
        _EuclideanRingElement __t = __m % __n;
        __m = __n;
        __n = __t;
      }
      return __m;
    }






  template<typename _ForwardIter>
    void
    __rotate(_ForwardIter __first,
             _ForwardIter __middle,
             _ForwardIter __last,
              forward_iterator_tag)
    {
      if ((__first == __middle) || (__last == __middle))
        return;

      _ForwardIter __first2 = __middle;
      do {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
      } while (__first2 != __last);

      __first2 = __middle;

      while (__first2 != __last) {
        swap(*__first++, *__first2++);
        if (__first == __middle)
          __middle = __first2;
        else if (__first2 == __last)
          __first2 = __middle;
      }
    }






  template<typename _BidirectionalIter>
    void
    __rotate(_BidirectionalIter __first,
             _BidirectionalIter __middle,
             _BidirectionalIter __last,
              bidirectional_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      __reverse(__first, __middle, bidirectional_iterator_tag());
      __reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
        swap (*__first++, *--__last);

      if (__first == __middle) {
        __reverse(__middle, __last, bidirectional_iterator_tag());
      }
      else {
        __reverse(__first, __middle, bidirectional_iterator_tag());
      }
    }






  template<typename _RandomAccessIter>
    void
    __rotate(_RandomAccessIter __first,
             _RandomAccessIter __middle,
             _RandomAccessIter __last,
             random_access_iterator_tag)
    {

     


      if ((__first == __middle) || (__last == __middle))
        return;

      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;
      _Distance __l = __n - __k;

      if (__k == __l) {
        swap_ranges(__first, __middle, __middle);
        return;
      }

      _Distance __d = __gcd(__n, __k);

      for (_Distance __i = 0; __i < __d; __i++) {
        _ValueType __tmp = *__first;
        _RandomAccessIter __p = __first;

        if (__k < __l) {
          for (_Distance __j = 0; __j < __l/__d; __j++) {
            if (__p > __first + __l) {
              *__p = *(__p - __l);
              __p -= __l;
            }

            *__p = *(__p + __k);
            __p += __k;
          }
        }

        else {
          for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
            if (__p < __last - __k) {
              *__p = *(__p + __k);
              __p += __k;
            }

            *__p = * (__p - __l);
            __p -= __l;
          }
        }

        *__p = __tmp;
        ++__first;
      }
    }
# 1561 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter>
    inline void
    rotate(_ForwardIter __first, _ForwardIter __middle, _ForwardIter __last)
    {

     

      typedef typename iterator_traits<_ForwardIter>::iterator_category _IterType;
      __rotate(__first, __middle, __last, _IterType());
    }
# 1589 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _OutputIter>
    _OutputIter
    rotate_copy(_ForwardIter __first, _ForwardIter __middle,
                _ForwardIter __last, _OutputIter __result)
    {

     
     


      return copy(__first, __middle, copy(__middle, __last, __result));
    }
# 1612 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _Distance>
    inline _Distance
    __random_number(_Distance __n)
    {

      return lrand48() % __n;



    }
# 1634 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __random_number((__i - __first) + 1));
    }
# 1660 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
                   _RandomNumberGenerator& __rand)
    {

     


      if (__first == __last) return;
      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
        iter_swap(__i, __first + __rand((__i - __first) + 1));
    }







  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    __partition(_ForwardIter __first, _ForwardIter __last,
                _Predicate __pred,
                forward_iterator_tag)
    {
      if (__first == __last) return __first;

      while (__pred(*__first))
        if (++__first == __last) return __first;

      _ForwardIter __next = __first;

      while (++__next != __last)
        if (__pred(*__next)) {
          swap(*__first, *__next);
          ++__first;
        }

      return __first;
    }






  template<typename _BidirectionalIter, typename _Predicate>
    _BidirectionalIter
    __partition(_BidirectionalIter __first, _BidirectionalIter __last,
                _Predicate __pred,
                bidirectional_iterator_tag)
    {
      while (true) {
        while (true)
          if (__first == __last)
            return __first;
          else if (__pred(*__first))
            ++__first;
          else
            break;
        --__last;
        while (true)
          if (__first == __last)
            return __first;
          else if (!__pred(*__last))
            --__last;
          else
            break;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1748 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    inline _ForwardIter
    partition(_ForwardIter __first, _ForwardIter __last,
              _Predicate __pred)
    {

     
     


      return __partition(__first, __last, __pred, __iterator_category(__first));
    }







  template<typename _ForwardIter, typename _Predicate, typename _Distance>
    _ForwardIter
    __inplace_stable_partition(_ForwardIter __first, _ForwardIter __last,
                               _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
        return __pred(*__first) ? __last : __first;
      _ForwardIter __middle = __first;
      advance(__middle, __len / 2);
      _ForwardIter __begin = __inplace_stable_partition(__first, __middle,
                                                        __pred,
                                                        __len / 2);
      _ForwardIter __end = __inplace_stable_partition(__middle, __last,
                                                      __pred,
                                                      __len - __len / 2);
      rotate(__begin, __middle, __end);
      advance(__begin, distance(__middle, __end));
      return __begin;
    }






  template<typename _ForwardIter, typename _Pointer, typename _Predicate,
           typename _Distance>
    _ForwardIter
    __stable_partition_adaptive(_ForwardIter __first, _ForwardIter __last,
                                _Predicate __pred, _Distance __len,
                                _Pointer __buffer,
                                _Distance __buffer_size)
    {
      if (__len <= __buffer_size) {
        _ForwardIter __result1 = __first;
        _Pointer __result2 = __buffer;
        for ( ; __first != __last ; ++__first)
          if (__pred(*__first)) {
            *__result1 = *__first;
            ++__result1;
          }
          else {
            *__result2 = *__first;
            ++__result2;
          }
        copy(__buffer, __result2, __result1);
        return __result1;
      }
      else {
        _ForwardIter __middle = __first;
        advance(__middle, __len / 2);
        _ForwardIter __begin = __stable_partition_adaptive(__first, __middle,
                                                           __pred,
                                                           __len / 2,
                                                           __buffer, __buffer_size);
        _ForwardIter __end = __stable_partition_adaptive( __middle, __last,
                                                          __pred,
                                                          __len - __len / 2,
                                                          __buffer, __buffer_size);
        rotate(__begin, __middle, __end);
        advance(__begin, distance(__middle, __end));
        return __begin;
      }
    }
# 1848 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Predicate>
    _ForwardIter
    stable_partition(_ForwardIter __first, _ForwardIter __last,
                     _Predicate __pred)
    {

     
     


      if (__first == __last)
        return __first;
      else
      {
        typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
        typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;

        _Temporary_buffer<_ForwardIter, _ValueType> __buf(__first, __last);
        if (__buf.size() > 0)
          return __stable_partition_adaptive(__first, __last, __pred,
                                             _DistanceType(__buf.requested_size()),
                                             __buf.begin(), __buf.size());
        else
          return __inplace_stable_partition(__first, __last, __pred,
                                            _DistanceType(__buf.requested_size()));
      }
    }






  template<typename _RandomAccessIter, typename _Tp>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot)
    {
      while (true) {
        while (*__first < __pivot)
          ++__first;
        --__last;
        while (__pivot < *__last)
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    _RandomAccessIter
    __unguarded_partition(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Tp __pivot, _Compare __comp)
    {
      while (true) {
        while (__comp(*__first, __pivot))
          ++__first;
        --__last;
        while (__comp(__pivot, *__last))
          --__last;
        if (!(__first < __last))
          return __first;
        iter_swap(__first, __last);
        ++__first;
      }
    }
# 1929 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  enum { _M_threshold = 16 };






  template<typename _RandomAccessIter, typename _Tp>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__val < *__next) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter, typename _Tp, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, _Compare __comp)
    {
      _RandomAccessIter __next = __last;
      --__next;
      while (__comp(__val, *__next)) {
        *__last = *__next;
        __last = __next;
        --__next;
      }
      *__last = __val;
    }






  template<typename _RandomAccessIter>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__val < *__first) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val);
      }
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
      {
        typename iterator_traits<_RandomAccessIter>::value_type __val = *__i;
        if (__comp(__val, *__first)) {
          copy_backward(__first, __i, __i + 1);
          *__first = __val;
        }
        else
          __unguarded_linear_insert(__i, __val, __comp);
      }
    }






  template<typename _RandomAccessIter>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i));
    }






  template<typename _RandomAccessIter, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                               _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert(__i, _ValueType(*__i), __comp);
    }






  template<typename _RandomAccessIter>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold);
        __unguarded_insertion_sort(__first + _M_threshold, __last);
      }
      else
        __insertion_sort(__first, __last);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Compare __comp)
    {
      if (__last - __first > _M_threshold) {
        __insertion_sort(__first, __first + _M_threshold, __comp);
        __unguarded_insertion_sort(__first + _M_threshold, __last, __comp);
      }
      else
        __insertion_sort(__first, __last, __comp);
    }






  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 1; __n >>= 1) ++__k;
      return __k;
    }






  template<typename _RandomAccessIter, typename _Size>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        __introsort_loop(__cut, __last, __depth_limit);
        __last = __cut;
      }
    }






  template<typename _RandomAccessIter, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIter __first, _RandomAccessIter __last,
                     _Size __depth_limit, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;

      while (__last - __first > _M_threshold) {
        if (__depth_limit == 0) {
          partial_sort(__first, __last, __last, __comp);
          return;
        }
        --__depth_limit;
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1), __comp)),
           __comp);
        __introsort_loop(__cut, __last, __depth_limit, __comp);
        __last = __cut;
      }
    }
# 2166 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2);
        __final_insertion_sort(__first, __last);
      }
    }
# 2197 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      if (__first != __last) {
        __introsort_loop(__first, __last, __lg(__last - __first) * 2, __comp);
        __final_insertion_sort(__first, __last, __comp);
      }
    }







  template<typename _RandomAccessIter>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle);
      __inplace_stable_sort(__middle, __last);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle);
    }






  template<typename _RandomAccessIter, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                          _Compare __comp)
    {
      if (__last - __first < 15) {
        __insertion_sort(__first, __last, __comp);
        return;
      }
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle, __comp);
      __inplace_stable_sort(__middle, __last, __comp);
      __merge_without_buffer(__first, __middle, __last,
                             __middle - __first,
                             __last - __middle,
                             __comp);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result);
        __first += __two_step;
      }

      __step_size = min(_Distance(__last - __first), __step_size);
      merge(__first, __first + __step_size, __first + __step_size, __last,
            __result);
    }

  template<typename _RandomAccessIter1, typename _RandomAccessIter2,
           typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIter1 __first, _RandomAccessIter1 __last,
                      _RandomAccessIter2 __result, _Distance __step_size,
                      _Compare __comp)
    {
      _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step) {
        __result = merge(__first, __first + __step_size,
                         __first + __step_size, __first + __two_step,
                         __result,
                         __comp);
        __first += __two_step;
      }
      __step_size = min(_Distance(__last - __first), __step_size);

      merge(__first, __first + __step_size,
            __first + __step_size, __last,
            __result,
            __comp);
    }

  enum { _M_chunk_size = 7 };

  template<typename _RandomAccessIter, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last);
    }

  template<typename _RandomAccessIter, typename _Distance, typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size) {
        __insertion_sort(__first, __first + __chunk_size, __comp);
        __first += __chunk_size;
      }
      __insertion_sort(__first, __last, __comp);
    }

  template<typename _RandomAccessIter, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIter __first, _RandomAccessIter __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _Distance;

      _Distance __len = __last - __first;
      _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _M_chunk_size;
      __chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len) {
        __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
        __step_size *= 2;
        __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
        __step_size *= 2;
      }
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer);
        __merge_sort_with_buffer(__middle, __last, __buffer);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size);
    }

  template<typename _RandomAccessIter, typename _Pointer, typename _Distance,
           typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIter __first, _RandomAccessIter __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      _Distance __len = (__last - __first + 1) / 2;
      _RandomAccessIter __middle = __first + __len;
      if (__len > __buffer_size) {
        __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size,
                               __comp);
        __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size,
                               __comp);
      }
      else {
        __merge_sort_with_buffer(__first, __middle, __buffer, __comp);
        __merge_sort_with_buffer(__middle, __last, __buffer, __comp);
      }
      __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first),
                       _Distance(__last - __middle), __buffer, __buffer_size,
                       __comp);
    }
# 2430 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     

      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()));
    }
# 2466 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    inline void
    stable_sort(_RandomAccessIter __first, _RandomAccessIter __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     

     


      _Temporary_buffer<_RandomAccessIter, _ValueType> buf(__first, __last);
      if (buf.begin() == 0)
        __inplace_stable_sort(__first, __last, __comp);
      else
        __stable_sort_adaptive(__first, __last, buf.begin(), _DistanceType(buf.size()),
                               __comp);
    }
# 2502 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     

      make_heap(__first, __middle);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (*__i < *__first)
          __pop_heap(__first, __middle, __i, _ValueType(*__i));
      sort_heap(__first, __middle);
    }
# 2540 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    partial_sort(_RandomAccessIter __first,
                 _RandomAccessIter __middle,
                 _RandomAccessIter __last,
                 _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     

     


      make_heap(__first, __middle, __comp);
      for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (__comp(*__i, *__first))
          __pop_heap(__first, __middle, __i, _ValueType(*__i), __comp);
      sort_heap(__first, __middle, __comp);
    }
# 2579 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     

      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last);
      while (__first != __last) {
        if (*__first < *__result_first)
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first));
        ++__first;
      }
      sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
# 2633 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter, typename _RandomAccessIter, typename _Compare>
    _RandomAccessIter
    partial_sort_copy(_InputIter __first, _InputIter __last,
                      _RandomAccessIter __result_first,
                      _RandomAccessIter __result_last,
                      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIter>::value_type _InputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::value_type _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIter>::difference_type _DistanceType;


     
     
     
     


      if (__result_first == __result_last) return __result_last;
      _RandomAccessIter __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last) {
        *__result_real_last = *__first;
        ++__result_real_last;
        ++__first;
      }
      make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last) {
        if (__comp(*__first, *__result_first))
          __adjust_heap(__result_first, _DistanceType(0),
                        _DistanceType(__result_real_last - __result_first),
                        _InputValueType(*__first),
                        __comp);
        ++__first;
      }
      sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 2686 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     

      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1))));
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last);
    }
# 2728 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _RandomAccessIter, typename _Compare>
    void
    nth_element(_RandomAccessIter __first,
                _RandomAccessIter __nth,
                _RandomAccessIter __last,
                            _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIter>::value_type _ValueType;


     
     


      while (__last - __first > 3) {
        _RandomAccessIter __cut =
          __unguarded_partition(__first, __last,
                                _ValueType(__median(*__first,
                                                    *(__first + (__last - __first)/2),
                                                    *(__last - 1),
                                                    __comp)),
                                __comp);
        if (__cut <= __nth)
          __first = __cut;
        else
          __last = __cut;
      }
      __insertion_sort(__first, __last, __comp);
    }
# 2768 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;






     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2816 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    lower_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else
          __len = __half;
      }
      return __first;
    }
# 2856 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__val < *__middle)
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2901 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    _ForwardIter
    upper_bound(_ForwardIter __first, _ForwardIter __last,
                const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(__val, *__middle))
          __len = __half;
        else {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
      }
      return __first;
    }
# 2948 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;



     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (*__middle < __val) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__val < *__middle)
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3003 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    pair<_ForwardIter, _ForwardIter>
    equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
                _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;
      typedef typename iterator_traits<_ForwardIter>::difference_type _DistanceType;


     
     
     

      _DistanceType __len = distance(__first, __last);
      _DistanceType __half;
      _ForwardIter __middle, __left, __right;

      while (__len > 0) {
        __half = __len >> 1;
        __middle = __first;
        advance(__middle, __half);
        if (__comp(*__middle, __val)) {
          __first = __middle;
          ++__first;
          __len = __len - __half - 1;
        }
        else if (__comp(__val, *__middle))
          __len = __half;
        else {
          __left = lower_bound(__first, __middle, __val, __comp);
          advance(__first, __len);
          __right = upper_bound(++__middle, __first, __val, __comp);
          return pair<_ForwardIter, _ForwardIter>(__left, __right);
        }
      }
      return pair<_ForwardIter, _ForwardIter>(__first, __first);
    }
# 3052 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val)
    {


     
     

     

      _ForwardIter __i = lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
# 3083 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIter __first, _ForwardIter __last,
                  const _Tp& __val, _Compare __comp)
    {

     
     

     


      _ForwardIter __i = lower_bound(__first, __last, __val, __comp);
      return __i != __last && !__comp(__val, *__i);
    }
# 3115 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }
# 3166 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    merge(_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _InputIter2 __last2,
          _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }






  template<typename _BidirectionalIter, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (*__middle < *__first)
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22);
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIter __first,
                           _BidirectionalIter __middle,
                           _BidirectionalIter __last,
                           _Distance __len1, _Distance __len2,
                           _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
        return;
      if (__len1 + __len2 == 2) {
        if (__comp(*__middle, *__first))
              iter_swap(__first, __middle);
        return;
      }
      _BidirectionalIter __first_cut = __first;
      _BidirectionalIter __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2) {
        __len11 = __len1 / 2;
        advance(__first_cut, __len11);
        __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
        __len22 = distance(__middle, __second_cut);
      }
      else {
        __len22 = __len2 / 2;
        advance(__second_cut, __len22);
        __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
        __len11 = distance(__first, __first_cut);
      }
      rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIter __new_middle = __first_cut;
      advance(__new_middle, distance(__middle, __second_cut));
      __merge_without_buffer(__first, __first_cut, __new_middle,
                             __len11, __len22, __comp);
      __merge_without_buffer(__new_middle, __second_cut, __last,
                             __len1 - __len11, __len2 - __len22, __comp);
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _Distance>
    _BidirectionalIter1
    __rotate_adaptive(_BidirectionalIter1 __first,
                      _BidirectionalIter1 __middle,
                      _BidirectionalIter1 __last,
                      _Distance __len1, _Distance __len2,
                      _BidirectionalIter2 __buffer,
                      _Distance __buffer_size)
    {
      _BidirectionalIter2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size) {
        __buffer_end = copy(__middle, __last, __buffer);
        copy_backward(__first, __middle, __last);
        return copy(__buffer, __buffer_end, __first);
      }
      else if (__len1 <= __buffer_size) {
        __buffer_end = copy(__first, __middle, __buffer);
        copy(__middle, __last, __first);
        return copy_backward(__buffer, __buffer_end, __last);
      }
      else {
        rotate(__first, __middle, __last);
        advance(__first, distance(__middle, __last));
        return __first;
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (*__last2 < *__last1) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BidirectionalIter3, typename _Compare>
    _BidirectionalIter3
    __merge_backward(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
                     _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
                     _BidirectionalIter3 __result,
                     _Compare __comp)
    {
      if (__first1 == __last1)
        return copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
        return copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true) {
        if (__comp(*__last2, *__last1)) {
          *--__result = *__last1;
          if (__first1 == __last1)
            return copy_backward(__first2, ++__last2, __result);
          --__last1;
        }
        else {
          *--__result = *__last2;
          if (__first2 == __last2)
            return copy_backward(__first1, ++__last1, __result);
          --__last2;
        }
      }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size);
          }
    }






  template<typename _BidirectionalIter, typename _Distance, typename _Pointer,
           typename _Compare>
    void
    __merge_adaptive(_BidirectionalIter __first,
                     _BidirectionalIter __middle,
                     _BidirectionalIter __last,
                     _Distance __len1, _Distance __len2,
                     _Pointer __buffer, _Distance __buffer_size,
                     _Compare __comp)
    {
          if (__len1 <= __len2 && __len1 <= __buffer_size) {
            _Pointer __buffer_end = copy(__first, __middle, __buffer);
            merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
          }
          else if (__len2 <= __buffer_size) {
            _Pointer __buffer_end = copy(__middle, __last, __buffer);
            __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
                                             __comp);
          }
          else {
            _BidirectionalIter __first_cut = __first;
            _BidirectionalIter __second_cut = __middle;
            _Distance __len11 = 0;
            _Distance __len22 = 0;
            if (__len1 > __len2) {
                  __len11 = __len1 / 2;
                  advance(__first_cut, __len11);
                  __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
                  __len22 = distance(__middle, __second_cut);
            }
            else {
                  __len22 = __len2 / 2;
                  advance(__second_cut, __len22);
                  __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
                  __len11 = distance(__first, __first_cut);
            }
            _BidirectionalIter __new_middle =
                  __rotate_adaptive(__first_cut, __middle, __second_cut,
                                    __len1 - __len11, __len22, __buffer,
                                    __buffer_size);
            __merge_adaptive(__first, __first_cut, __new_middle, __len11,
                             __len22, __buffer, __buffer_size, __comp);
            __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
                             __len2 - __len22, __buffer, __buffer_size, __comp);
          }
    }
# 3508 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     

      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()));
    }
# 3559 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _BidirectionalIter, typename _Compare>
    void
    inplace_merge(_BidirectionalIter __first,
                  _BidirectionalIter __middle,
                  _BidirectionalIter __last,
                  _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIter>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIter>::difference_type
          _DistanceType;


     

     


      if (__first == __middle || __middle == __last)
        return;

      _DistanceType __len1 = distance(__first, __middle);
      _DistanceType __len2 = distance(__middle, __last);

      _Temporary_buffer<_BidirectionalIter, _ValueType> __buf(__first, __last);
      if (__buf.begin() == 0)
        __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
      else
        __merge_adaptive(__first, __middle, __last, __len1, __len2,
                         __buf.begin(), _DistanceType(__buf.size()),
                         __comp);
    }






  template<typename _InputIter1, typename _InputIter2>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2)
    {

     
     
     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first2 < *__first1)
          return false;
        else if(*__first1 < *__first2)
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _Compare>
    bool
    includes(_InputIter1 __first1, _InputIter1 __last1,
             _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)
    {

     
     
     


     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first2, *__first1))
          return false;
        else if(__comp(*__first1, *__first2))
          ++__first1;
        else
          ++__first1, ++__first2;

      return __first2 == __last2;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2) {
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_union(_InputIter1 __first1, _InputIter1 __last1,
              _InputIter2 __first2, _InputIter2 __last2,
              _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2) {
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
        }
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
        }
        ++__result;
      }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2)
          ++__first1;
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_intersection(_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _InputIter2 __last2,
                     _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2))
          ++__first1;
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          *__result = *__first1;
          ++__first1;
          ++__first2;
          ++__result;
        }
      return __result;
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1)
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_difference(_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result, _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1))
          ++__first2;
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first1, __last1, __result);
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result)
    {

     
     
     

     


     


      while (__first1 != __last1 && __first2 != __last2)
        if (*__first1 < *__first2) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (*__first2 < *__first1) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }

  template<typename _InputIter1, typename _InputIter2, typename _OutputIter,
           typename _Compare>
    _OutputIter
    set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _OutputIter __result,
                             _Compare __comp)
    {

     
     
     


     

     



      while (__first1 != __last1 && __first2 != __last2)
        if (__comp(*__first1, *__first2)) {
          *__result = *__first1;
          ++__first1;
          ++__result;
        }
        else if (__comp(*__first2, *__first1)) {
          *__result = *__first2;
          ++__first2;
          ++__result;
        }
        else {
          ++__first1;
          ++__first2;
        }
      return copy(__first2, __last2, copy(__first1, __last1, __result));
    }




  template<typename _ForwardIter>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__result < *__first)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    max_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__result, *__first)) __result = __first;
      return __result;
    }

  template<typename _ForwardIter>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last)
    {

     
     


      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (*__first < *__result)
          __result = __first;
      return __result;
    }

  template<typename _ForwardIter, typename _Compare>
    _ForwardIter
    min_element(_ForwardIter __first, _ForwardIter __last,
                _Compare __comp)
    {

     
     



      if (__first == __last) return __first;
      _ForwardIter __result = __first;
      while (++__first != __last)
        if (__comp(*__first, *__result))
          __result = __first;
      return __result;
    }




  template<typename _BidirectionalIter>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__i < *__ii) {
          _BidirectionalIter __j = __last;
          while (!(*__i < *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__i, *__ii)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*__i, *--__j))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last)
    {

     
     


      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (*__ii < *__i) {
          _BidirectionalIter __j = __last;
          while (!(*--__j < *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }

  template<typename _BidirectionalIter, typename _Compare>
    bool
    prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
                     _Compare __comp)
    {

     
     



      if (__first == __last)
        return false;
      _BidirectionalIter __i = __first;
      ++__i;
      if (__i == __last)
        return false;
      __i = __last;
      --__i;

      for(;;) {
        _BidirectionalIter __ii = __i;
        --__i;
        if (__comp(*__ii, *__i)) {
          _BidirectionalIter __j = __last;
          while (!__comp(*--__j, *__i))
            {}
          iter_swap(__i, __j);
          reverse(__ii, __last);
          return true;
        }
        if (__i == __first) {
          reverse(__first, __last);
          return false;
        }
      }
    }



  template<typename _InputIter, typename _ForwardIter>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2)
    {

     
     
     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (*__first1 == *__iter)
            return __first1;
      return __last1;
    }

  template<typename _InputIter, typename _ForwardIter, typename _BinaryPredicate>
    _InputIter
    find_first_of(_InputIter __first1, _InputIter __last1,
                  _ForwardIter __first2, _ForwardIter __last2,
                  _BinaryPredicate __comp)
    {

     
     
     


     



      for ( ; __first1 != __last1; ++__first1)
        for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
          if (__comp(*__first1, *__iter))
            return __first1;
      return __last1;
    }
# 4201 "/usr/include/gcc/darwin/3.1/g++-v3/bits/stl_algo.h" 3
  template<typename _ForwardIter1, typename _ForwardIter2>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    _ForwardIter1
    __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
               _ForwardIter2 __first2, _ForwardIter2 __last2,
               forward_iterator_tag, forward_iterator_tag,
               _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
        return __last1;
      else {
        _ForwardIter1 __result = __last1;
        while (1) {
          _ForwardIter1 __new_result
            = search(__first1, __last1, __first2, __last2, __comp);
          if (__new_result == __last1)
            return __result;
          else {
            __result = __new_result;
            __first1 = __new_result;
            ++__first1;
          }
        }
      }
    }


  template<typename _BidirectionalIter1, typename _BidirectionalIter2>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }

  template<typename _BidirectionalIter1, typename _BidirectionalIter2,
           typename _BinaryPredicate>
    _BidirectionalIter1
    __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
               _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
               bidirectional_iterator_tag, bidirectional_iterator_tag,
               _BinaryPredicate __comp)
    {

     
     

      typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
      typedef reverse_iterator<_BidirectionalIter2> _RevIter2;

      _RevIter1 __rlast1(__first1);
      _RevIter2 __rlast2(__first2);
      _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
                                   _RevIter2(__last2), __rlast2,
                                   __comp);

      if (__rresult == __rlast1)
        return __last1;
      else {
        _BidirectionalIter1 __result = __rresult.base();
        advance(__result, -distance(__first2, __last2));
        return __result;
      }
    }



  template<typename _ForwardIter1, typename _ForwardIter2>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2));
    }

  template<typename _ForwardIter1, typename _ForwardIter2,
           typename _BinaryPredicate>
    inline _ForwardIter1
    find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
             _ForwardIter2 __first2, _ForwardIter2 __last2,
             _BinaryPredicate __comp)
    {

     
     
     



      return __find_end(__first1, __last1, __first2, __last2,
                        __iterator_category(__first1),
                        __iterator_category(__first2),
                        __comp);
    }

}
# 70 "/usr/include/gcc/darwin/3.1/g++-v3/algorithm" 2 3
# 57 "/usr/include/gcc/darwin/3.1/g++-v3/string" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.tcc" 1 3
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_S_empty_rep_storage[
    (sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   input_iterator_tag)
      {
        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();

        _CharT __buf[100];
        size_type __i = 0;
        while (__beg != __end && __i < sizeof(__buf) / sizeof(_CharT))
          {
            __buf[__i++] = *__beg;
            ++__beg;
          }
        _Rep* __r = _Rep::_S_create(__i, __a);
        traits_type::copy(__r->_M_refdata(), __buf, __i);
        __r->_M_length = __i;
        try
          {



            for (;;)
              {
                _CharT* __p = __r->_M_refdata() + __r->_M_length;
                _CharT* __last = __r->_M_refdata() + __r->_M_capacity;
                for (;;)
                  {
                    if (__beg == __end)
                      {
                        __r->_M_length = __p - __r->_M_refdata();
                        *__p = _Rep::_S_terminal;
                        return __r->_M_refdata();
                      }
                    if (__p == __last)
                      break;
                    *__p++ = *__beg;
                    ++__beg;
                  }

                size_type __len = __p - __r->_M_refdata();
                _Rep* __another = _Rep::_S_create(__len + 1, __a);
                traits_type::copy(__another->_M_refdata(),
                                  __r->_M_refdata(), __len);
                __r->_M_destroy(__a);
                __r = __another;
                __r->_M_length = __len;
              }
          }
        catch(...)
          {
            __r->_M_destroy(__a);
            throw;
          }
        return 0;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <class _InIter>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,
                   forward_iterator_tag)
      {
        size_type __dnew = static_cast<size_type>(distance(__beg, __end));


        if (__builtin_expect(__beg == _InIter(0), 0))
          __throw_logic_error("attempt to create string with null pointer");

        if (__beg == __end && __a == _Alloc())
          return _S_empty_rep()._M_refcopy();


        _Rep* __r = _Rep::_S_create(__dnew, __a);
        try
          { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
        catch(...)
          {
            __r->_M_destroy(__a);
            throw;
          }
        __r->_M_length = __dnew;

        __r->_M_refdata()[__dnew] = _Rep::_S_terminal;
        return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      if (__n == 0 && __a == _Alloc())
        return _S_empty_rep()._M_refcopy();


      _Rep* __r = _Rep::_S_create(__n, __a);
      try
        {
          if (__n)
            traits_type::assign(__r->_M_refdata(), __n, __c);
        }
      catch(...)
        {
          __r->_M_destroy(__a);
          throw;
        }
      __r->_M_length = __n;
      __r->_M_refdata()[__n] = _Rep::_S_terminal;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(), __str.get_allocator()),
                 __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
                 size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_check(__pos),
                               __str._M_fold(__pos, __n), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) : 0,
                               __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIter __beg, _InputIter __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
        {

          allocator_type __a = this->get_allocator();
          _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      size_type __size = sizeof(_Rep) + (_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_M_leak_hard()
    {
      if (_M_rep()->_M_is_shared())
        _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const _CharT* __src = _M_data() + __pos + __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (_M_rep()->_M_is_shared() || __new_size > capacity())
        {

          allocator_type __a = get_allocator();


          const size_type __pagesize = 4096;
          const size_type __malloc_header_size = 4 * sizeof (void*);

          const size_type __page_capacity = (__pagesize - __malloc_header_size
                                             - sizeof(_Rep) - sizeof(_CharT))
                                             / sizeof(_CharT);
          _Rep* __r;
          if (__new_size > capacity() && __new_size > __page_capacity)

            __r = _Rep::_S_create(__new_size > 2*capacity() ?
                                  __new_size : 2*capacity(), __a);
          else
            __r = _Rep::_S_create(__new_size, __a);
          try
            {
              if (__pos)
                traits_type::copy(__r->_M_refdata(), _M_data(), __pos);
              if (__how_much)
                traits_type::copy(__r->_M_refdata() + __pos + __len2,
                                  __src, __how_much);
            }
          catch(...)
            {
              __r->_M_dispose(get_allocator());
              throw;
            }
          _M_rep()->_M_dispose(__a);
          _M_data(__r->_M_refdata());
      }
      else if (__how_much && __len1 != __len2)
        {

          traits_type::move(_M_data() + __pos + __len2, __src, __how_much);
        }
      _M_rep()->_M_set_sharable();
      _M_rep()->_M_length = __new_size;
      _M_data()[__new_size] = _Rep::_S_terminal;

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::reserve(size_type __res)
    {
      if (__res > this->capacity() || _M_rep()->_M_is_shared())
        {
          if (__res > this->max_size())
            __throw_length_error("basic_string::reserve");

          if (__res < this->size())
            __res = this->size();
          allocator_type __a = get_allocator();
          _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
          _M_rep()->_M_dispose(__a);
          _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
        _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
        __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
        {
          _CharT* __tmp = _M_data();
          _M_data(__s._M_data());
          __s._M_data(__tmp);
        }

      else
        {
          basic_string __tmp1(_M_ibegin(), _M_iend(), __s.get_allocator());
          basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                              this->get_allocator());
          *this = __tmp2;
          __s = __tmp1;
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_t __capacity, const _Alloc& __alloc)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;


      if (__capacity > _S_max_size)



        __throw_length_error("basic_string::_S_create");




      size_t __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
# 421 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.tcc" 3
      const size_t __pagesize = 4096;
      const size_t __subpagesize = 128;
      const size_t __malloc_header_size = 4 * sizeof (void*);
      if ((__size + __malloc_header_size) > __pagesize)
        {
          size_t __extra =
            (__pagesize - ((__size + __malloc_header_size) % __pagesize))
            % __pagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }
      else if (__size > __subpagesize)
        {
          size_t __extra =
            (__subpagesize - ((__size + __malloc_header_size) % __subpagesize))
            % __subpagesize;
          __capacity += __extra / sizeof(_CharT);
          __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
        }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      __p->_M_length = 0;
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = _M_length + __res;

      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof (void*);

      const size_type __page_capacity =
        (__pagesize - __malloc_header_size - sizeof(_Rep) - sizeof(_CharT))
        / sizeof(_CharT);
      _Rep* __r;
      if (__requested_cap > _M_capacity && __requested_cap > __page_capacity)

        __r = _Rep::_S_create(__requested_cap > 2*_M_capacity ?
                              __requested_cap : 2*_M_capacity, __alloc);
      else
        __r = _Rep::_S_create(__requested_cap, __alloc);

      if (_M_length)
        {
          try
            { traits_type::copy(__r->_M_refdata(), _M_refdata(), _M_length); }
          catch(...)
            {
              __r->_M_destroy(__alloc);
              throw;
            }
        }
      __r->_M_length = _M_length;
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::resize(size_type __n, _CharT __c)
    {
      if (__n > max_size())
        __throw_length_error("basic_string::resize");
      size_type __size = this->size();
      if (__size < __n)
        this->append(__n - __size, __c);
      else if (__n < __size)
        this->erase(__n);

    }
# 508 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace(iterator __i1, iterator __i2, _InputIter __k1,
                 _InputIter __k2, input_iterator_tag)
      {

        basic_string __s(__k1, __k2);
        return _M_replace_safe(__i1, __i2, __s._M_ibegin(), __s._M_iend());
      }






  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _ForwardIter>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_safe(iterator __i1, iterator __i2, _ForwardIter __k1,
                      _ForwardIter __k2)
      {
        size_type __dnew = static_cast<size_type>(distance(__k1, __k2));
        size_type __dold = __i2 - __i1;
        size_type __dmax = this->max_size();

        if (__dmax <= __dnew)
          __throw_length_error("basic_string::_M_replace");
        size_type __off = __i1 - _M_ibegin();
        _M_mutate(__off, __dold, __dnew);


        if (__dnew)
          _S_copy_chars(_M_data() + __off, __k1, __k2);

        return *this;
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2)
    {
      const size_type __strsize = __str.size();
      if (__pos2 > __strsize)
        __throw_out_of_range("basic_string::replace");
      const bool __testn2 = __n2 < __strsize - __pos2;
      const size_type __foldn2 = __testn2 ? __n2 : __strsize - __pos2;
      return this->replace(__pos1, __n1,
                           __str._M_data() + __pos2, __foldn2);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {



      size_type __size = __str.size();
      size_type __len = __size + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_ibegin(),
                             __str._M_iend());
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {



      size_type __len = min(__str.size() - __pos, __n) + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __str._M_check(__pos),
                             __str._M_fold(__pos, __n));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
      return _M_replace_safe(_M_iend(), _M_iend(), __s, __s + __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      size_type __len = __n + this->size();
      if (__len > this->capacity())
        this->reserve(__len);
       return this->replace(_M_iend(), _M_iend(), __n, __c);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
              const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __lhs + __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    replace(iterator __i1, iterator __i2, size_type __n2, _CharT __c)
    {
      size_type __n1 = __i2 - __i1;
      size_type __off1 = __i1 - _M_ibegin();
      if (max_size() - (this->size() - __n1) <= __n2)
        __throw_length_error("basic_string::replace");
      _M_mutate (__off1, __n1, __n2);

      if (__n2)
        traits_type::assign(_M_data() + __off1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      if (__pos > this->size())
        __throw_out_of_range("basic_string::copy");

      if (__n > this->size() - __pos)
        __n = this->size() - __pos;

      traits_type::copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      size_t __xpos = __pos;
      const _CharT* __data = _M_data();
      for (; __xpos + __n <= __size; ++__xpos)
        if (traits_type::compare(__data + __xpos, __s, __n) == 0)
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      size_type __ret = npos;
      if (__pos < __size)
        {
          const _CharT* __data = _M_data();
          size_type __n = __size - __pos;
          const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
          if (__p)
            __ret = __p - __data;
        }
      return __ret;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__n <= __size)
        {
          __pos = std::min(__size - __n, __pos);
          const _CharT* __data = _M_data();
          do
            {
              if (traits_type::compare(__data + __pos, __s, __n) == 0)
                return __pos;
            }
          while (__pos-- > 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          size_t __xpos = __size - 1;
          if (__xpos > __pos)
            __xpos = __pos;

          for (++__xpos; __xpos-- > 0; )
            if (traits_type::eq(_M_data()[__xpos], __c))
              return __xpos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      for (; __n && __pos < this->size(); ++__pos)
        {
          const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
          if (__p)
            return __pos;
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size && __n)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size-- != 0);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::find(__s, __n, _M_data()[__xpos]))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      size_t __xpos = __pos;
      for (; __xpos < this->size(); ++__xpos)
        if (!traits_type::eq(_M_data()[__xpos], __c))
          return __xpos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::find(__s, __n, _M_data()[__size]))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
        {
          if (--__size > __pos)
            __size = __pos;
          do
            {
              if (!traits_type::eq(_M_data()[__size], __c))
                return __size;
            }
          while (__size--);
        }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize= min(__size - __pos, __n);
      size_type __len = min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
            size_type __pos2, size_type __n2) const
    {
      size_type __size = this->size();
      size_type __osize = __str.size();
      if (__pos1 > __size || __pos2 > __osize)
        __throw_out_of_range("basic_string::compare");

      size_type __rsize = min(__size - __pos1, __n1);
      size_type __rosize = min(__osize - __pos2, __n2);
      size_type __len = min(__rsize, __rosize);
      int __r = traits_type::compare(_M_data() + __pos1,
                                     __str.data() + __pos2, __len);
      if (!__r)
        __r = __rsize - __rosize;
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      size_type __size = this->size();
      int __r = traits_type::compare(_M_data(), __s, __size);
      if (!__r)
        __r = __size - traits_type::length(__s);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = traits_type::length(__s);
      size_type __rsize = min(__size - __pos, __n1);
      size_type __len = min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
            size_type __n2) const
    {
      size_type __size = this->size();
      if (__pos > __size)
        __throw_out_of_range("basic_string::compare");

      size_type __osize = min(traits_type::length(__s), __n2);
      size_type __rsize = min(__size - __pos, __n1);
      size_type __len = min(__rsize, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
        __r = __rsize - __osize;
      return __r;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    _S_string_copy(const basic_string<_CharT, _Traits, _Alloc>& __str,
                   _CharT* __buf, typename _Alloc::size_type __bufsiz)
    {
      typedef typename _Alloc::size_type size_type;
      size_type __strsize = __str.size();
      size_type __bytes = min(__strsize, __bufsiz - 1);
      _Traits::copy(__buf, __str.data(), __bytes);
      __buf[__bytes] = _CharT();
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);

  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
}
# 58 "/usr/include/gcc/darwin/3.1/g++-v3/string" 2 3
# 50 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 1 3
# 34 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/exception_defines.h" 1 3
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/bits/functexcept.h" 2 3

namespace std
{

  void
  __throw_bad_exception(void);


  void
  __throw_bad_alloc(void);


  void
  __throw_bad_cast(void);

  void
  __throw_bad_typeid(void);


  void
  __throw_logic_error(const char* __s);

  void
  __throw_domain_error(const char* __s);

  void
  __throw_invalid_argument(const char* __s);

  void
  __throw_length_error(const char* __s);

  void
  __throw_out_of_range(const char* __s);

  void
  __throw_runtime_error(const char* __s);

  void
  __throw_range_error(const char* __s);

  void
  __throw_overflow_error(const char* __s);

  void
  __throw_underflow_error(const char* __s);


  void
  __throw_ios_failure(const char* __s);
}
# 51 "/usr/include/gcc/darwin/3.1/g++-v3/bits/localefwd.h" 2 3


namespace std
{

  class locale;


  template<typename _CharT>
    inline bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    inline bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    inline _CharT
    tolower(_CharT, const locale&);



  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;



  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  class __enc_traits;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;


  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


  class locale
  {
  public:

    typedef unsigned int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();



    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (collate | ctype | monetary |
                                           numeric | time | messages);


    locale() throw();

    locale(const locale& __other) throw();

    explicit
    locale(const char* __s);

    locale(const locale& __base, const char* __s, category __cat);

    locale(const locale& __base, const locale& __add, category __cat);

    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);

    ~locale() throw();

    const locale&
    operator=(const locale& __other) throw();

    template<typename _Facet>
      locale
      combine(const locale& __other) const;


    string
    name() const;

    bool
    operator==(const locale& __other) const throw ();

    inline bool
    operator!=(const locale& __other) const throw ()
    { return !(this->operator==(__other)); }

    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
                 const basic_string<_Char, _Traits, _Alloc>& __s2) const;


    static locale
    global(const locale&);

    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;

    static const size_t _S_num_categories = 6;

    explicit
    locale(_Impl*) throw();

    static inline void
    _S_initialize()
    {
      if (!_S_classic)
        classic();
    }

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

  private:

    _Atomic_word _M_references;
    facet** _M_facets;
    size_t _M_facets_size;
    const char* _M_names[_S_num_categories];
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    inline void
    _M_add_reference() throw()
    { __atomic_add(&_M_references, 1); }

    inline void
    _M_remove_reference() throw()
    {
      if (__exchange_and_add(&_M_references, -1) == 1)
        {
          try
            { delete this; }
          catch(...)
            { }
        }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(facet**, size_t, bool);

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    inline bool
    _M_check_same_name()
    {
      bool __ret = true;
      for (size_t i = 0; __ret && i < _S_num_categories - 1; ++i)
        __ret &= (strcmp(_M_names[i], _M_names[i + 1]) == 0);
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, facet*);

    template<typename _Facet>
      inline void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }
  };

  template<typename _Facet>
    locale::locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
      _M_impl->_M_install_facet(&_Facet::id, __f);
      for (size_t __i = 0; __i < _S_num_categories; ++__i)
        _M_impl->_M_names[__i] = "*";
    }


  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    _Atomic_word _M_references;

  protected:


    static __c_locale _S_c_locale;

    explicit
    facet(size_t __refs = 0) throw();

    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
                       __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc);

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

  private:
    void
    _M_add_reference() throw();

    void
    _M_remove_reference() throw();

    facet(const facet&);

    void
    operator=(const facet&);
  };



  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw ();




    mutable size_t _M_index;


    static _Atomic_word _S_highwater;

    void
    operator=(const id&);

    id(const id&);

  public:


    id();

    inline size_t
    _M_id() const
    {
      if (!_M_index)
        _M_index = 1 + __exchange_and_add(&_S_highwater, 1);
      return _M_index - 1;
    }
  };

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
}
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ios_base.h" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ios_base.h" 3



namespace std
{




  enum _Ios_Fmtflags { _M_ios_fmtflags_end = 1L << 16 };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline _Ios_Fmtflags
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline _Ios_Fmtflags
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }


  enum _Ios_Openmode { _M_ios_openmode_end = 1L << 16 };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline _Ios_Openmode
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline _Ios_Openmode
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }


  enum _Ios_Iostate { _M_ios_iostate_end = 1L << 16 };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline _Ios_Iostate
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline _Ios_Iostate
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  enum _Ios_Seekdir { _M_ios_seekdir_end = 1L << 16 };


  class ios_base
  {
  public:


    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      enum { _M_bufsize = 256 };
      char _M_name[_M_bufsize];

    };


    typedef _Ios_Fmtflags fmtflags;

    static const fmtflags boolalpha = fmtflags(__ios_flags::_S_boolalpha);
    static const fmtflags dec = fmtflags(__ios_flags::_S_dec);
    static const fmtflags fixed = fmtflags(__ios_flags::_S_fixed);
    static const fmtflags hex = fmtflags(__ios_flags::_S_hex);
    static const fmtflags internal = fmtflags(__ios_flags::_S_internal);
    static const fmtflags left = fmtflags(__ios_flags::_S_left);
    static const fmtflags oct = fmtflags(__ios_flags::_S_oct);
    static const fmtflags right = fmtflags(__ios_flags::_S_right);
    static const fmtflags scientific = fmtflags(__ios_flags::_S_scientific);
    static const fmtflags showbase = fmtflags(__ios_flags::_S_showbase);
    static const fmtflags showpoint = fmtflags(__ios_flags::_S_showpoint);
    static const fmtflags showpos = fmtflags(__ios_flags::_S_showpos);
    static const fmtflags skipws = fmtflags(__ios_flags::_S_skipws);
    static const fmtflags unitbuf = fmtflags(__ios_flags::_S_unitbuf);
    static const fmtflags uppercase = fmtflags(__ios_flags::_S_uppercase);
    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);
    static const fmtflags basefield = fmtflags(__ios_flags::_S_basefield);
    static const fmtflags floatfield = fmtflags(__ios_flags::_S_floatfield);


    typedef _Ios_Iostate iostate;
    static const iostate badbit = iostate(__ios_flags::_S_badbit);
    static const iostate eofbit = iostate(__ios_flags::_S_eofbit);
    static const iostate failbit = iostate(__ios_flags::_S_failbit);
    static const iostate goodbit = iostate(0);


    typedef _Ios_Openmode openmode;
    static const openmode app = openmode(__ios_flags::_S_app);
    static const openmode ate = openmode(__ios_flags::_S_ate);
    static const openmode binary = openmode(__ios_flags::_S_bin);
    static const openmode in = openmode(__ios_flags::_S_in);
    static const openmode out = openmode(__ios_flags::_S_out);
    static const openmode trunc = openmode(__ios_flags::_S_trunc);


    typedef _Ios_Seekdir seekdir;
    static const seekdir beg = seekdir(0);
    static const seekdir cur = seekdir(1);
    static const seekdir end = seekdir(2);
# 226 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };

    typedef void (*event_callback) (event, ios_base&, int);

    void
    register_callback(event_callback __fn, int __index);

  protected:

    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
                     _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __atomic_add(&_M_refcount, 1); }


      int
      _M_remove_reference() { return __exchange_and_add(&_M_refcount, -1); }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void);


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;


    static const int _S_local_word_size = 8;
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index);


    locale _M_ios_locale;

    void
    _M_init();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

      static void
      _S_ios_create(bool __sync);

      static void
      _S_ios_destroy();

    private:
      static int _S_ios_base_init;
      static bool _S_synced_with_stdio;
    };


    inline fmtflags
    flags() const { return _M_flags; }

    inline fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }

    inline fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }

    inline fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }

    inline void
    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }

    inline streamsize
    precision() const { return _M_precision; }

    inline streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }

    inline streamsize
    width() const { return _M_width; }

    inline streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }

    static bool
    sync_with_stdio(bool __sync = true);


    locale
    imbue(const locale& __loc);

    inline locale
    getloc() const { return _M_ios_locale; }


    static int
    xalloc() throw();

    inline long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_iword;
    }

    inline void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
                        ? _M_word[__ix] : _M_grow_words(__ix);
      return __word._M_pword;
    }


    ~ios_base();

  protected:
    ios_base();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);

  };


  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }

  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }

  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }

  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }

  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }

  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }

  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }

  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }

  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }

  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }

  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }

  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }

  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }

  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }

  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }

  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }

  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }

  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }

  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }

}
# 50 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 3







namespace std
{
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& _ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout);


  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef ctype<char_type> __ctype_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;

      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs<>(basic_ios<char_type, traits_type>& __ios,
                          __streambuf_type* __sbin,__streambuf_type* __sbout);

    protected:





      char_type* _M_buf;


      int_type _M_buf_size;


      int_type _M_buf_size_opt;



      bool _M_buf_unified;






      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      ios_base::openmode _M_mode;


      locale _M_buf_locale;


      bool _M_buf_locale_init;






      static const int_type _S_pback_size = 1;
      char_type _M_pback[_S_pback_size];
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;




      void
      _M_pback_create()
      {
        if (!_M_pback_init)
          {
            int_type __dist = _M_in_end - _M_in_cur;
            int_type __len = min(_S_pback_size, __dist);
            traits_type::copy(_M_pback, _M_in_cur, __len);
            _M_pback_cur_save = _M_in_cur;
            _M_pback_end_save = _M_in_end;
            this->setg(_M_pback, _M_pback, _M_pback + __len);
            _M_pback_init = true;
          }
      }




      void
      _M_pback_destroy()
      {
        if (_M_pback_init)
          {

            int_type __off_cur = _M_in_cur - _M_pback;


            int_type __off_end = 0;
            int_type __pback_len = _M_in_end - _M_pback;
            int_type __save_len = _M_pback_end_save - _M_buf;
            if (__pback_len > __save_len)
              __off_end = __pback_len - __save_len;

            this->setg(_M_buf, _M_pback_cur_save + __off_cur,
                       _M_pback_end_save + __off_end);
            _M_pback_cur_save = (0);
            _M_pback_end_save = (0);
            _M_pback_init = false;
          }
      }



      void
      _M_in_cur_move(off_type __n)
      {
        bool __testout = _M_out_cur;
        _M_in_cur += __n;
        if (__testout && _M_buf_unified)
          _M_out_cur += __n;
      }
# 198 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 3
      void
      _M_out_cur_move(off_type __n)
      {
        bool __testin = _M_in_cur;

        _M_out_cur += __n;
        if (__testin && _M_buf_unified)
          _M_in_cur += __n;
        if (_M_out_cur > _M_out_end)
          {
            _M_out_end = _M_out_cur;

            if (__testin)
              _M_in_end += __n;
          }
      }




      off_type
      _M_out_buf_size()
      {
        off_type __ret = 0;
        if (_M_out_cur)
          {

            if (_M_out_beg == _M_buf)
              __ret = _M_out_beg + _M_buf_size - _M_out_cur;

            else
              __ret = _M_out_end - _M_out_cur;
          }
        return __ret;
      }
# 241 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 3
      void
      _M_set_indeterminate(void)
      {
        if (_M_mode & ios_base::in)
          this->setg(_M_buf, _M_buf, _M_buf);
        if (_M_mode & ios_base::out)
          this->setp(_M_buf, _M_buf);
      }

      void
      _M_set_determinate(off_type __off)
      {
        bool __testin = _M_mode & ios_base::in;
        bool __testout = _M_mode & ios_base::out;
        if (__testin)
          this->setg(_M_buf, _M_buf, _M_buf + __off);
        if (__testout)
          this->setp(_M_buf, _M_buf + __off);
      }

      bool
      _M_is_indeterminate(void)
      {
        bool __ret = false;

        if (_M_buf)
          {
            if (_M_mode & ios_base::in)
              __ret = _M_in_beg == _M_in_cur && _M_in_cur == _M_in_end;
            if (_M_mode & ios_base::out)
              __ret = _M_out_beg == _M_out_cur && _M_out_cur == _M_out_end;
          }
        return __ret;
      }

  public:
      virtual
      ~basic_streambuf()
      {
        _M_buf_unified = false;
        _M_buf_size = 0;
        _M_buf_size_opt = 0;
        _M_mode = ios_base::openmode(0);
        _M_buf_locale_init = false;
      }


      locale
      pubimbue(const locale &__loc)
      {
        locale __tmp(this->getloc());
        this->imbue(__loc);
        return __tmp;
      }

      locale
      getloc() const
      {
        if (_M_buf_locale_init)
          return _M_buf_locale;
        else
          return locale();
      }


      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
                 ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }



      streamsize
      in_avail()
      {
        streamsize __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          {
            if (_M_pback_init)
              {
                int_type __save_len = _M_pback_end_save - _M_pback_cur_save;
                int_type __pback_len = _M_in_cur - _M_pback;
                __ret = __save_len - __pback_len;
              }
            else
              __ret = this->egptr() - this->gptr();
          }
        else
          __ret = this->showmanyc();
        return __ret;
      }

      int_type
      snextc()
      {
        int_type __eof = traits_type::eof();
        return (this->sbumpc() == __eof ? __eof : this->sgetc());
      }

      int_type
      sbumpc();

      int_type
      sgetc()
      {
        int_type __ret;
        if (_M_in_cur && _M_in_cur < _M_in_end)
          __ret = traits_type::to_int_type(*(this->gptr()));
        else
          __ret = this->underflow();
        return __ret;
      }

      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }


      int_type
      sputbackc(char_type __c);

      int_type
      sungetc();


      int_type
      sputc(char_type __c);

      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
      basic_streambuf()
      : _M_buf((0)), _M_buf_size(0),
      _M_buf_size_opt(static_cast<int_type>(1024)), _M_buf_unified(false),
      _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0),
      _M_out_end(0), _M_mode(ios_base::openmode(0)), _M_buf_locale(locale()),
      _M_buf_locale_init(false), _M_pback_cur_save(0), _M_pback_end_save(0),
      _M_pback_init(false)
      { }


      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }

      void
      gbump(int __n) { _M_in_cur += __n; }

      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
        _M_in_beg = __gbeg;
        _M_in_cur = __gnext;
        _M_in_end = __gend;
        if (!(_M_mode & ios_base::in) && __gbeg && __gnext && __gend)
          _M_mode = _M_mode | ios_base::in;
      }


      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }

      void
      pbump(int __n) { _M_out_cur += __n; }

      void
      setp(char_type* __pbeg, char_type* __pend)
      {
        _M_out_beg = _M_out_cur = __pbeg;
        _M_out_end = __pend;
        if (!(_M_mode & ios_base::out) && __pbeg && __pend)
          _M_mode = _M_mode | ios_base::out;
      }



      virtual void
      imbue(const locale& __loc)
      {
        _M_buf_locale_init = true;
        if (_M_buf_locale != __loc)
          _M_buf_locale = __loc;
      }


      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }

      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      virtual pos_type
      seekpos(pos_type,
              ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }

      virtual int
      sync() { return 0; }


      virtual streamsize
      showmanyc() { return 0; }

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual int_type
      underflow()
      { return traits_type::eof(); }

      virtual int_type
      uflow()
      {
        int_type __ret = traits_type::eof();
        bool __testeof = this->underflow() == __ret;
        bool __testpending = _M_in_cur && _M_in_cur < _M_in_end;
        if (!__testeof && __testpending)
          {
            __ret = traits_type::to_int_type(*_M_in_cur);
            ++_M_in_cur;
            if (_M_buf_unified && _M_mode & ios_base::out)
              ++_M_out_cur;
          }
        return __ret;
      }


      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }


      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);

      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
# 522 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 3
    private:
      basic_streambuf(const __streambuf_type&) { };

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };

    };
}





# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/streambuf.tcc" 1 3
# 39 "/usr/include/gcc/darwin/3.1/g++-v3/bits/streambuf.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    const typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::_S_pback_size;

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sbumpc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_cur < _M_in_end)
        {
          char_type __c = *gptr();
          _M_in_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->uflow();
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputbackc(char_type __c)
    {
      int_type __ret;
      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur;
      bool __testne = _M_in_cur && !traits_type::eq(__c, this->gptr()[-1]);
      if (!__testpos || __testne)
        __ret = pbackfail(traits_type::to_int_type(__c));
      else
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*this->gptr());
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sungetc()
    {
      int_type __ret;
      if (_M_in_cur && _M_in_beg < _M_in_cur)
        {
          _M_in_cur_move(-1);
          __ret = traits_type::to_int_type(*_M_in_cur);
        }
      else
        __ret = this->pbackfail();
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::
    sputc(char_type __c)
    {
      int_type __ret;
      if (_M_out_buf_size())
        {
          *_M_out_cur = __c;
          _M_out_cur_move(1);
          __ret = traits_type::to_int_type(__c);
        }
      else
        __ret = this->overflow(traits_type::to_int_type(__c));
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          size_t __buf_len = _M_in_end - _M_in_cur;
          if (__buf_len > 0)
            {
              size_t __remaining = __n - __ret;
              size_t __len = min(__buf_len, __remaining);
              traits_type::copy(__s, _M_in_cur, __len);
              __ret += __len;
              __s += __len;
              _M_in_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->uflow();
              if (__c != traits_type::eof())
                {
                  traits_type::assign(*__s++, traits_type::to_char_type(__c));
                  ++__ret;
                }
              else
                break;
            }
        }
      return __ret;
    }






  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
        {
          off_type __buf_len = _M_out_buf_size();
          if (__buf_len > 0)
            {
              off_type __remaining = __n - __ret;
              off_type __len = min(__buf_len, __remaining);
              traits_type::copy(_M_out_cur, __s, __len);
              __ret += __len;
              __s += __len;
              _M_out_cur_move(__len);
            }

          if (__ret < __n)
            {
              int_type __c = this->overflow(traits_type::to_int_type(*__s));
              if (__c != traits_type::eof())
                {
                  ++__ret;
                  ++__s;
                }
              else
                break;
            }
        }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs(basic_ios<_CharT, _Traits>& __ios,
                      basic_streambuf<_CharT, _Traits>* __sbin,
                      basic_streambuf<_CharT, _Traits>* __sbout)
  {
      typedef typename _Traits::int_type int_type;

      streamsize __ret = 0;
      streamsize __bufsize = __sbin->in_avail();
      streamsize __xtrct;
      bool __testput = __sbout->_M_mode & ios_base::out;
      try
        {
          while (__testput && __bufsize != -1)
            {
              __xtrct = __sbout->sputn(__sbin->gptr(), __bufsize);
              __ret += __xtrct;
              __sbin->_M_in_cur_move(__xtrct);
              if (__xtrct == __bufsize)
                {
                  if (__sbin->sgetc() == _Traits::eof())
                    break;
                  __bufsize = __sbin->in_avail();
                }
              else
                break;
            }
        }
      catch(exception& __fail)
        {
          __ios.setstate(ios_base::failbit);
          if ((__ios.exceptions() & ios_base::failbit) != 0)
            throw;
        }
      return __ret;
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<char>&, basic_streambuf<char>*,
                      basic_streambuf<char>*);

  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_ios<wchar_t>&, basic_streambuf<wchar_t>*,
                      basic_streambuf<wchar_t>*);
}
# 536 "/usr/include/gcc/darwin/3.1/g++-v3/streambuf" 2 3
# 51 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.h" 1 3
# 39 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.h" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/streambuf_iterator.h" 1 3
# 41 "/usr/include/gcc/darwin/3.1/g++-v3/bits/streambuf_iterator.h" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
      inline
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }

      ostreambuf_iterator&
      operator=(_CharT __c);

      ostreambuf_iterator&
      operator*() throw()
      { return *this; }

      ostreambuf_iterator&
      operator++(int) throw()
      { return *this; }

      ostreambuf_iterator&
      operator++() throw()
      { return *this; }

      bool
      failed() const throw()
      { return _M_failed; }
    };

  template<typename _CharT, typename _Traits>
    inline ostreambuf_iterator<_CharT, _Traits>&
    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)
    {
      if (!_M_failed &&
          _Traits::eq_int_type(_M_sbuf->sputc(__c),_Traits::eof()))
      _M_failed = true;
      return *this;
    }



  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*, _CharT&>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:







      streambuf_type* _M_sbuf;
      int_type _M_c;

    public:
      istreambuf_iterator() throw()
      : _M_sbuf((0)), _M_c(-2) { }

      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(-2) { }

      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(-2) { }




      char_type
      operator*() const
      {

        char_type __ret;
        if (_M_sbuf && _M_c != static_cast<int_type>(-2))
          __ret = _M_c;
        else if (_M_sbuf)
          __ret = traits_type::to_char_type(_M_sbuf->sgetc());
        else
          __ret = static_cast<char_type>(traits_type::eof());
        return __ret;
      }

      istreambuf_iterator&
      operator++()
      {
        if (_M_sbuf)
          _M_sbuf->sbumpc();
        _M_c = -2;
        return *this;
      }

      istreambuf_iterator
      operator++(int)
      {
        istreambuf_iterator __old = *this;
        if (_M_sbuf)
          __old._M_c = _M_sbuf->sbumpc();
        _M_c = -2;
        return __old;
      }

      bool
      equal(const istreambuf_iterator& __b)
      {
        int_type __eof = traits_type::eof();
        bool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;
        bool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;
        return (__thiseof && __beof || (!__thiseof && !__beof));
      }




      bool
      equal(const istreambuf_iterator& __b) const
      {
        int_type __eof = traits_type::eof();
        bool __thiseof = !_M_sbuf || _M_sbuf->sgetc() == __eof;
        bool __beof = !__b._M_sbuf || __b._M_sbuf->sgetc() == __eof;
        return (__thiseof && __beof || (!__thiseof && !__beof));
      }

    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
               const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }
}
# 41 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 1 3
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cwctype" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cwctype" 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3

namespace std
{
# 60 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_base.h" 1 3
# 39 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_base.h" 3
  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned long mask;


    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask xdigit = 0x00010000L;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask graph = 0x00000800L;
    static const mask cntrl = 0x00000200L;
    static const mask punct = 0x00002000L;
    static const mask alnum = 0x00000100L | 0x00000400L;
# 74 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_base.h" 3
  };
# 61 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:

      typedef _CharT char_type;

      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }

      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }

      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }

      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }

      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }

      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }

      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }

      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }

      char_type
      widen(char __c) const
      { return this->do_widen(__c); }

      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }

      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }

      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
              char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): locale::facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }

      virtual bool
      do_is(mask __m, char_type __c) const = 0;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
            mask* __vec) const = 0;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
                 const char_type* __hi) const = 0;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const = 0;

      virtual char_type
      do_toupper(char_type) const = 0;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_tolower(char_type) const = 0;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;

      virtual char_type
      do_widen(char) const = 0;

      virtual const char*
      do_widen(const char* __lo, const char* __hi,
               char_type* __dest) const = 0;

      virtual char
      do_narrow(char_type, char __dfault) const = 0;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                 char __dfault, char* __dest) const = 0;
    };


  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename ctype::mask mask;

      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;


  template<>
    class ctype<char> : public __ctype_abstract_base<char>
    {
    public:

      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;

    public:
      static locale::id id;
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);

      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);

      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
            size_t __refs = 0);

      inline bool
      is(mask __m, char __c) const;

      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;

      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;

      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;

    protected:
      const mask*
      table() const throw()
      { return _M_table; }

      static const mask*
      classic_table() throw();

      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
                  const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
                char __dfault, char* __dest) const;
    };

  template<>
    const ctype<char>&
    use_facet<ctype<char> >(const locale& __loc);
# 397 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_inline.h" 1 3
# 38 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_inline.h" 3
  bool
  ctype<char>::
  is(mask __m, char __c) const
  {
    return __istype(__c, __m);
  }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    for (;__low < __high; ++__vec, ++__low)
      {

        *__vec = __maskrune (*__low, upper | lower | alpha | digit | xdigit
                             | space | print | graph | cntrl | punct | alnum);
# 70 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/ctype_inline.h" 3
      }
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }
# 398 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3


  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef _CharT char_type;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    ctype_byname<char>::ctype_byname(const char*, size_t refs);

  template<>
    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/codecvt.h" 1 3
# 45 "/usr/include/gcc/darwin/3.1/g++-v3/bits/codecvt.h" 3


  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;


      result
      out(state_type& __state, const intern_type* __from,
          const intern_type* __from_end, const intern_type*& __from_next,
          extern_type* __to, extern_type* __to_end,
          extern_type*& __to_next) const
      {
        return this->do_out(__state, __from, __from_end, __from_next,
                            __to, __to_end, __to_next);
      }

      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
              extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }

      result
      in(state_type& __state, const extern_type* __from,
         const extern_type* __from_end, const extern_type*& __from_next,
         intern_type* __to, intern_type* __to_end,
         intern_type*& __to_next) const
      {
        return this->do_in(__state, __from, __from_end, __from_next,
                           __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(const state_type& __state, const extern_type* __from,
             const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;


      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT,_ExternT,_StateT> (__refs) { }

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;


      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
             const intern_type* __from_end, const intern_type*& __from_next,
             extern_type* __to, extern_type* __to_end,
             extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
                 extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
            const extern_type* __from_end, const extern_type*& __from_next,
            intern_type* __to, intern_type* __to_end,
            intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(const state_type&, const extern_type* __from,
                const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };
# 318 "/usr/include/gcc/darwin/3.1/g++-v3/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs) { }
    protected:
      virtual
      ~codecvt_byname() { }
    };
# 423 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3



  class __num_base
  {
  protected:


    static const char _S_atoms[];

    enum
    {
      _M_zero,
      _M_e = _M_zero + 10,
      _M_E = _M_zero + 11,
      _M_size = 21 + 1
    };



    static bool
    _S_format_float(const ios_base& __io, char* __fptr, char __mod,
                    streamsize __prec);


    static void
    _S_format_int(const ios_base& __io, char* __fptr, char __mod, char __modl);
  };


  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

    private:
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char* _M_grouping;
      const char_type* _M_truename;
      const char_type* _M_falsename;

    public:
      explicit
      numpunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(); }

      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_numpunct(__cloc); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      truename() const
      { return this->do_truename(); }

      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:
      virtual
      ~numpunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_truename() const
      { return _M_truename; }

      virtual string_type
      do_falsename() const
      { return _M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = _S_c_locale);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
# 547 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {

      __c_locale _M_c_locale_numpunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
        _S_create_c_locale(_M_c_locale_numpunct, __s);
        _M_initialize_numpunct(_M_c_locale_numpunct);
      }

    protected:
      virtual
      ~numpunct_byname()
      { _S_destroy_c_locale(_M_c_locale_numpunct); }
    };

  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      static locale::id id;

      explicit
      num_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
          ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:
      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
                       string& __xtrc) const;

      iter_type
      _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
                     string& __xtrc, int& __base) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
              unsigned short&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned int&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long long&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             unsigned long long&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             long double&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
             void*&) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet, public __num_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      static locale::id id;

      explicit
      num_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
          const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_convert_float(iter_type, ios_base& __io, char_type __fill,
                         char __mod, _ValueT __v) const;

      template<typename _ValueT>
        iter_type
        _M_convert_int(iter_type, ios_base& __io, char_type __fill,
                       char __mod, char __modl, _ValueT __v) const;

      iter_type
      _M_widen_float(iter_type, ios_base& __io, char_type __fill, char* __cs,
                     int __len) const;

      iter_type
      _M_widen_int(iter_type, ios_base& __io, char_type __fill, char* __cs,
                   int __len) const;

      iter_type
      _M_insert(iter_type, ios_base& __io, char_type __fill,
                const char_type* __ws, int __len) const;

      virtual
      ~num_put() { };

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;

      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;


  template<typename _CharT>
    class collate : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_collate;

    public:
      static locale::id id;

      explicit
      collate(size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_c_locale; }


      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : locale::facet(__refs)
      { _M_c_locale_collate = _S_clone_c_locale(__cloc); }

      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
              const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }

      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }

      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const;

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const;

  protected:
      virtual
      ~collate()
      {
        if (_M_c_locale_collate != _S_c_locale)
          _S_destroy_c_locale(_M_c_locale_collate);
      }

      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
                 const _CharT* __lo2, const _CharT* __hi2) const;

      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;

      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const;

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const;
# 896 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
        if (_M_c_locale_collate != _S_c_locale)
          _S_destroy_c_locale(_M_c_locale_collate);
        _S_create_c_locale(_M_c_locale_collate, __s);
      }

    protected:
      virtual
      ~collate_byname() { }
    };


  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;


      static const _CharT* _S_timezones[14];

    protected:
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_day_a1;
      const _CharT* _M_day_a2;
      const _CharT* _M_day_a3;
      const _CharT* _M_day_a4;
      const _CharT* _M_day_a5;
      const _CharT* _M_day_a6;
      const _CharT* _M_day_a7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_month_a01;
      const _CharT* _M_month_a02;
      const _CharT* _M_month_a03;
      const _CharT* _M_month_a04;
      const _CharT* _M_month_a05;
      const _CharT* _M_month_a06;
      const _CharT* _M_month_a07;
      const _CharT* _M_month_a08;
      const _CharT* _M_month_a09;
      const _CharT* _M_month_a10;
      const _CharT* _M_month_a11;
      const _CharT* _M_month_a12;

    public:
      explicit
      __timepunct(size_t __refs = 0)
      : locale::facet(__refs), _M_name_timepunct("C")
      { _M_initialize_timepunct(); }

      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : locale::facet(__refs), _M_name_timepunct(__s)
      { _M_initialize_timepunct(__cloc); }

      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
             const tm* __tm) const;

      void
      _M_date_formats(const _CharT** __date) const
      {

        __date[0] = _M_date_format;
        __date[1] = _M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

        __time[0] = _M_time_format;
        __time[1] = _M_time_era_format;
      }

      void
      _M_ampm(const _CharT** __ampm) const
      {
        __ampm[0] = _M_am;
        __ampm[1] = _M_pm;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

        __dt[0] = _M_date_time_format;
        __dt[1] = _M_date_time_era_format;
      }

      void
      _M_days(const _CharT** __days) const
      {
        __days[0] = _M_day1;
        __days[1] = _M_day2;
        __days[2] = _M_day3;
        __days[3] = _M_day4;
        __days[4] = _M_day5;
        __days[5] = _M_day6;
        __days[6] = _M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
        __days[0] = _M_day_a1;
        __days[1] = _M_day_a2;
        __days[2] = _M_day_a3;
        __days[3] = _M_day_a4;
        __days[4] = _M_day_a5;
        __days[5] = _M_day_a6;
        __days[6] = _M_day_a7;
      }

      void
      _M_months(const _CharT** __months) const
      {
        __months[0] = _M_month01;
        __months[1] = _M_month02;
        __months[2] = _M_month03;
        __months[3] = _M_month04;
        __months[4] = _M_month05;
        __months[5] = _M_month06;
        __months[6] = _M_month07;
        __months[7] = _M_month08;
        __months[8] = _M_month09;
        __months[9] = _M_month10;
        __months[10] = _M_month11;
        __months[11] = _M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
        __months[0] = _M_month_a01;
        __months[1] = _M_month_a02;
        __months[2] = _M_month_a03;
        __months[3] = _M_month_a04;
        __months[4] = _M_month_a05;
        __months[5] = _M_month_a06;
        __months[6] = _M_month_a07;
        __months[7] = _M_month_a08;
        __months[8] = _M_month_a09;
        __months[9] = _M_month_a10;
        __months[10] = _M_month_a11;
        __months[11] = _M_month_a12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = _S_c_locale);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    __timepunct<char>::~__timepunct();

  template<>
    const char*
    __timepunct<char>::_S_timezones[14];

  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const;
# 1147 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
  template<typename _CharT>
    const _CharT* __timepunct<_CharT>::_S_timezones[14];


  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> __string_type;

      static locale::id id;

      explicit
      time_get(size_t __refs = 0)
      : locale::facet (__refs) { }

      dateorder
      date_order() const
      { return this->do_date_order(); }

      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }

      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }

      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }

      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }

      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
               ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }

    protected:
      virtual
      ~time_get() { }

      virtual dateorder
      do_date_order() const;

      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
                     ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
                       ios_base::iostate& __err, tm* __tm) const;

      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                  ios_base::iostate& __err, tm* __tm) const;


      void
      _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                     int __min, int __max, size_t __len,
                     const ctype<_CharT>& __ctype,
                     ios_base::iostate& __err) const;



      void
      _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                      const _CharT** __names, size_t __indexlen,
                      ios_base::iostate& __err) const;


      void
      _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                            ios_base::iostate& __err, tm* __tm,
                            const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }

    protected:
      virtual
      ~time_get_byname() { }
    };

  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet, public time_base
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      static locale::id id;

      explicit
      time_put(size_t __refs = 0)
      : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
          const _CharT* __beg, const _CharT* __end) const;

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
          const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:
      virtual
      ~time_put()
      { }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
             char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;

  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char* , size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };

    protected:
      virtual
      ~time_put_byname() { }
    };


  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;



    static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn);
  };

  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;
      static locale::id id;

    private:
      const char* _M_grouping;
      char_type _M_decimal_point;
      char_type _M_thousands_sep;
      const char_type* _M_curr_symbol;
      const char_type* _M_positive_sign;
      const char_type* _M_negative_sign;
      int _M_frac_digits;
      pattern _M_pos_format;
      pattern _M_neg_format;

    public:
      explicit
      moneypunct(size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_moneypunct(); }

      explicit
      moneypunct(__c_locale __cloc, size_t __refs = 0) : locale::facet(__refs)
      { _M_initialize_moneypunct(__cloc); }

      char_type
      decimal_point() const
      { return this->do_decimal_point(); }

      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }

      string
      grouping() const
      { return this->do_grouping(); }

      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }

      string_type
      positive_sign() const
      { return this->do_positive_sign(); }

      string_type
      negative_sign() const
      { return this->do_negative_sign(); }

      int
      frac_digits() const
      { return this->do_frac_digits(); }

      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }

    protected:
      virtual
      ~moneypunct();

      virtual char_type
      do_decimal_point() const
      { return _M_decimal_point; }

      virtual char_type
      do_thousands_sep() const
      { return _M_thousands_sep; }

      virtual string
      do_grouping() const
      { return _M_grouping; }

      virtual string_type
      do_curr_symbol() const
      { return _M_curr_symbol; }

      virtual string_type
      do_positive_sign() const
      { return _M_positive_sign; }

      virtual string_type
      do_negative_sign() const
      { return _M_negative_sign; }

      virtual int
      do_frac_digits() const
      { return _M_frac_digits; }

      virtual pattern
      do_pos_format() const
      { return _M_pos_format; }

      virtual pattern
      do_neg_format() const
      { return _M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = _S_c_locale);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale __cloc);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale __cloc);
# 1480 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
      __c_locale _M_c_locale_moneypunct;

    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
        _S_create_c_locale(_M_c_locale_moneypunct, __s);
        _M_initialize_moneypunct(_M_c_locale_moneypunct);
      }

    protected:
      virtual
      ~moneypunct_byname()
      { _S_destroy_c_locale(_M_c_locale_moneypunct); }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_get(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }

      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
          ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:
      virtual
      ~money_get() { }

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, long double& __units) const;

      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
             ios_base::iostate& __err, string_type& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;

  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;

      static locale::id id;

      explicit
      money_put(size_t __refs = 0) : locale::facet(__refs) { }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }

      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
          char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:
      virtual
      ~money_put() { }

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             long double __units) const;

      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
             const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;


  struct messages_base
  {
    typedef int catalog;
  };

  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:

      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

    protected:


      __c_locale _M_c_locale_messages;


      const char* _M_name_messages;


    public:
      static locale::id id;

      explicit
      messages(size_t __refs = 0)
      : locale::facet(__refs), _M_name_messages("C")
      { _M_c_locale_messages = _S_c_locale; }


      explicit
      messages(__c_locale __cloc, const char* __name, size_t __refs = 0)
      : locale::facet(__refs)
      {
        _M_name_messages = __name;
        _M_c_locale_messages = _S_clone_c_locale(__cloc);
      }

      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }


      catalog
      open(const basic_string<char>&, const locale&, const char*) const;

      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }

      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:
      virtual
      ~messages()
       {
         if (_M_c_locale_messages != _S_c_locale)
           _S_destroy_c_locale(_M_c_locale_messages);
       }

      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;

      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;

      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

        return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char* __msg) const
      {

        size_t __len = char_traits<char>::length(__msg) - 1;
# 1705 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 3
        return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/messages_members.h" 1 3
# 37 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/messages_members.h" 3
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
                           const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
                             const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }
# 1719 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.h" 2 3

  template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0)
      : messages<_CharT>(__refs)
      {
        _M_name_messages = __s;
        if (_M_c_locale_messages != _S_c_locale)
          _S_destroy_c_locale(_M_c_locale_messages);
        _S_create_c_locale(_M_c_locale_messages, __s);
      }

    protected:
      virtual
      ~messages_byname()
      { }
    };






  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }

  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }

  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }

  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }

  template<typename _CharT>
    inline bool islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }

  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }

  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }

  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }

  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }

  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }

  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }

  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }

  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
}
# 42 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.h" 2 3

namespace std
{

  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef ctype<_CharT> __ctype_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;


    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_fctype;

      const __numput_type* _M_fnumput;

      const __numget_type* _M_fnumget;

    public:
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }

      iostate
      rdstate() const
      { return _M_streambuf_state; }

      void
      clear(iostate __state = goodbit);

      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }

      bool
      good() const
      { return this->rdstate() == 0; }

      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }

      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }

      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }

      iostate
      exceptions() const
      { return _M_exception; }

      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }


      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base()
      { this->init(__sb); }

      virtual
      ~basic_ios() { }


      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }

      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }

      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }

      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);

      basic_ios&
      copyfmt(const basic_ios& __rhs);

      char_type
      fill() const
      {
        if (!_M_fill_init)
          {
            _M_fill = this->widen(' ');
            _M_fill_init = true;
          }
        return _M_fill;
      }

      char_type
      fill(char_type __ch)
      {
        char_type __old = this->fill();
        _M_fill = __ch;
        return __old;
      }


      locale
      imbue(const locale& __loc);

      char
      narrow(char_type __c, char __dfault) const;

      char_type
      widen(char __c) const;

    protected:

      basic_ios() : ios_base()
      { }

      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      bool
      _M_check_facet(const locale::facet* __f) const
      {
        if (!__f)
          __throw_bad_cast();
        return true;
      }

      void
      _M_cache_facets(const locale& __loc);
    };
}



# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.tcc" 1 3
# 34 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.tcc" 3

namespace std
{
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
        _M_streambuf_state = __state;
      else
          _M_streambuf_state = __state | badbit;
      if ((this->rdstate() & this->exceptions()))
        __throw_ios_failure("basic_ios::clear(iostate) caused exception");
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {




      _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
        _M_local_word : new _Words[__rhs._M_word_size];


      _Callback_list* __cb = __rhs._M_callbacks;
      if (__cb)
        __cb->_M_add_reference();
      _M_call_callbacks(erase_event);
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_dispose_callbacks();

      _M_callbacks = __cb;
      for (int __i = 0; __i < __rhs._M_word_size; ++__i)
        __words[__i] = __rhs._M_word[__i];
      if (_M_word != _M_local_word)
        {
          delete [] _M_word;
          _M_word = 0;
        }
      _M_word = __words;
      _M_word_size = __rhs._M_word_size;

      this->flags(__rhs.flags());
      this->width(__rhs.width());
      this->precision(__rhs.precision());
      this->tie(__rhs.tie());
      this->fill(__rhs.fill());

      this->exceptions(__rhs.exceptions());

      _M_call_callbacks(copyfmt_event);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    char
    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const
    {
      char __ret = __dfault;
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->narrow(__c, __dfault);
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    _CharT
    basic_ios<_CharT, _Traits>::widen(char __c) const
    {
      char_type __ret = char_type();
      if (_M_check_facet(_M_fctype))
        __ret = _M_fctype->widen(__c);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_facets(__loc);
      if (this->rdbuf() != 0)
        this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();
      _M_cache_facets(_M_ios_locale);
      _M_tie = 0;
# 159 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.tcc" 3
      _M_fill = 0;
      _M_fill_init = false;

      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_facets(const locale& __loc)
    {
      if (has_facet<__ctype_type>(__loc))
        _M_fctype = &use_facet<__ctype_type>(__loc);
      else
        _M_fctype = 0;

      if (has_facet<__numput_type>(__loc))
        _M_fnumput = &use_facet<__numput_type>(__loc);
      else
        _M_fnumput = 0;
      if (has_facet<__numget_type>(__loc))
        _M_fnumget = &use_facet<__numget_type>(__loc);
      else
        _M_fnumget = 0;
    }




  extern template class basic_ios<char>;
  extern template class basic_ios<wchar_t>;
}
# 208 "/usr/include/gcc/darwin/3.1/g++-v3/bits/basic_ios.h" 2 3
# 52 "/usr/include/gcc/darwin/3.1/g++-v3/ios" 2 3
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/ostream" 2 3

namespace std
{

  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ostreambuf_iterator<_CharT, _Traits> __ostreambuf_iter;
      typedef num_put<_CharT, __ostreambuf_iter> __numput_type;
      typedef ctype<_CharT> __ctype_type;


      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }

      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;



      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&));

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&));

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&));


      __ostream_type&
      operator<<(long __n);

      __ostream_type&
      operator<<(unsigned long __n);

      __ostream_type&
      operator<<(bool __n);

      __ostream_type&
      operator<<(short __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned short>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned short __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }

      __ostream_type&
      operator<<(int __n)
      {
        ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt & ios_base::oct || __fmt & ios_base::hex)
          return this->operator<<(static_cast<unsigned long>
                                  (static_cast<unsigned int>(__n)));
        else
          return this->operator<<(static_cast<long>(__n));
      }

      __ostream_type&
      operator<<(unsigned int __n)
      { return this->operator<<(static_cast<unsigned long>(__n)); }


      __ostream_type&
      operator<<(long long __n);

      __ostream_type&
      operator<<(unsigned long long __n);


      __ostream_type&
      operator<<(double __f);

      __ostream_type&
      operator<<(float __f)
      { return this->operator<<(static_cast<double>(__f)); }

      __ostream_type&
      operator<<(long double __f);

      __ostream_type&
      operator<<(const void* __p);

      __ostream_type&
      operator<<(__streambuf_type* __sb);


      __ostream_type&
      put(char_type __c);

      __ostream_type&
      write(const char_type* __s, streamsize __n);

      __ostream_type&
      flush();


      pos_type
      tellp();

      __ostream_type&
      seekp(pos_type);

      __ostream_type&
      seekp(off_type, ios_base::seekdir);
    };


  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT,_Traits>& _M_os;

    public:
      explicit
      sentry(basic_ostream<_CharT,_Traits>& __os);

      ~sentry()
      {

        if (_M_os.flags() & ios_base::unitbuf && !uncaught_exception())
          {

            if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
              _M_os.setstate(ios_base::badbit);
          }
      }

      operator bool()
      { return _M_ok; }
    };

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s);


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}





# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ostream.tcc" 1 3
# 36 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ostream.tcc" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/locale" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/locale" 3



# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 1 3
# 37 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cerrno" 1 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/cerrno" 2 3
# 39 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 2 3


# 1 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 1 3
# 48 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3



# 1 "/usr/include/math.h" 1 3 4
# 24 "/usr/include/math.h" 3 4
# 1 "/usr/include/architecture/ppc/math.h" 1 3 4
# 34 "/usr/include/architecture/ppc/math.h" 3 4
extern "C" {






typedef float float_t;
typedef double double_t;
# 55 "/usr/include/architecture/ppc/math.h" 3 4
enum {
        FP_NAN = 1,
        FP_INFINITE = 2,
        FP_ZERO = 3,
        FP_NORMAL = 4,
        FP_SUBNORMAL = 5
};
# 76 "/usr/include/architecture/ppc/math.h" 3 4
extern unsigned int __math_errhandling ( void );
# 124 "/usr/include/architecture/ppc/math.h" 3 4
extern long __fpclassifyd( double x );
extern long __fpclassifyf( float x );
extern long __fpclassify( long double x );


    inline long __fpclassify( long double x ) { return __fpclassifyd((double)( x )); }






extern long __isnormald( double x );
extern long __isnormalf( float x );
extern long __isnormal( long double x );


    inline long __isnormal( long double x ) { return __isnormald((double)( x )); }





extern long __isfinited( double x );
extern long __isfinitef( float x );
extern long __isfinite( long double x );


    inline long __isfinite( long double x ) { return __isfinited((double)( x )); }






extern long __isinfd( double x );
extern long __isinff( float x );
extern long __isinf( long double x );


    inline long __isinf( long double x ) { return __isinfd((double)( x )); }






extern long __isnand( double x );
extern long __isnanf( float x );
extern long __isnan( long double x );


    inline long __isnan( long double x ) { return __isnand((double)( x )); }






extern long __signbitd( double x );
extern long __signbitf( float x );
extern long __signbitl( long double x );


    inline long __signbitl( long double x ) { return __signbitd((double)( x )); }
# 200 "/usr/include/architecture/ppc/math.h" 3 4
extern double acos( double x );
extern double asin( double x );
extern double atan( double x );
extern double atan2( double y, double x );
extern double cos( double x );
extern double sin( double x );
extern double tan( double x );
extern double acosh( double x );
extern double asinh( double x );
extern double atanh( double x );
extern double cosh( double x );
extern double sinh( double x );
extern double tanh( double x );

extern double exp ( double x );
extern double exp2 ( double x );
extern double expm1 ( double x );
extern double log ( double x );
extern double log10 ( double x );
extern double log2 ( double x );
extern double log1p ( double x );

extern double logb ( double x );
extern float logbf ( float x );

extern double modf ( double x, double *iptr );
extern float modff ( float x, float *iptr );

extern double ldexp ( double value, int exp );
extern float ldexpf ( float value, int exp );

extern double frexp ( double value, int *eptr );
extern float frexpf ( float value, int *eptr );

extern int ilogb ( double x );
extern int ilogbf ( float x );

extern double scalbn ( double x, int n );
extern float scalbnf ( float x, int n );

extern double scalbln ( double x, long int n );
extern float scalblnf ( float x, long int n );

extern double fabs( double x );
extern float fabsf( float x );

extern double cbrt( double x );
extern double hypot ( double x, double y );
extern double pow ( double x, double y );
extern double sqrt( double x );

extern double erf( double x );
extern double erfc( double x );
extern double lgamma( double x );
extern double tgamma( double x );

extern double ceil ( double x );
extern float ceilf ( float x );

extern double floor ( double x );
extern float floorf ( float x );

extern double nearbyint ( double x );
extern float nearbyintf ( float x );

extern double rint ( double x );
extern float rintf ( float x );

extern long int lrint ( double x );
extern long int lrintf ( float x );

extern long long int llrint ( double x );
extern long long int llrintf ( float x );

extern double round ( double x );
extern float roundf ( float x );

extern long int lround ( double x );
extern long int lroundf ( float x );

extern long long int llround ( double x );
extern long long int llroundf ( float x );

extern double trunc ( double x );
extern float truncf ( float x );

extern double fmod ( double x, double y );
extern float fmodf ( float x, float y );

extern double remainder ( double x, double y );
extern float remainderf ( float x, float y );

extern double remquo ( double x, double y, int *quo );
extern float remquof ( float x, float y, int *quo );

extern double copysign ( double x, double y );
extern float copysignf ( float x, float y );

extern double nan( const char *tagp );
extern float nanf( const char *tagp );

extern double nextafter ( double x, double y );
extern float nextafterf ( float x, float y );

extern double fdim ( double x, double y );
extern float fdimf ( float x, float y );

extern double fmax ( double x, double y );
extern float fmaxf ( float x, float y );

extern double fmin ( double x, double y );
extern float fminf ( float x, float y );

extern double fma ( double x, double y, double z );
extern float fmaf ( float x, float y, float z );
# 323 "/usr/include/architecture/ppc/math.h" 3 4
extern double __inf( void );
extern float __inff( void );
extern float __nan( void );






extern long int rinttol ( double x );

extern long int roundtol ( double x );

typedef struct _complx {
        double Real;
        double Imag;
} _complex;
# 360 "/usr/include/architecture/ppc/math.h" 3 4
extern int signgam;


enum fdversion {fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix};
# 375 "/usr/include/architecture/ppc/math.h" 3 4
extern enum fdversion _fdlib_version;
# 412 "/usr/include/architecture/ppc/math.h" 3 4
extern int finite ( double x );

extern double gamma ( double x );

extern double j0 ( double x );
extern double j1 ( double x );
extern double jn ( int n, double x );

extern double y0 ( double x );
extern double y1 ( double x );
extern double yn ( int n, double x );



extern double scalb ( double x, int n );
# 435 "/usr/include/architecture/ppc/math.h" 3 4
extern double significand ( double x );




extern double cabs ( _complex z );

extern double drem ( double x, double y );
# 458 "/usr/include/architecture/ppc/math.h" 3 4
}
# 25 "/usr/include/math.h" 2 3 4
# 52 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 2 3
# 79 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
namespace std
{


  template<typename _Tp> _Tp __cmath_power(_Tp, unsigned int);

  template<typename _Tp>
  inline _Tp
    __cmath_abs(_Tp __x)
    {
      return __x < _Tp() ? -__x : __x;
    }

  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }





  inline float
  acos(float __x) { return ::acos(static_cast<double>(__x)); }


  using ::acos;





  inline long double
  acos(long double __x) { return ::acos(static_cast<double>(__x)); }


  using ::asin;





  inline float
  asin(float __x) { return ::asin(static_cast<double>(__x)); }






  inline long double
  asin(long double __x) { return ::asin(static_cast<double>(__x)); }


  using ::atan;





  inline float
  atan(float __x) { return ::atan(static_cast<double>(__x)); }






  inline long double
  atan(long double __x) { return ::atan(static_cast<double>(__x)); }


  using ::atan2;





  inline float
  atan2(float __y, float __x)
  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }






  inline long double
  atan2(long double __y, long double __x)
  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }


  using ::ceil;


  inline float
  ceil(float __x) { return ::ceilf(__x); }
# 192 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }


  using ::cos;

  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }

  using ::cosh;





  inline float
  cosh(float __x) { return ::cosh(static_cast<double>(__x)); }






  inline long double
  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }


  using ::exp;





  inline float
  exp(float __x) { return ::exp(static_cast<double>(__x)); }






  inline long double
  exp(long double __x) { return ::exp(static_cast<double>(__x)); }


  using ::fabs;

  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }

  using ::floor;


  inline float
  floor(float __x) { return ::floorf(__x); }
# 266 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  floor(long double __x) { return ::floor(static_cast<double>(__x)); }


  using ::fmod;


  inline float
  fmod(float __x, float __y) { return ::fmodf(__x, __y); }
# 285 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  fmod(long double __x, long double __y)
  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }
# 304 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  frexp(long double __x, int* __exp)
  { return ::frexp(static_cast<double>(__x), __exp); }


  using ::ldexp;


  inline float
  ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }
# 324 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  ldexp(long double __x, int __exp)
  { return ::ldexp(static_cast<double>(__x), __exp); }


  using ::log;





  inline float log(float __x)
  { return ::log(static_cast<double>(__x)); }






  inline long double
  log(long double __x) { return ::log(static_cast<double>(__x)); }


  using ::log10;





  inline float
  log10(float __x) { return ::log10(static_cast<double>(__x)); }






  inline long double
  log10(long double __x) { return ::log10(static_cast<double>(__x)); }


  using ::modf;


  inline float
  modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }
# 385 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
  inline long double
  modf(long double __x, long double* __iptr)
  {
    double __tmp;
    double __res = ::modf(static_cast<double>(__x), &__tmp);
    * __iptr = static_cast<long double>(__tmp);
    return __res;
  }


  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }

  using ::pow;





  inline float
  pow(float __x, float __y)
  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }






  inline long double
  pow(long double __x, long double __y)
  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }


  inline double
  pow(double __x, int __i)
  { return __pow_helper(__x, __i); }

  inline float
  pow(float __x, int __n)
  { return __pow_helper(__x, __n); }

  inline long double
  pow(long double __x, int __n)
  { return __pow_helper(__x, __n); }

  using ::sin;

  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }

  using ::sinh;





  inline float
  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }






  inline long double
  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }


  using ::sqrt;

  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }

  using ::tan;





  inline float
  tan(float __x) { return ::tan(static_cast<double>(__x)); }






  inline long double
  tan(long double __x) { return ::tan(static_cast<double>(__x)); }


  using ::tanh;





  inline float
  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }






  inline long double
  tanh(long double __x) { return ::tanh(static_cast<double>(__x)); }

}
# 661 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/cmath.tcc" 1 3
# 35 "/usr/include/gcc/darwin/3.1/g++-v3/bits/cmath.tcc" 3
namespace std
{
  template<typename _Tp>
    _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : 1;

      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }

      return __y;
    }
}
# 662 "/usr/include/gcc/darwin/3.1/g++-v3/cmath" 2 3
# 42 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 1 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/ppc-darwin/bits/cpu_limits.h" 1 3
# 49 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 2 3
# 887 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
namespace std
{
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };

  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };




  struct __numeric_limits_base
  {
    static const bool is_specialized = false;

    static const int digits = 0;
    static const int digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };

  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      static _Tp min() throw() { return static_cast<_Tp>(0); }
      static _Tp max() throw() { return static_cast<_Tp>(0); }
      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
      static _Tp infinity() throw() { return static_cast<_Tp>(0); }
      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };



  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool min() throw()
      { return false; }

      static bool max() throw()
      { return true; }

      static const int digits = 1;
      static const int digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true
               || true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char min() throw()
      { return (char)(-127 - 1); }
      static char max() throw()
      { return (char)127; }

      static const int digits = 7;
      static const int digits10 = 7;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return char(); }
      static char round_error() throw()
      { return char(); }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1071 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char min() throw()
      { return (-127 - 1); }
      static signed char max() throw()
      { return 127; }

      static const int digits = 7;
      static const int digits10 = 2;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1128 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return (127 * 2 + 1); }

      static const int digits = 8;
      static const int digits10 = 2;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };






  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t min() throw()
      { return (wchar_t)(-2147483647L - 1); }
      static wchar_t max() throw()
      { return (wchar_t)2147483647L; }

      static const int digits = 31;
      static const int digits10 = 9;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1241 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short min() throw()
      { return (-32767 - 1); }
      static short max() throw()
      { return 32767; }

      static const int digits = 15;
      static const int digits10 = 4;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1298 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return (32767 * 2 + 1); }

      static const int digits = 16;
      static const int digits10 = 4;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };






  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int min() throw()
      { return (int)(-2147483647L - 1); }
      static int max() throw()
      { return (int)2147483647L; }

      static const int digits = 31;
      static const int digits10 = 9;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1410 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int min() throw()
      { return 0; }
          static unsigned int max() throw()
      { return (unsigned)(2147483647L * 2U + 1); }

      static const int digits = 32;
      static const int digits10 = 9;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };






  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long min() throw()
      { return (-2147483647L - 1); }
      static long max() throw()
      { return 2147483647L; }

      static const int digits = 31;
      static const int digits10 = 9;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1522 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return (2147483647L * 2U + 1); }

      static const int digits = 32;
      static const int digits10 = 9;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };






  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long min() throw()
      { return (-9223372036854775807LL - 1); }
      static long long max() throw()
      { return 9223372036854775807LL; }

      static const int digits = 63;
      static const int digits10 = 18;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1634 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return (9223372036854775807LL * 2ULL + 1); }

      static const int digits = 64;
      static const int digits10 = 19;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = true;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };






  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float min() throw()
      { return 1.17549435e-38F; }
      static float max() throw()
      { return 3.40282347e+38F; }

      static const int digits = 24;
      static const int digits10 = 6;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209290e-07F; }
      static float round_error() throw()
      { return 1.0F; }

      static const int min_exponent = -125;
      static const int min_exponent10 = -37;
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;

      static float infinity() throw()
      { return 0.0F; }
      static float quiet_NaN() throw()
      { return 0.0F; }
      static float signaling_NaN() throw()
      { return 0.0F; }
      static float denorm_min() throw()
      { return 0.0F; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
# 1765 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double min() throw()
      { return 2.2250738585072014e-308; }
      static double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static double round_error() throw()
      { return 1.0; }

      static const int min_exponent = -1021;
      static const int min_exponent10 = -307;
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm =
              denorm_absent;
      static const bool has_denorm_loss = false;

      static double infinity() throw()
      { return 0.0; }
      static double quiet_NaN() throw()
      { return 0.0; }
      static double signaling_NaN() throw()
      { return 0.0; }
      static double denorm_min() throw()
      { return 0.0; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style =
              round_toward_zero;
    };
# 1844 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double min() throw()
      { return 2.2250738585072014e-308; }
      static long double max() throw()
      { return 1.7976931348623157e+308; }

      static const int digits = 53;
      static const int digits10 = 15;
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 2.2204460492503131e-16; }
      static long double round_error() throw()
      { return 1.0; }

      static const int min_exponent = -1021;
      static const int min_exponent10 = -307;
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN =
                false;
      static const float_denorm_style has_denorm =
                denorm_absent;
      static const bool has_denorm_loss =
                false;

      static long double infinity() throw()
      { return 0.0L; }
      static long double quiet_NaN() throw()
      { return 0.0L; }
      static long double signaling_NaN() throw()
      { return 0.0L; }
      static long double denorm_min() throw()
      { return 0.0L; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style =
        round_toward_zero;
    };
# 1924 "/usr/include/gcc/darwin/3.1/g++-v3/limits" 3
}
# 44 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 2 3

# 1 "/usr/include/gcc/darwin/3.1/g++-v3/typeinfo" 1 3
# 40 "/usr/include/gcc/darwin/3.1/g++-v3/typeinfo" 3
extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 55 "/usr/include/gcc/darwin/3.1/g++-v3/typeinfo" 3
namespace std
{



  class type_info
  {
  public:




    virtual ~type_info();

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);

  protected:
    const char *__name;

  protected:
    explicit type_info(const char *__n): __name(__n) { }

  public:



    const char* name() const
    { return __name; }


    bool before(const type_info& __arg) const;



    bool operator==(const type_info& __arg) const;
# 103 "/usr/include/gcc/darwin/3.1/g++-v3/typeinfo" 3
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }


  public:

    virtual bool __is_pointer_p() const;

    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
                            unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
                             void **__obj_ptr) const;
  };



  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }


    virtual ~bad_cast() throw();
  };


  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }


    virtual ~bad_typeid() throw();
  };
}

}
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 2 3

namespace std
{
  template<typename _Facet>
    locale
    locale::combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
                                __s2.data(), __s2.data() + __s2.length()) < 0);
    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      if (!(__i < __loc._M_impl->_M_facets_size && __facets[__i]))
        __throw_bad_cast();
      return static_cast<const _Facet&>(*__facets[__i]);
    }

  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      size_t __i = _Facet::id._M_id();
      locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size && __facets[__i]);
    }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
                     ios_base::iostate& __err, string& __xtrc) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      const char_type __plus = __ctype.widen('+');
      const char_type __minus = __ctype.widen('-');
      int __pos = 0;
      char_type __c = *__beg;
      if ((__c == __plus || __c == __minus) && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);
      bool __found_zero = false;
      while (__c == __zero && __beg != __end)
        {
          __c = *(++__beg);
          __found_zero = true;
        }
      if (__found_zero)
        {
          __xtrc += _S_atoms[_M_zero];
          ++__pos;
        }


      const size_t __len = _M_E - _M_zero + 1;
      char_type __watoms[__len];
      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);
      bool __found_dec = false;
      bool __found_sci = false;
      const char_type __dec = __np.decimal_point();

      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();

      while (__beg != __end)
        {

          typedef char_traits<_CharT> __traits_type;
          const char_type* __p = __traits_type::find(__watoms, 10, __c);


          if (__p && __c)
            {

              ++__pos;
              __xtrc += _S_atoms[__p - __watoms];
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__c == __sep && __check_grouping && !__found_dec)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else if (__c == __dec && !__found_dec)
            {



              if (__found_grouping.size())
                __found_grouping += static_cast<char>(__sep_pos);
              ++__pos;
              __xtrc += '.';
              __c = *(++__beg);
              __found_dec = true;
            }
          else if ((__c == __watoms[_M_e] || __c == __watoms[_M_E])
                   && !__found_sci && __pos)
            {

              ++__pos;
              __xtrc += __ctype.narrow(__c, char());
              __c = *(++__beg);


              if (__c == __plus || __c == __minus)
                {
                  ++__pos;
                  __xtrc += __ctype.narrow(__c, char());
                  __c = *(++__beg);
                }
              __found_sci = true;
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          if (!__found_dec)
            __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
                   ios_base::iostate& __err, string& __xtrc, int& __base) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);


      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
      if (__basefield == ios_base::oct)
        __base = 8;
      else if (__basefield == ios_base::hex)
        __base = 16;
      else
        __base = 10;


      int __pos = 0;
      char_type __c = *__beg;
      if ((__c == __ctype.widen('+') || __c == __ctype.widen('-'))
          && __beg != __end)
        {
          __xtrc += __ctype.narrow(__c, char());
          ++__pos;
          __c = *(++__beg);
        }


      const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);
      const char_type __x = __ctype.widen('x');
      const char_type __X = __ctype.widen('X');
      if (__base == 10)
        {
          bool __found_zero = false;
          while (__c == __zero && __beg != __end)
            {
              __c = *(++__beg);
              __found_zero = true;
            }
          if (__found_zero)
            {
              __xtrc += _S_atoms[_M_zero];
              ++__pos;
              if (__basefield == 0)
                {
                  if ((__c == __x || __c == __X) && __beg != __end)
                    {
                      __xtrc += __ctype.narrow(__c, char());
                      ++__pos;
                      __c = *(++__beg);
                      __base = 16;
                    }
                  else
                    __base = 8;
                }
            }
        }
      else if (__base == 16)
        {
          if (__c == __zero && __beg != __end)
            {
              __xtrc += _S_atoms[_M_zero];
              ++__pos;
              __c = *(++__beg);
              if ((__c == __x || __c == __X) && __beg != __end)
                {
                  __xtrc += __ctype.narrow(__c, char());
                  ++__pos;
                  __c = *(++__beg);
                }
            }
        }



      size_t __len;
      if (__base == 16)
        __len = _M_size;
      else
        __len = __base;


      char_type __watoms[_M_size];
      __ctype.widen(_S_atoms, _S_atoms + __len, __watoms);
      string __found_grouping;
      const string __grouping = __np.grouping();
      bool __check_grouping = __grouping.size();
      int __sep_pos = 0;
      const char_type __sep = __np.thousands_sep();
      while (__beg != __end)
        {
          typedef char_traits<_CharT> __traits_type;
          const char_type* __p = __traits_type::find(__watoms, __len, __c);


          if (__p && __c)
            {

              __xtrc += _S_atoms[__p - __watoms];
              ++__pos;
              ++__sep_pos;
              __c = *(++__beg);
            }
          else if (__c == __sep && __check_grouping)
            {


              if (__sep_pos)
                {
                  __found_grouping += static_cast<char>(__sep_pos);
                  __sep_pos = 0;
                  __c = *(++__beg);
                }
              else
                {
                  __err |= ios_base::failbit;
                  break;
                }
            }
          else

            break;
        }



      if (__check_grouping && __found_grouping.size())
        {

          __found_grouping += static_cast<char>(__sep_pos);
          if (!__verify_grouping(__grouping, __found_grouping))
            __err |= ios_base::failbit;
        }


      __xtrc += char();
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {

      if (!(__io.flags() & ios_base::boolalpha))
        {


          string __xtrc;
          int __base;
          __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);

          unsigned long __ul;
          __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
          if (!(__err & ios_base::failbit) && __ul <= 1)
            __v = __ul;
          else
            __err |= ios_base::failbit;
        }


      else
        {
          typedef basic_string<_CharT> __string_type;
          locale __loc = __io.getloc();
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          const __string_type __true = __np.truename();
          const __string_type __false = __np.falsename();
          const char_type* __trues = __true.c_str();
          const char_type* __falses = __false.c_str();
          const size_t __truen = __true.size() - 1;
          const size_t __falsen = __false.size() - 1;

          for (size_t __n = 0; __beg != __end; ++__n)
            {
              char_type __c = *__beg++;
              bool __testf = __n <= __falsen ? __c == __falses[__n] : false;
              bool __testt = __n <= __truen ? __c == __trues[__n] : false;
              if (!(__testf || __testt))
                {
                  __err |= ios_base::failbit;
                  break;
                }
              else if (__testf && __n == __falsen)
                {
                  __v = 0;
                  break;
                }
              else if (__testt && __n == __truen)
                {
                  __v = 1;
                  break;
                }
            }
          if (__beg == __end)
            __err |= ios_base::eofbit;
        }
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned short& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned short>::max())
        __v = static_cast<unsigned short>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned int& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit)
          && __ul <= numeric_limits<unsigned int>::max())
        __v = static_cast<unsigned int>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, unsigned long long& __v) const
    {
      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale, __base);
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      __convert_to_v(__xtrc.c_str(), __v, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      fmtflags __fmt = __io.flags();
      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield
                             | ios_base::uppercase | ios_base::internal);
      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));

      string __xtrc;
      int __base;
      __beg = _M_extract_int(__beg, __end, __io, __err, __xtrc, __base);


      __io.flags(__fmt);

      unsigned long __ul;
      __convert_to_v(__xtrc.c_str(), __ul, __err, _S_c_locale, __base);
      if (!(__err & ios_base::failbit))
        __v = reinterpret_cast<void*>(__ul);
      else
        __err |= ios_base::failbit;
      return __beg;
    }
# 604 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                       _ValueT __v) const
      {


        const int __max_digits = numeric_limits<_ValueT>::digits10 + 1;
        streamsize __prec = __io.precision();

        if (__prec > static_cast<streamsize>(__max_digits))
          __prec = static_cast<streamsize>(__max_digits);


        char __fbuf[16];


        int __len;
# 651 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
        const bool __fixed = __io.flags() & ios_base::fixed;
        const int __max_exp = numeric_limits<_ValueT>::max_exponent10;





        const int __cs_size = __fixed ? __max_exp + __max_digits + 4
                                      : __max_digits * 3;
        char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));

        if (_S_format_float(__io, __fbuf, __mod, __prec))
          __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale, __prec);
        else
          __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale);

        return _M_widen_float(__s, __io, __fill, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_convert_int(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
                     char __modl, _ValueT __v) const
      {



        char __fbuf[16];
        _S_format_int(__io, __fbuf, __mod, __modl);
# 699 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
        char __cs[128];
        int __len = __convert_from_v(__cs, 0, __fbuf, __v, _S_c_locale);

        return _M_widen_int(__s, __io, __fill, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                   int __len) const
    {


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const _CharT* __p;
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      if (__p = char_traits<_CharT>::find(__ws, __len, __ctype.widen('.')))
        __ws[__p - __ws] = __np.decimal_point();




      const string __grouping = __np.grouping();
      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
      if (__grouping.size())
        {
          _CharT* __p2;
          int __declen = __p ? __p - __ws : __len;
          __p2 = __add_grouping(__ws2, __np.thousands_sep(),
                                __grouping.c_str(),
                                __grouping.c_str() + __grouping.size(),
                                __ws, __ws + __declen);
          int __newlen = __p2 - __ws2;


          if (__p)
            {
              char_traits<_CharT>::copy(__p2, __p, __len - __declen);
              __newlen += __len - __declen;
            }


          __ws = __ws2;
          __len = __newlen;
        }

      return _M_insert(__s, __io, __fill, __ws, __len);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_widen_int(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs,
                 int __len) const
    {


      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                           * __len));


      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __len * 2));
      __ctype.widen(__cs, __cs + __len, __ws);


      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      const string __grouping = __np.grouping();
      const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
      if (__grouping.size())
        {



          streamsize __off = 0;
          if (__io.flags() & ios_base::showbase)
            if (__basefield == ios_base::oct)
              {
                __off = 1;
                *__ws2 = *__ws;
              }
            else if (__basefield == ios_base::hex)
              {
                __off = 2;
                *__ws2 = *__ws;
                *(__ws2 + 1) = *(__ws + 1);
              }
          _CharT* __p;
          __p = __add_grouping(__ws2 + __off, __np.thousands_sep(),
                               __grouping.c_str(),
                               __grouping.c_str() + __grouping.size(),
                               __ws + __off, __ws + __len);
          __len = __p - __ws2;

          __ws = __ws2;
        }
      return _M_insert(__s, __io, __fill, __ws, __len);
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws,
              int __len) const
    {

      streamsize __w = __io.width();
      _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
                                                            * __w));
      if (__w > static_cast<streamsize>(__len))
        {
          __pad(__io, __fill, __ws2, __ws, __w, __len, true);
          __len = static_cast<int>(__w);

          __ws = __ws2;
        }
      __io.width(0);



      for (int __j = 0; __j < __len; ++__j, ++__s)
        *__s = __ws[__j];
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          unsigned long __uv = __v;
          __s = _M_convert_int(__s, __io, __fill, 'u', char_type(), __uv);
        }
      else
        {
          typedef basic_string<_CharT> __string_type;
          locale __loc = __io.getloc();
          const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
          __string_type __name;
          if (__v)
            __name = __np.truename();
          else
            __name = __np.falsename();
          __s = _M_insert(__s, __io, __fill, __name.c_str(), __name.size());
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
    { return _M_convert_int(__s, __io, __fill, 'd', char_type(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long __v) const
    { return _M_convert_int(__s, __io, __fill, 'u', char_type(), __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const
    { return _M_convert_int(__s, __b, __fill, 'd', 'l', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           unsigned long long __v) const
    { return _M_convert_int(__s, __io, __fill, 'u', 'l', __v); }


  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_convert_float(__s, __io, __fill, char_type(), __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           long double __v) const
    { return _M_convert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      ios_base::fmtflags __flags = __io.flags();
      ios_base::fmtflags __fmt = ~(ios_base::showpos | ios_base::basefield
                                   | ios_base::uppercase | ios_base::internal);
      __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));
      try
        {
          __s = _M_convert_int(__s, __io, __fill, 'u', char_type(),
                               reinterpret_cast<unsigned long>(__v));
          __io.flags(__flags);
        }
      catch (...)
        {
          __io.flags(__flags);
          throw;
        }
      return __s;
    }


  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, long double& __units) const
    {
      string_type __str;
      __beg = this->do_get(__beg, __end, __intl, __io, __err, __str);

      const int __n = numeric_limits<long double>::digits10;
      char* __cs = static_cast<char*>(__builtin_alloca(__n));
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const _CharT* __wcs = __str.c_str();
      __ctype.narrow(__wcs, __wcs + __str.size() + 1, char(), __cs);
      __convert_to_v(__cs, __units, __err, _S_c_locale);
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
           ios_base::iostate& __err, string_type& __units) const
    {

      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      typedef money_base::part part;
      typedef typename string_type::size_type size_type;

      const locale __loc = __io.getloc();
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      const money_base::pattern __p = __intl ? __mpt.neg_format()
                                             : __mpf.neg_format();

      const string_type __pos_sign =__intl ? __mpt.positive_sign()
                                           : __mpf.positive_sign();
      const string_type __neg_sign =__intl ? __mpt.negative_sign()
                                           : __mpf.negative_sign();
      const char_type __d = __intl ? __mpt.decimal_point()
                                   : __mpf.decimal_point();
      const char_type __sep = __intl ? __mpt.thousands_sep()
                                     : __mpf.thousands_sep();

      const string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();


      string_type __sign;

      string __grouping_tmp;

      int __sep_pos = 0;

      bool __testvalid = true;

      bool __testdecfound = false;


      string_type __temp_units;

      char_type __c = *__beg;
      char_type __eof = static_cast<char_type>(char_traits<char_type>::eof());
      for (int __i = 0; __beg != __end && __i < 4 && __testvalid; ++__i)
        {
          part __which = static_cast<part>(__p.field[__i]);
          switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase
                      || __i < 2 || __sign.size() > 1
                      || ((static_cast<part>(__p.field[3]) != money_base::none)
                          && __i == 2))
                    {





                      const string_type __symbol = __intl ? __mpt.curr_symbol()
                                                         : __mpf.curr_symbol();
                      size_type __len = __symbol.size();
                      size_type __j = 0;
                      while (__beg != __end
                             && __j < __len && __symbol[__j] == __c)
                        {
                          __c = *(++__beg);
                          ++__j;
                        }


                      if (__j != __len && (__io.flags() & ios_base::showbase))
                        __testvalid = false;
                    }
                  break;
                case money_base::sign:

                  if (__pos_sign.size() && __neg_sign.size())
                  {

                    if (__c == __pos_sign[0])
                      {
                        __sign = __pos_sign;
                        __c = *(++__beg);
                      }
                    else if (__c == __neg_sign[0])
                      {
                        __sign = __neg_sign;
                        __c = *(++__beg);
                      }
                    else
                      __testvalid = false;
                  }
                  else if (__pos_sign.size() && __c == __pos_sign[0])
                    {
                      __sign = __pos_sign;
                      __c = *(++__beg);
                    }
                  else if (__neg_sign.size() && __c == __neg_sign[0])
                    {
                      __sign = __neg_sign;
                      __c = *(++__beg);
                    }
                  break;
                case money_base::value:


                  while (__beg != __end
                         && (__ctype.is(ctype_base::digit, __c)
                             || (__c == __d && !__testdecfound)
                             || __c == __sep))
                    {
                      if (__c == __d)
                        {
                          __grouping_tmp += static_cast<char>(__sep_pos);
                          __sep_pos = 0;
                          __testdecfound = true;
                        }
                      else if (__c == __sep)
                        {
                          if (__grouping.size())
                            {

                              __grouping_tmp += static_cast<char>(__sep_pos);
                              __sep_pos = 0;
                            }
                          else
                            {
                              __testvalid = false;
                              break;
                            }
                        }
                      else
                        {
                          __temp_units += __c;
                          ++__sep_pos;
                        }
                      __c = *(++__beg);
                    }
                  break;
                case money_base::space:
                case money_base::none:

                  if (__i != 3)
                    while (__beg != __end
                           && __ctype.is(ctype_base::space, __c))
                      __c = *(++__beg);
                  break;
                }
        }


      if (__sign.size() > 1)
        {
          size_type __len = __sign.size();
          size_type __i = 1;
          for (; __c != __eof && __i < __len; ++__i)
            while (__beg != __end && __c != __sign[__i])
              __c = *(++__beg);

          if (__i != __len)
            __testvalid = false;
        }


      while (__temp_units[0] == __ctype.widen('0'))
        __temp_units.erase(__temp_units.begin());

      if (__sign.size() && __sign == __neg_sign)
        __temp_units.insert(__temp_units.begin(), __ctype.widen('-'));


      if (__grouping.size() && __grouping_tmp.size())
        {
          if (!__verify_grouping(__grouping, __grouping_tmp))
            __testvalid = false;
        }


      if (__c == __eof)
        __err |= ios_base::eofbit;


      if (!__testvalid || !__temp_units.size())
        __err |= ios_base::failbit;
      else

        __temp_units.swap(__units);

      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
# 1171 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
      const int __cs_size = numeric_limits<long double>::max_exponent10 + 5;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = __convert_from_v(__cs, 0, "%.01Lf", __units, _S_c_locale);

      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __cs_size));
      __ctype.widen(__cs, __cs + __len, __ws);
      string_type __digits(__ws);
      return this->do_put(__s, __intl, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
           const string_type& __digits) const
    {
      typedef typename string_type::size_type size_type;
      typedef money_base::part part;

      const locale __loc = __io.getloc();
      const size_type __width = static_cast<size_type>(__io.width());


      typedef moneypunct<_CharT, true> __money_true;
      typedef moneypunct<_CharT, false> __money_false;
      const __money_true& __mpt = use_facet<__money_true>(__loc);
      const __money_false& __mpf = use_facet<__money_false>(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);



      const char_type* __beg = __digits.data();
      const char_type* __end = __beg + __digits.size();
      money_base::pattern __p;
      string_type __sign;
      if (*__beg != __ctype.widen('-'))
        {
          __p = __intl ? __mpt.pos_format() : __mpf.pos_format();
          __sign =__intl ? __mpt.positive_sign() : __mpf.positive_sign();
        }
      else
        {
          __p = __intl ? __mpt.neg_format() : __mpf.neg_format();
          __sign =__intl ? __mpt.negative_sign() : __mpf.negative_sign();
          ++__beg;
        }


      __end = __ctype.scan_not(ctype_base::digit, __beg, __end);
      if (__beg != __end)
        {



          string_type __res;
          string_type __value;
          const string_type __symbol = __intl ? __mpt.curr_symbol()
                                              : __mpf.curr_symbol();


          const int __frac = __intl ? __mpt.frac_digits()
                                    : __mpf.frac_digits();
          if (__frac > 0)
            {
              const char_type __d = __intl ? __mpt.decimal_point()
                                           : __mpf.decimal_point();
              if (__end - __beg >= __frac)
                {
                  __value = string_type(__end - __frac, __end);
                  __value.insert(__value.begin(), __d);
                  __end -= __frac;
                }
              else
                {

                  __value = string_type(__beg, __end);
                  int __paddec = __frac - (__end - __beg);
                  char_type __zero = __ctype.widen('0');
                  __value.insert(__value.begin(), __paddec, __zero);
                  __value.insert(__value.begin(), __d);
                  __beg = __end;
                }
            }



          if (__beg != __end)
            {
              const string __grouping = __intl ? __mpt.grouping()
                                               : __mpf.grouping();
              if (__grouping.size())
                {
                  const char_type __sep = __intl ? __mpt.thousands_sep()
                                                 : __mpf.thousands_sep();
                  const char* __gbeg = __grouping.c_str();
                  const char* __gend = __gbeg + __grouping.size();
                  const int __n = (__end - __beg) * 2;
                  _CharT* __ws2 =
                    static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));
                  _CharT* __ws_end = __add_grouping(__ws2, __sep, __gbeg,
                                                    __gend, __beg, __end);
                  __value.insert(0, __ws2, __ws_end - __ws2);
                }
              else
                __value.insert(0, string_type(__beg, __end));
            }


          ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;
          size_type __len = __value.size() + __sign.size();
          __len += (__io.flags() & ios_base::showbase) ? __symbol.size() : 0;
          bool __testipad = __f == ios_base::internal && __len < __width;


          for (int __i = 0; __i < 4; ++__i)
            {
              part __which = static_cast<part>(__p.field[__i]);
              switch (__which)
                {
                case money_base::symbol:
                  if (__io.flags() & ios_base::showbase)
                    __res += __symbol;
                  break;
                case money_base::sign:



                  if (__sign.size())
                    __res += __sign[0];
                  break;
                case money_base::value:
                  __res += __value;
                  break;
                case money_base::space:



                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  else
                    __res += __ctype.widen(__fill);
                  break;
                case money_base::none:
                  if (__testipad)
                    __res += string_type(__width - __len, __fill);
                  break;
                }
            }


          if (__sign.size() > 1)
            __res += string_type(__sign.begin() + 1, __sign.end());


          __len = __res.size();
          if (__width > __len)
            {
              if (__f == ios_base::left)

                __res.append(__width - __len, __fill);
              else

                __res.insert(0, string_type(__width - __len, __fill));
              __len = __width;
            }


          for (size_type __j = 0; __j < __len; ++__j, ++__s)
            *__s = __res[__j];
        }
      __io.width(0);
      return __s;
    }





  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type& __beg, iter_type& __end, ios_base& __io,
                          ios_base::iostate& __err, tm* __tm,
                          const _CharT* __format) const
    {
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      size_t __len = char_traits<_CharT>::length(__format);

      for (size_t __i = 0; __beg != __end && __i < __len && !__err; ++__i)
        {
          char __c = __format[__i];
          if (__c == '%')
            {

              __c = __format[++__i];
              char __mod = 0;
              int __mem = 0;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __c = __format[++__i];
                }
              switch (__c)
                {
                  const char* __cs;
                  _CharT __wcs[10];
                case 'a':

                  const char_type* __days1[7];
                  __tp._M_days_abbreviated(__days1);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days1, 7,
                                  __err);
                  break;
                case 'A':

                  const char_type* __days2[7];
                  __tp._M_days(__days2);
                  _M_extract_name(__beg, __end, __tm->tm_wday, __days2, 7,
                                  __err);
                  break;
                case 'h':
                case 'b':

                  const char_type* __months1[12];
                  __tp._M_months_abbreviated(__months1);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months1, 12,
                                  __err);
                  break;
                case 'B':

                  const char_type* __months2[12];
                  __tp._M_months(__months2);
                  _M_extract_name(__beg, __end, __tm->tm_mon, __months2, 12,
                                  __err);
                  break;
                case 'c':

                  const char_type* __dt[2];
                  __tp._M_date_time_formats(__dt);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dt[0]);
                  break;
                case 'd':

                  _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
                                 __ctype, __err);
                  break;
                case 'D':

                  __cs = "%m/%d/%y";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'H':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
                                 __ctype, __err);
                  break;
                case 'I':

                  _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
                                 __ctype, __err);
                  break;
                case 'm':

                  _M_extract_num(__beg, __end, __mem, 1, 12, 2, __ctype,
                                 __err);
                  if (!__err)
                    __tm->tm_mon = __mem - 1;
                  break;
                case 'M':

                  _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 'n':
                  if (__ctype.narrow(*__beg, 0) == '\n')
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                  break;
                case 'R':

                  __cs = "%H:%M";
                  __ctype.widen(__cs, __cs + 6, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'S':

                  _M_extract_num(__beg, __end, __tm->tm_sec, 0, 59, 2,
                                 __ctype, __err);
                  break;
                case 't':
                  if (__ctype.narrow(*__beg, 0) == '\t')
                    ++__beg;
                  else
                __err |= ios_base::failbit;
                  break;
                case 'T':

                  __cs = "%H:%M:%S";
                  __ctype.widen(__cs, __cs + 9, __wcs);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __wcs);
                  break;
                case 'x':

                  const char_type* __dates[2];
                  __tp._M_date_formats(__dates);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __dates[0]);
                  break;
                case 'X':

                  const char_type* __times[2];
                  __tp._M_time_formats(__times);
                  _M_extract_via_format(__beg, __end, __io, __err, __tm,
                                        __times[0]);
                  break;
                case 'y':

                  _M_extract_num(__beg, __end, __tm->tm_year, 0, 99, 2,
                                 __ctype, __err);
                  break;
                case 'Y':

                  _M_extract_num(__beg, __end, __mem, 0,
                                 numeric_limits<int>::max(), 4,
                                 __ctype, __err);
                  if (!__err)
                    __tm->tm_year = __mem - 1900;
                  break;
                case 'Z':

                  if (__ctype.is(ctype_base::upper, *__beg))
                    {
                      int __tmp;
                      _M_extract_name(__beg, __end, __tmp,
                                      __timepunct<_CharT>::_S_timezones,
                                      14, __err);


                      char_type __c = *__beg;
                      if (!__err && __tmp == 0
                          && (__c == __ctype.widen('-')
                              || __c == __ctype.widen('+')))
                        {
                          _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
                                          __ctype, __err);
                          _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
                                          __ctype, __err);
                        }
                          }
                      else
                        __err |= ios_base::failbit;
                      break;
                    default:

                      __err |= ios_base::failbit;
                    }
                }
              else
                {

                  if (__c == __ctype.narrow(*__beg, 0))
                    ++__beg;
                  else
                    __err |= ios_base::failbit;
                }
        }
    }

  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type& __beg, iter_type& __end, int& __member,
                   int __min, int __max, size_t __len,
                   const ctype<_CharT>& __ctype,
                   ios_base::iostate& __err) const
    {
      size_t __i = 0;
      string __digits;
      bool __testvalid = true;
      char_type __c = *__beg;
      while (__beg != __end && __i < __len
             && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == __len)
        {
          int __value = atoi(__digits.c_str());
          if (__min <= __value && __value <= __max)
            __member = __value;
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }



  template<typename _CharT, typename _InIter>
    void
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type& __beg, iter_type& __end, int& __member,
                    const _CharT** __names, size_t __indexlen,
                    ios_base::iostate& __err) const
    {
      typedef char_traits<char_type> __traits_type;
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int) * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;

      char_type __c = *__beg;

      for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
        if (__c == __names[__i1][0])
          __matches[__nmatches++] = __i1;

      while(__nmatches > 1)
        {

          size_t __minlen = 10;
          for (size_t __i2 = 0; __i2 < __nmatches; ++__i2)
            __minlen = min(__minlen,
                           __traits_type::length(__names[__matches[__i2]]));

          if (__pos < __minlen && __beg != __end)
            {
              ++__pos;
              __c = *(++__beg);
              for (size_t __i3 = 0; __i3 < __nmatches; ++__i3)
                {
                  __name = __names[__matches[__i3]];
                  if (__name[__pos] != __c)
                    __matches[__i3] = __matches[--__nmatches];
                }
            }
          else
            break;
        }

      if (__nmatches == 1)
        {

          __name = __names[__matches[0]];
          const size_t __len = __traits_type::length(__name);
          while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
            ++__beg, ++__pos;

          if (__len == __pos)
            __member = __matches[0];
          else
            __testvalid = false;
        }
      else
        __testvalid = false;
      if (!__testvalid)
        __err |= ios_base::failbit;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%X";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      _CharT __wcs[3];
      const char* __cs = "%x";
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __ctype.widen(__cs, __cs + 3, __wcs);
      _M_extract_via_format(__beg, __end, __io, __err, __tm, __wcs);
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
                   ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<char_type> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __days[7];
      __tp._M_days_abbreviated(__days);
      int __tmpwday;
      _M_extract_name(__beg, __end, __tmpwday, __days, 7, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__days[__tmpwday]);
          __tp._M_days(__days);
          const char_type* __name = __days[__tmpwday];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_wday = __tmpwday;
        }
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<char_type> __traits_type;
      locale __loc = __io.getloc();
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __months[12];
      __tp._M_months_abbreviated(__months);
      int __tmpmon;
      _M_extract_name(__beg, __end, __tmpmon, __months, 12, __err);







      if (!__err)
        {
          size_t __pos = __traits_type::length(__months[__tmpmon]);
          __tp._M_months(__months);
          const char_type* __name = __months[__tmpmon];
          if (__name[__pos] == *__beg)
            {

              const size_t __len = __traits_type::length(__name);
              while (__pos < __len && __beg != __end
                     && __name[__pos] == *__beg)
                ++__beg, ++__pos;
              if (__len != __pos)
                __err |= ios_base::failbit;
            }
          if (!__err)
            __tm->tm_mon = __tmpmon;
        }

      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
                ios_base::iostate& __err, tm* __tm) const
    {
      locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      char_type __c = *__beg;
      size_t __i = 0;
      string __digits;
      while (__i < 4 && __beg != __end && __ctype.is(ctype_base::digit, __c))
        {
          __digits += __ctype.narrow(__c, 0);
          __c = *(++__beg);
          ++__i;
        }
      if (__i == 2 || __i == 4)
        {
          long __l;
          __convert_to_v(__digits.c_str(), __l, __err, _S_c_locale);
          if (!(__err & ios_base::failbit) && __l <= 2147483647)
            {
              __l = __i == 2 ? __l : __l - 1900;
              __tm->tm_year = static_cast<int>(__l);
            }
        }
      else
        __err |= ios_base::failbit;
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
        const _CharT* __beg, const _CharT* __end) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      while (__beg != __end)
        {
          char __c = __ctype.narrow(*__beg, 0);
          ++__beg;
          if (__c == '%')
            {
              char __format;
              char __mod = 0;
              size_t __len = 1;
              __c = __ctype.narrow(*__beg, 0);
              ++__beg;
              if (__c == 'E' || __c == 'O')
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__beg, 0);
                  ++__beg;
                }
              else
                __format = __c;
              __s = this->do_put(__s, __io, char_type(), __tm, __format,
                                 __mod);
            }
          else
            {
              *__s = __c;
              ++__s;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
           char __format, char __mod) const
    {
      locale __loc = __io.getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 64;
      char_type* __res =
        static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __maxlen));






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      size_t __len = char_traits<char_type>::length(__res);
      for (size_t __i = 0; __i < __len; ++__i, ++__s)
        *__s = __res[__i];
      return __s;
    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
               const _CharT* __lo2, const _CharT* __hi2) const
    {
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);
      return _M_compare(__one.c_str(), __two.c_str());
    }

 template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      size_t __len = (__hi - __lo) * 2;

      _CharT* __c =
        static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __len));
      size_t __res = _M_transform(__c, __lo, __len);

      if (__res >= __len)
        {
          __c =
            static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__res + 1)));
          _M_transform(__c, __lo, __res + 1);
        }
      return string_type(__c);
    }

 template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
        __val = *__lo + ((__val << 7) |
                       (__val >> (numeric_limits<unsigned long>::digits - 7)));
      return static_cast<long>(__val);
    }




  template<typename _Tv>
    void
    __convert_to_v(const char* __in, _Tv& __out, ios_base::iostate& __err,
                   const __c_locale& __cloc, int __base = 10);
# 1971 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
  template<typename _Tv>
    int
    __convert_from_v(char* __out, const int, const char* __fmt, _Tv __v,
                     const __c_locale&, int __prec = -1)
    {
      int __ret;
      const char* __old = setlocale(0, "C");
      if (__prec >= 0)
        __ret = sprintf(__out, __fmt, __prec, __v);
      else
        __ret = sprintf(__out, __fmt, __v);
      setlocale(0, __old);
      return __ret;
    }
# 1995 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,
          const streamsize __newlen, const streamsize __oldlen,
          const bool __num)
    {
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;

      int_type __plen = static_cast<size_t>(__newlen - __oldlen);
      char_type* __pads = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __plen));
      traits_type::assign(__pads, __plen, __fill);

      char_type* __beg;
      char_type* __end;
      size_t __mod = 0;
      size_t __beglen;
      ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;

      if (__adjust == ios_base::left)
        {

          __beg = const_cast<char_type*>(__olds);
          __beglen = __oldlen;
          __end = __pads;
        }
      else if (__adjust == ios_base::internal && __num)
        {



          locale __loc = __io.getloc();
          const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
          const char_type __minus = __ctype.widen('-');
          const char_type __plus = __ctype.widen('+');
          bool __testsign = __olds[0] == __minus || __olds[0] == __plus;
          bool __testhex = __ctype.widen('0') == __olds[0]
                           && (__ctype.widen('x') == __olds[1]
                               || __ctype.widen('X') == __olds[1]);
          if (__testhex)
            {
              __news[0] = __olds[0];
              __news[1] = __olds[1];
              __mod += 2;
              __news += 2;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<char_type*>(__olds + __mod);
            }
          else if (__testsign)
            {
              __news[0] = __olds[0] == __plus ? __plus : __minus;
              ++__mod;
              ++__news;
              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<char_type*>(__olds + __mod);
            }
          else
            {

              __beg = __pads;
              __beglen = __plen;
              __end = const_cast<char_type*>(__olds);
            }
        }
      else
        {

          __beg = __pads;
          __beglen = __plen;
          __end = const_cast<char_type*>(__olds);
        }
      traits_type::copy(__news, __beg, __beglen);
      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);
    }




  template<typename _CharT>
    void
    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,
          const streamsize __newlen, const streamsize __oldlen,
          const bool __num)
    {
      return __pad<_CharT, char_traits<_CharT> >(__io, __fill, __news, __olds,
                                                 __newlen, __oldlen, __num);
    }
# 2094 "/usr/include/gcc/darwin/3.1/g++-v3/bits/locale_facets.tcc" 3
  template<typename _CharT>
    bool
    __verify_grouping(const basic_string<_CharT>& __grouping,
                      basic_string<_CharT>& __grouping_tmp)
    {
      int __i = 0;
      int __j = 0;
      const int __len = __grouping.size();
      const int __n = __grouping_tmp.size();
      bool __test = true;




      while (__test && __i < __n - 1)
        for (__j = 0; __test && __j < __len && __i < __n - 1; ++__j,++__i)
          __test &= __grouping[__j] == __grouping_tmp[__n - __i - 1];


      __j == __len ? __j = 0 : __j;
      __test &= __grouping[__j] >= __grouping_tmp[__n - __i - 1];
      return __test;
    }






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
                   const char* __gbeg, const char* __gend,
                   const _CharT* __first, const _CharT* __last)
    {
      if (__last - __first > *__gbeg)
        {
          __s = __add_grouping(__s, __sep,
                               (__gbeg + 1 == __gend ? __gbeg : __gbeg + 1),
                               __gend, __first, __last - *__gbeg);
          __first = __last - *__gbeg;
          *__s++ = __sep;
        }
      do
        *__s++ = *__first++;
      while (__first != __last);
      return __s;
    }




  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template class ctype_byname<char>;
  extern template class ctype_byname<wchar_t>;
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template class collate<char>;
  extern template class collate_byname<char>;
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(locale const&);

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);


  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);
}
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/locale" 2 3
# 38 "/usr/include/gcc/darwin/3.1/g++-v3/bits/ostream.tcc" 2 3

namespace std
{
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT,_Traits>& __os)
    : _M_ok(__os.good()), _M_os(__os)
    {

      if (_M_ok && __os.tie())
        __os.tie()->flush();
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ostream_type& (*__pf)(__ostream_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__ios_type& (*__pf)(__ios_type&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(ios_base& (*__pf)(ios_base&))
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            { __pf(*this); }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              streamsize __xtrct = 0;
              if (__sbin)
                {
                  __streambuf_type* __sbout = this->rdbuf();
                  __xtrct = __copy_streambufs(*this, __sbin, __sbout);
                }
              else
                this->setstate(ios_base::badbit);
              if (!__xtrct)
                this->setstate(ios_base::failbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(bool __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long __l = static_cast<unsigned long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              char_type __c = this->fill();
              ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
              if (_M_check_facet(_M_fnumput))
                {
                  bool __b = false;
                  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))
                    {
                      unsigned long long __l;
                      __l = static_cast<unsigned long long>(__n);
                      __b = _M_fnumput->put(*this, *this, __c, __l).failed();
                    }
                  else
                    __b = _M_fnumput->put(*this, *this, __c, __n).failed();
                  if (__b)
                    this->setstate(ios_base::badbit);
                }
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(long double __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          try
            {
              if (_M_check_facet(_M_fnumput))
                if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())
                  this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::put(char_type __c)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          int_type __put = rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          streamsize __put = this->rdbuf()->sputn(__s, __n);
          if ( __put != __n)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::flush()
    {
      sentry __cerb(*this);
      if (__cerb)
        {
          if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
            this->setstate(ios_base::badbit);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::tellp()
    {
      pos_type __ret = pos_type(-1);
      if (!this->fail())
        __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __d)
    {
      if (!this->fail())
        {


          pos_type __err = this->rdbuf()->pubseekoff(__off, __d,
                                                     ios_base::out);


          if (__err == pos_type(off_type(-1)))
            this->setstate(ios_base::failbit);

        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              streamsize __w = __out.width();
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__w + 1)));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad(__out, __out.fill(), __pads, &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          catch(exception& __fail)
            {


              __out.setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
    }


  template <class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              streamsize __w = __out.width();
              char* __pads = static_cast<char*>(__builtin_alloca(__w + 1));
              __pads[0] = __c;
              streamsize __len = 1;
              if (__w > __len)
                {
                  __pad(__out, __out.fill(), __pads, &__c, __w, __len, false);
                  __len = __w;
                }
              __out.write(__pads, __len);
              __out.width(0);
            }
          catch(exception& __fail)
            {


              __out.setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
     }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              streamsize __w = __out.width();
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));
              if (__w > __len)
                {
                  __pad(__out, __out.fill(), __pads, __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          catch(exception& __fail)
            {


              __out.setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;



      typedef char_traits<char> __ctraits_type;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          size_t __clen = __ctraits_type::length(__s);
          _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * (__clen + 1)));
          for (size_t __i = 0; __i <= __clen; ++__i)
            __ws[__i] = __out.widen(__s[__i]);
          _CharT* __str = __ws;

          try
            {
              streamsize __len = static_cast<streamsize>(__clen);
              streamsize __w = __out.width();
              _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));

              if (__w > __len)
                {
                  __pad(__out, __out.fill(), __pads, __ws, __w, __len, false);
                  __str = __pads;
                  __len = __w;
                }
              __out.write(__str, __len);
              __out.width(0);
            }
          catch(exception& __fail)
            {


              __out.setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
    }


  template<class _Traits>
    basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      typedef basic_ostream<char, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          try
            {
              streamsize __w = __out.width();
              char* __pads = static_cast<char*>(__builtin_alloca(__w));
              streamsize __len = static_cast<streamsize>(_Traits::length(__s));
              if (__w > __len)
                {
                  __pad(__out, __out.fill(), __pads, __s, __w, __len, false);
                  __s = __pads;
                  __len = __w;
                }
              __out.write(__s, __len);
              __out.width(0);
            }
          catch(exception& __fail)
            {


              __out.setstate(ios_base::badbit);
              if ((__out.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __out;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out,
               const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
        {
          const _CharT* __s = __str.data();
          streamsize __w = __out.width();
          _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __w));
          streamsize __len = static_cast<streamsize>(__str.size());



          if (__w > __len)
            {
              __pad(__out, __out.fill(), __pads, __s, __w, __len, false);
              __s = __pads;
              __len = __w;
            }
          streamsize __res = __out.rdbuf()->sputn(__s, __len);
          __out.width(0);
          if (__res != __len)
            __out.setstate(ios_base::failbit);
        }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
}
# 276 "/usr/include/gcc/darwin/3.1/g++-v3/ostream" 2 3
# 46 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 2 3
# 1 "/usr/include/gcc/darwin/3.1/g++-v3/istream" 1 3
# 43 "/usr/include/gcc/darwin/3.1/g++-v3/istream" 3




namespace std
{

  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef istreambuf_iterator<_CharT, _Traits> __istreambuf_iter;
      typedef num_get<_CharT, __istreambuf_iter> __numget_type;
      typedef ctype<_CharT> __ctype_type;

    protected:

      streamsize _M_gcount;

    public:

      explicit
      basic_istream(__streambuf_type* __sb)
      {
        this->init(__sb);
        _M_gcount = streamsize(0);
      }

      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;



      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&));

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&));

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&));


      __istream_type&
      operator>>(bool& __n);

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n);

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n);

      __istream_type&
      operator>>(long& __n);

      __istream_type&
      operator>>(unsigned long& __n);


      __istream_type&
      operator>>(long long& __n);

      __istream_type&
      operator>>(unsigned long long& __n);


      __istream_type&
      operator>>(float& __f);

      __istream_type&
      operator>>(double& __f);

      __istream_type&
      operator>>(long double& __f);

      __istream_type&
      operator>>(void*& __p);

      __istream_type&
      operator>>(__streambuf_type* __sb);


      inline streamsize
      gcount(void) const
      { return _M_gcount; }

      int_type
      get(void);

      __istream_type&
      get(char_type& __c);

      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);

      inline __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }

      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);

      inline __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }

      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);

      inline __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }

      __istream_type&
      ignore(streamsize __n = 1, int_type __delim = traits_type::eof());

      int_type
      peek(void);

      __istream_type&
      read(char_type* __s, streamsize __n);

      streamsize
      readsome(char_type* __s, streamsize __n);

      __istream_type&
      putback(char_type __c);

      __istream_type&
      unget(void);

      int
      sync(void);

      pos_type
      tellg(void);

      __istream_type&
      seekg(pos_type);

      __istream_type&
      seekg(off_type, ios_base::seekdir);
    };

  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
    public:
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;

      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);

      operator bool() { return _M_ok; }

    private:
      bool _M_ok;
    };


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    basic_istream<char,_Traits>&
    operator>>(basic_istream<char,_Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }


  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;

      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb)
      { }

      virtual
      ~basic_iostream() { }
    };


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
}





# 1 "/usr/include/gcc/darwin/3.1/g++-v3/bits/istream.tcc" 1 3
# 36 "/usr/include/gcc/darwin/3.1/g++-v3/bits/istream.tcc" 3




namespace std
{
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)
    {
      if (__in.good())
        {
          if (__in.tie())
            __in.tie()->flush();
          if (!__noskipws && (__in.flags() & ios_base::skipws))
            {
              const __int_type __eof = traits_type::eof();
              __streambuf_type* __sb = __in.rdbuf();
              __int_type __c = __sb->sgetc();

              if (__in._M_check_facet(__in._M_fctype))
                while (__c != __eof
                       && __in._M_fctype->is(ctype_base::space, __c))
                  __c = __sb->snextc();



              if (__c == __eof)
                __in.setstate(ios_base::eofbit);

            }
        }

      if (__in.good())
        _M_ok = true;
      else
        {
          _M_ok = false;
          __in.setstate(ios_base::failbit);
        }
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__istream_type& (*__pf)(__istream_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__ios_type& (*__pf)(__ios_type&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(ios_base& (*__pf)(ios_base&))
    {
      __pf(*this);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(bool& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<short>::min() <= __l
                      && __l <= numeric_limits<short>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              long __l;
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __l);


              if (!(__err & ios_base::failbit)
                  && (numeric_limits<int>::min() <= __l
                      && __l <= numeric_limits<int>::max()))
                __n = __l;
              else
                __err |= ios_base::failbit;

              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
              throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(unsigned long long& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(float& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(long double& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(void*& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
        {
          try
            {
              ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);
              if (_M_check_facet(_M_fnumget))
                _M_fnumget->get(*this, 0, *this, __err, __n);
              this->setstate(__err);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
       sentry __cerb(*this, false);
       if (__cerb)
         {
           try
             {
               streamsize __xtrct = 0;
               if (__sbout)
                 {
                   __streambuf_type* __sbin = this->rdbuf();
                   __xtrct = __copy_streambufs(*this, __sbin, __sbout);
                 }
               if (!__sbout || !__xtrct)
                 this->setstate(ios_base::failbit);
             }
           catch(exception& __fail)
             {


               this->setstate(ios_base::badbit);
               if ((this->exceptions() & ios_base::badbit) != 0)
                 throw;
             }
         }
       return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              __c = this->rdbuf()->sbumpc();

              if (__c != __eof)
                _M_gcount = 1;
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              int_type __bufval = this->rdbuf()->sbumpc();

              if (__bufval != __eof)
                {
                  _M_gcount = 1;
                  __c = traits_type::to_char_type(__bufval);
                }
              else
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n && __c != __eof && __c != __idelim)
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (__c == __eof)
                this->setstate(ios_base::eofbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __this_sb = this->rdbuf();
              int_type __c = __this_sb->sgetc();

              while (__c != __eof && __c != __idelim
                     && (__sb.sputc(traits_type::to_char_type(__c)) != __eof))
                {
                  ++_M_gcount;
                  __c = __this_sb->snextc();
                }
              if (__c == __eof)
                this->setstate(ios_base::eofbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n && __c != __eof && __c != __idelim)
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (__c == __eof)
                this->setstate(ios_base::eofbit);
              else
                {
                  if (__c == __idelim)
                    {
                      __sb->snextc();
                      ++_M_gcount;
                    }
                  else
                    this->setstate(ios_base::failbit);
                }
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      *__s = char_type();
      if (!_M_gcount)
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sbumpc();
              bool __testdelim = __c == __idelim;
              bool __testeof = __c == __eof;

              __n = min(__n, numeric_limits<streamsize>::max());
              while (_M_gcount < __n - 1 && !__testeof && !__testdelim)
                {
                  ++_M_gcount;
                  __c = __sb->sbumpc();
                  __testeof = __c == __eof;
                  __testdelim = __c == __idelim;
                }
              if ((_M_gcount == __n - 1 && !__testeof) || __testdelim)
                ++_M_gcount;
              if (__testeof)
                this->setstate(ios_base::eofbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            { __c = this->rdbuf()->sgetc(); }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount < __n && __c != __eof)
                {
                  *__s++ = traits_type::to_char_type(__c);
                  ++_M_gcount;
                  __c = __sb->snextc();
                }
              if (__c == __eof)
                this->setstate(ios_base::eofbit | ios_base::failbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              streamsize __num = this->rdbuf()->in_avail();
              if (__num != static_cast<streamsize>(__eof))
                {
                  __num = min(__num, __n);
                  if (__num)
                    _M_gcount = this->rdbuf()->sgetn(__s, __num);
                }
              else
                this->setstate(ios_base::eofbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb || __sb->sputbackc(__c) == __eof)
                this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb || __eof == __sb->sungetc())
                this->setstate(ios_base::badbit);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        this->setstate(ios_base::failbit);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      int __ret = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              __streambuf_type* __sb = this->rdbuf();
              if (!__sb || __ret == __sb->pubsync())
                this->setstate(ios_base::badbit);
              else
                __ret = 0;
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      pos_type __ret = pos_type(-1);
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
             __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return __ret;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {


              pos_type __err = this->rdbuf()->pubseekpos(__pos, ios_base::in);


              if (__err == pos_type(off_type(-1)))
                this->setstate(ios_base::failbit);

            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {


              pos_type __err = this->rdbuf()->pubseekoff(__off, __dir,
                                                         ios_base::in);


              if (__err == pos_type(off_type(-1)))
                this->setstate(ios_base::failbit);

            }
          catch(exception& __fail)
            {


              this->setstate(ios_base::badbit);
              if ((this->exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          try
            { __in.get(__c); }
          catch(exception& __fail)
            {


              __in.setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      else
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
      streamsize __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          try
            {

              streamsize __num = __in.width();
              if (__num == 0)
                __num = numeric_limits<streamsize>::max();

              const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
              const int_type __eof = _Traits::eof();
              __streambuf_type* __sb = __in.rdbuf();
              int_type __c = __sb->sgetc();

              while (__extracted < __num - 1
                     && __c != __eof && !__ctype.is(ctype_base::space, __c))
                {
                  *__s++ = __c;
                  ++__extracted;
                  __c = __sb->snextc();
                }
              if (__c == __eof)
                __in.setstate(ios_base::eofbit);



              *__s = char_type();

              __in.width(0);
            }
          catch(exception& __fail)
            {


              __in.setstate(ios_base::badbit);
              if ((__in.exceptions() & ios_base::badbit) != 0)
                throw;
            }
        }
      if (!__extracted)
        __in.setstate(ios_base::failbit);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT,_Traits>&
    ws(basic_istream<_CharT,_Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename __istream_type::int_type __int_type;

      const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (__c != __eof && __ctype.is(ctype_base::space, __c))
        __c = __sb->snextc();
      if (__c == __eof)
        __in.setstate(ios_base::eofbit);

      return __in;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
               basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
        {
          __str.erase();
          streamsize __w = __in.width();
          __size_type __n;
          __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();

          const __ctype_type& __ctype = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sgetc();

          while (__extracted < __n
                 && __c != __eof && !__ctype.is(ctype_base::space, __c))
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->snextc();
            }
          if (__c == __eof)
            __in.setstate(ios_base::eofbit);
          __in.width(0);
        }


      if (!__extracted)
        __in.setstate (ios_base::failbit);

      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __istream_type::__streambuf_type __streambuf_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      bool __testdelim = false;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
        {
          __str.erase();
          __size_type __n = __str.max_size();

          __int_type __idelim = _Traits::to_int_type(__delim);
          __streambuf_type* __sb = __in.rdbuf();
          __int_type __c = __sb->sbumpc();
          const __int_type __eof = _Traits::eof();
          __testdelim = __c == __idelim;

          while (__extracted <= __n && __c != __eof && !__testdelim)
            {
              __str += _Traits::to_char_type(__c);
              ++__extracted;
              __c = __sb->sbumpc();
              __testdelim = __c == __idelim;
            }
          if (__c == __eof)
            __in.setstate(ios_base::eofbit);
        }
      if (!__extracted && !__testdelim)
        __in.setstate(ios_base::failbit);
      return __in;
    }

  template<class _CharT, class _Traits, class _Alloc>
    inline basic_istream<_CharT,_Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
            basic_string<_CharT,_Traits,_Alloc>& __str)
    { return getline(__in, __str, __in.widen('\n')); }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
}
# 288 "/usr/include/gcc/darwin/3.1/g++-v3/istream" 2 3
# 47 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 2 3

namespace std
{
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;
# 62 "/usr/include/gcc/darwin/3.1/g++-v3/iostream" 3
  static ios_base::Init __ioinit;
}
# 11 "services.cpp" 2

# 1 "config.h" 1
# 13 "services.cpp" 2
# 1 "services.h" 1
# 15 "services.h"
# 1 "server.h" 1
# 13 "server.h"
# 1 "/usr/include/errno.h" 1 3 4
# 14 "server.h" 2

# 1 "/usr/include/netdb.h" 1 3 4
# 84 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/sys/param.h" 1 3 4
# 102 "/usr/include/sys/param.h" 3 4
# 1 "/usr/include/machine/param.h" 1 3 4
# 30 "/usr/include/machine/param.h" 3 4
# 1 "/usr/include/ppc/param.h" 1 3 4
# 31 "/usr/include/machine/param.h" 2 3 4
# 103 "/usr/include/sys/param.h" 2 3 4
# 85 "/usr/include/netdb.h" 2 3 4
# 93 "/usr/include/netdb.h" 3 4
extern int h_errno;






struct hostent {
        char *h_name;
        char **h_aliases;
        int h_addrtype;
        int h_length;
        char **h_addr_list;

};





struct netent {
        char *n_name;
        char **n_aliases;
        int n_addrtype;
        unsigned long n_net;
};

struct servent {
        char *s_name;
        char **s_aliases;
        int s_port;
        char *s_proto;
};

struct protoent {
        char *p_name;
        char **p_aliases;
        int p_proto;
};

struct addrinfo {
        int ai_flags;
        int ai_family;
        int ai_socktype;
        int ai_protocol;
        size_t ai_addrlen;
        char *ai_canonname;
        struct sockaddr *ai_addr;
        struct addrinfo *ai_next;
};

struct rpcent {
        char *r_name;
        char **r_aliases;
        int r_number;
};
# 218 "/usr/include/netdb.h" 3 4
extern "C" {
void endhostent (void);
void endnetent (void);
void endprotoent (void);
void endservent (void);
void freehostent (struct hostent *);
struct hostent *gethostbyaddr (const char *, int, int);
struct hostent *gethostbyname (const char *);
struct hostent *gethostbyname2 (const char *, int);
struct hostent *gethostent (void);
struct hostent *getipnodebyaddr (const void *, size_t, int, int *);
struct hostent *getipnodebyname (const char *, int, int, int *);
struct netent *getnetbyaddr (long, int);
struct netent *getnetbyname (const char *);
struct netent *getnetent (void);
struct protoent *getprotobyname (const char *);
struct protoent *getprotobynumber (int);
struct protoent *getprotoent (void);
struct servent *getservbyname (const char *, const char *);
struct servent *getservbyport (int, const char *);
struct servent *getservent (void);
struct rpcent *getrpcbyname (const char *name);
struct rpcent *getrpcbynumber (long number);
struct rpcent *getrpcent (void);
void setrpcent (int stayopen);
void endrpcent (void);

void herror (const char *);
char *hstrerror (int);
void sethostent (int);

void setnetent (int);
void setprotoent (int);
void setservent (int);

char *gai_strerror (int);
void freeaddrinfo (struct addrinfo *);
int getaddrinfo (const char *, const char *, const struct addrinfo *, struct addrinfo **);
int getnameinfo (const struct sockaddr *, size_t, char *, size_t, char *, size_t, int);
}
# 16 "server.h" 2

# 1 "/usr/include/netinet/in.h" 1 3 4
# 254 "/usr/include/netinet/in.h" 3 4
struct in_addr {
        in_addr_t s_addr;
};
# 311 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in {
        u_char sin_len;
        u_char sin_family;
        u_short sin_port;
        struct in_addr sin_addr;
        char sin_zero[8];
};
# 328 "/usr/include/netinet/in.h" 3 4
struct ip_opts {
        struct in_addr ip_dst;
        char ip_opts[40];
};
# 396 "/usr/include/netinet/in.h" 3 4
struct ip_mreq {
        struct in_addr imr_multiaddr;
        struct in_addr imr_interface;
};
# 517 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/netinet6/in6.h" 1 3 4
# 121 "/usr/include/netinet6/in6.h" 3 4
struct in6_addr {
        union {
                u_int8_t __u6_addr8[16];
                u_int16_t __u6_addr16[8];
                u_int32_t __u6_addr32[4];
        } __u6_addr;
};
# 144 "/usr/include/netinet6/in6.h" 3 4
struct sockaddr_in6 {
        u_int8_t sin6_len;
        u_int8_t sin6_family;
        u_int16_t sin6_port;
        u_int32_t sin6_flowinfo;
        struct in6_addr sin6_addr;
        u_int32_t sin6_scope_id;
};
# 222 "/usr/include/netinet6/in6.h" 3 4
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
extern const struct in6_addr in6addr_nodelocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allrouters;
# 382 "/usr/include/netinet6/in6.h" 3 4
struct route_in6 {
        struct rtentry *ro_rt;
        struct sockaddr_in6 ro_dst;
};
# 453 "/usr/include/netinet6/in6.h" 3 4
struct ipv6_mreq {
        struct in6_addr ipv6mr_multiaddr;
        unsigned int ipv6mr_interface;
};




struct in6_pktinfo {
        struct in6_addr ipi6_addr;
        unsigned int ipi6_ifindex;
};
# 612 "/usr/include/netinet6/in6.h" 3 4
extern "C" {
struct cmsghdr;

extern int inet6_option_space (int);
extern int inet6_option_init (void *, struct cmsghdr **, int);
extern int inet6_option_append (struct cmsghdr *, const u_int8_t *, int, int);

extern u_int8_t *inet6_option_alloc (struct cmsghdr *, int, int, int);
extern int inet6_option_next (const struct cmsghdr *, u_int8_t **);
extern int inet6_option_find (const struct cmsghdr *, u_int8_t **, int);

extern size_t inet6_rthdr_space (int, int);
extern struct cmsghdr *inet6_rthdr_init (void *, int);
extern int inet6_rthdr_add (struct cmsghdr *, const struct in6_addr *, unsigned int);

extern int inet6_rthdr_lasthop (struct cmsghdr *, unsigned int);



extern int inet6_rthdr_segments (const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr (struct cmsghdr *, int);
extern int inet6_rthdr_getflags (const struct cmsghdr *, int);

extern int inet6_opt_init (void *, size_t);
extern int inet6_opt_append (void *, size_t, int, u_int8_t, size_t, u_int8_t, void **);

extern int inet6_opt_finish (void *, size_t, int);
extern int inet6_opt_set_val (void *, size_t, void *, int);

extern int inet6_opt_next (void *, size_t, int, u_int8_t *, size_t *, void **);

extern int inet6_opt_find (void *, size_t, int, u_int8_t, size_t *, void **);

extern int inet6_opt_get_val (void *, size_t, void *, int);
extern size_t inet6_rth_space (int, int);
extern void *inet6_rth_init (void *, int, int, int);
extern int inet6_rth_add (void *, const struct in6_addr *);
extern int inet6_rth_reverse (const void *, void *);
extern int inet6_rth_segments (const void *);
extern struct in6_addr *inet6_rth_getaddr (const void *, int);
}
# 518 "/usr/include/netinet/in.h" 2 3 4
# 18 "server.h" 2
# 1 "/usr/include/sys/socket.h" 1 3 4
# 77 "/usr/include/sys/socket.h" 3 4
typedef u_char sa_family_t;
# 135 "/usr/include/sys/socket.h" 3 4
struct linger {
        int l_onoff;
        int l_linger;
};
# 211 "/usr/include/sys/socket.h" 3 4
struct sockaddr {
        u_char sa_len;
        u_char sa_family;
        char sa_data[14];
};






struct sockproto {
        u_short sp_family;
        u_short sp_protocol;
};
# 236 "/usr/include/sys/socket.h" 3 4
struct sockaddr_storage {
        u_char ss_len;
        sa_family_t ss_family;
        char __ss_pad1[((sizeof(int64_t)) - sizeof(u_char) - sizeof(sa_family_t))];
        int64_t __ss_align;
        char __ss_pad2[(128 - sizeof(u_char) - sizeof(sa_family_t) - ((sizeof(int64_t)) - sizeof(u_char) - sizeof(sa_family_t)) - (sizeof(int64_t)))];
};
# 371 "/usr/include/sys/socket.h" 3 4
struct msghdr {
        caddr_t msg_name;
        u_int msg_namelen;
        struct iovec *msg_iov;
        u_int msg_iovlen;
        caddr_t msg_control;
        u_int msg_controllen;
        int msg_flags;
};
# 405 "/usr/include/sys/socket.h" 3 4
struct cmsghdr {
        u_int cmsg_len;
        int cmsg_level;
        int cmsg_type;

};
# 468 "/usr/include/sys/socket.h" 3 4
struct osockaddr {
        u_short sa_family;
        char sa_data[14];
};




struct omsghdr {
        caddr_t msg_name;
        int msg_namelen;
        struct iovec *msg_iov;
        int msg_iovlen;
        caddr_t msg_accrights;
        int msg_accrightslen;
};
# 508 "/usr/include/sys/socket.h" 3 4
extern "C" {
int accept (int, struct sockaddr *, int *);
int bind (int, const struct sockaddr *, int);
int connect (int, const struct sockaddr *, int);
int getpeername (int, struct sockaddr *, int *);
int getsockname (int, struct sockaddr *, int *);
int getsockopt (int, int, int, void *, int *);
int listen (int, int);
ssize_t recv (int, void *, size_t, int);
ssize_t recvfrom (int, void *, size_t, int, struct sockaddr *, int *);
ssize_t recvmsg (int, struct msghdr *, int);
ssize_t send (int, const void *, size_t, int);
ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, int);

ssize_t sendmsg (int, const struct msghdr *, int);



int setsockopt (int, int, int, const void *, int);
int shutdown (int, int);
int socket (int, int, int);
int socketpair (int, int, int, int *);

void pfctlinput (int, struct sockaddr *);
}
# 19 "server.h" 2

class Server
{

  public:

         char *local_host;

         char *local_gecos;

         char *local_sid;

         int local_ts;


         char *remote_host;

         int port;

         bool connected;


  private:

         int sockfd;


  public:





         Server(char *i_hostname, char *i_description);
         Server(char *i_hostname, char *i_description, char *i_sid);


         Server();
         ~Server();


         bool connect(char *r_hostname, int r_port, char *password);


    char *gets();

         bool puts(char *fmt, ...);


    bool disconnect();

  private:


  public:
    static char *genSID();
         bool link(char *password);
};
# 16 "services.h" 2
# 1 "parser.h" 1
# 13 "parser.h"
# 1 "protocol.h" 1
# 14 "protocol.h"
using namespace std;

class Protocol
{
  public:
    static bool signon(Server serv,
                            const char *sid, const char *nick, int hops,
                                                          const char *umode, const char *user, const char *host,
                                                          const char *vhost, const char *ip,
                                                          const char *uid, const char *gecos);
    static bool Protocol::sjoin(Server serv,
                  const char *sid, const char *chan, const char *mode, const char *user);
    static const char *genSID();
    static const char *genUID(const char *sid);
};
# 14 "parser.h" 2

typedef enum {
  MSG_INVALID = -1, MSG_CLIENTSERVER, MSG_LOW
} msg_type;

typedef enum {
  SENDER_INVALID = -1, SENDER_SERVER, SENDER_NICK, SENDER_SID, SENDER_UID
} sender_type;

class Parser
{
  public:
    Server serv;
         char *cmdargs;
         char *longarg;

         char *command;
         char *sender;
         char *args;
  private:
         msg_type mtype;
         sender_type stype;
  public:
    Parser(Server i_serv);
         void parse(char *line);
         void inspect();
  private:
    void freeall();
};
# 17 "services.h" 2


void GenServices();
void StartServices(Server *server);
void ExecServices();

typedef struct {
  unsigned privmsg: 1;
  unsigned chanmsg: 1;
  unsigned notice: 1;
  unsigned nick: 1;
  unsigned join: 1;
  unsigned mode: 1;
  unsigned kick: 1;
  unsigned topic: 1;
} Filter;

class Service
{
  public:
         string uid;
    string name;
         string nick;
         string user;
         string host;
         string gecos;
         Filter filter;
         Server *serv;
         Service(string name, string nick, string user, string host, string gecos);
    void setFilter(Filter filter);
         void init(Server *server);
};
# 14 "services.cpp" 2





# 1 "nickserv.cpp" 1
# 13 "nickserv.cpp"
# 1 "nickserv.h" 1
# 20 "nickserv.h"
class NickServ : public Service
{
  public:
    NickServ(string name, string nick, string user, string host, string gecos);
         void init(Server *server);
};
# 14 "nickserv.cpp" 2

NickServ::NickServ(string name, string nick, string user,
                        string host, string gecos)
                                        : Service(name, nick, user, host, gecos)
{
}


void NickServ::init(Server *server)
{
  Service::init(server);
  Protocol::sjoin(*server, server->local_sid, "#kageserv", "Ont", uid.c_str());
}
# 20 "services.cpp" 2


static int lastserv = 0;
static Service servs[16;];
static Filter default_filter = {1, 1, 1, 1, 1, 1, 1, 1};

Service::Service(string name_, string nick_, string user_, string host_, string gecos_)
{
  name = name_;
  nick = nick_;
  user = user_;
  host = host_;
  gecos = gecos_;
  filter = default_filter;
}

void Service::setFilter(Filter filter_)
{
  filter = filter_;
}

void Service::init(Server *server)
{
  serv = server;
  uid = Protocol::genUID(server->local_sid);
  Protocol::signon(*server,
                  server->local_sid, nick.c_str(), 1, "aoeS",
                                                user.c_str(), server->local_host, host.c_str(), "127.0.0.1",
                                                uid.c_str(), gecos.c_str());
}

void GenServices()
{

  servs[lastserv] = NickServ("NickServ", "NicServ", "services",
       "services.pwnix.org", "Nickname Services");
  lastserv++;

}

void StartServices(Server *server)
{
  for (int i; i < lastserv; i++)
    servs[i].init(server);
}

void ExecServices()
{

}
